<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<title>SGScript documentation - v0.9.0</title>
	<link rel='stylesheet' type='text/css' href='sgscript-docs.css'>
	<script type='text/javascript' src='sgscript-docs.js'></script>
</head><body>
<h1>SGScript documentation - v0.9.0</h1><div><h2>Table of Contents</h2><ul><li><a href='#SGScript---description-info'>SGScript - description [info]</a></li><li><a href='#SGScript-Virtual-Machine-info'>SGScript Virtual Machine [info]</a></li><li><a href='#Commonly-required-advanced-tasks-info'>Commonly required advanced tasks [info]</a></li><li><a href='#Main-types-info'>Main types [info]</a></li><li><a href='#Error-codes-info'>Error codes [info]</a></li><li><a href='#Variable-type-flags-info'>Variable type flags [info]</a></li><li><a href='#Object-operation-types-info'>Object operation types [info]</a></li><li><a href='#Interaction-with-the-native-environment-info'>Interaction with the native environment [info]</a></li><li><a href='#sgs_CreateEngine-function-alias'>sgs_CreateEngine [function alias]</a></li><li><a href='#sgs_CreateEngineExt-function'>sgs_CreateEngineExt [function]</a></li><li><a href='#sgs_DestroyEngine-function'>sgs_DestroyEngine [function]</a></li><li><a href='#sgs_ExecString-function-alias'>sgs_ExecString [function alias]</a></li><li><a href='#sgs_ExecBuffer-function-alias'>sgs_ExecBuffer [function alias]</a></li><li><a href='#sgs_EvalString-function-alias'>sgs_EvalString [function alias]</a></li><li><a href='#sgs_EvalBuffer-function'>sgs_EvalBuffer [function]</a></li><li><a href='#sgs_ExecFile-function-alias'>sgs_ExecFile [function alias]</a></li><li><a href='#sgs_EvalFile-function'>sgs_EvalFile [function]</a></li><li><a href='#sgs_LoadLib_[Fmt|IO|Math|OS|String]-functions'>sgs_LoadLib_[Fmt|IO|Math|OS|String] [functions]</a></li><li><a href='#sgs_Reg[Func|Int|Real]Const-struct'>sgs_Reg[Func|Int|Real]Const [struct]</a></li><li><a href='#sgs_Reg[Func|Int|Real]Consts-function'>sgs_Reg[Func|Int|Real]Consts [function]</a></li><li><a href='#sgs_Push[Null|Bool|Int|Real|StringBuf|String|CFunction|Object|ObjectIPA|Variable]-functions'>sgs_Push[Null|Bool|Int|Real|StringBuf|String|CFunction|Object|ObjectIPA|Variable] [functions]</a></li><li><a href='#sgs_Pop-function'>sgs_Pop [function]</a></li><li><a href='#sgs_PopSkip-function'>sgs_PopSkip [function]</a></li><li><a href='#sgs_InsertVariable-function'>sgs_InsertVariable [function]</a></li><li><a href='#sgs_PushArray-function'>sgs_PushArray [function]</a></li><li><a href='#sgs_PushDict-function'>sgs_PushDict [function]</a></li><li><a href='#sgs_PushItem-function'>sgs_PushItem [function]</a></li><li><a href='#sgs_StoreItem-function'>sgs_StoreItem [function]</a></li><li><a href='#sgs_PushProperty-function'>sgs_PushProperty [function]</a></li><li><a href='#sgs_StoreProperty-function'>sgs_StoreProperty [function]</a></li><li><a href='#sgs_PushNumIndex-function'>sgs_PushNumIndex [function]</a></li><li><a href='#sgs_StoreNumIndex-function'>sgs_StoreNumIndex [function]</a></li><li><a href='#sgs_PushIndexExt-function'>sgs_PushIndexExt [function]</a></li><li><a href='#sgs_PushIndex-function-alias'>sgs_PushIndex [function alias]</a></li><li><a href='#sgs_PushIndexP-function'>sgs_PushIndexP [function]</a></li><li><a href='#sgs_StoreIndexExt-function'>sgs_StoreIndexExt [function]</a></li><li><a href='#sgs_StoreIndex-function-alias'>sgs_StoreIndex [function alias]</a></li><li><a href='#sgs_StoreIndexP-function'>sgs_StoreIndexP [function]</a></li><li><a href='#sgs_PushGlobal-function'>sgs_PushGlobal [function]</a></li><li><a href='#sgs_StoreGlobal-function'>sgs_StoreGlobal [function]</a></li><li><a href='#sgs_PushPath-function'>sgs_PushPath [function]</a></li><li><a href='#sgs_StorePath-function'>sgs_StorePath [function]</a></li><li><a href='#sgs_ArgErrorExt-function'>sgs_ArgErrorExt [function]</a></li><li><a href='#sgs_ArgError-function'>sgs_ArgError [function]</a></li><li><a href='#sgs_[FuncArgError|MethodArgError]-function-aliases'>sgs_[FuncArgError|MethodArgError] [function aliases]</a></li><li><a href='#sgs_LoadArgsExt-function'>sgs_LoadArgsExt [function]</a></li><li><a href='#sgs_LoadArgs-function-alias'>sgs_LoadArgs [function alias]</a></li><li><a href='#sgs_FCall-function'>sgs_FCall [function]</a></li><li><a href='#sgs_[Call|ThisCall]-function-aliases'>sgs_[Call|ThisCall] [function aliases]</a></li><li><a href='#sgs_GlobalCall-function'>sgs_GlobalCall [function]</a></li><li><a href='#sgs_TypeOf-function'>sgs_TypeOf [function]</a></li><li><a href='#sgs_DumpVar-function'>sgs_DumpVar [function]</a></li><li><a href='#sgs_GCExecute-function'>sgs_GCExecute [function]</a></li><li><a href='#sgs_PadString-function'>sgs_PadString [function]</a></li><li><a href='#sgs_StringConcat-function'>sgs_StringConcat [function]</a></li><li><a href='#sgs_StringMultiConcat-function'>sgs_StringMultiConcat [function]</a></li><li><a href='#sgs_CloneItem-function'>sgs_CloneItem [function]</a></li><li><a href='#sgs_Serialize-function'>sgs_Serialize [function]</a></li><li><a href='#sgs_SerializeObject-function'>sgs_SerializeObject [function]</a></li><li><a href='#sgs_Unserialize-function'>sgs_Unserialize [function]</a></li><li><a href='#sgs_CompareF-function'>sgs_CompareF [function]</a></li><li><a href='#sgs_Compare-function-alias'>sgs_Compare [function alias]</a></li><li><a href='#sgs_EqualTypes-function'>sgs_EqualTypes [function]</a></li><li><a href='#sgs_[GetBool|GetInt|GetReal]-functions'>sgs_[GetBool|GetInt|GetReal] [functions]</a></li><li><a href='#sgs_[ToBool|ToInt|ToReal]-functions'>sgs_[ToBool|ToInt|ToReal] [functions]</a></li><li><a href='#sgs_[ToStringBuf|ToStringBufFast]-functions'>sgs_[ToStringBuf|ToStringBufFast] [functions]</a></li><li><a href='#sgs_[ToString|ToStringFast]-function-aliases'>sgs_[ToString|ToStringFast] [function aliases]</a></li><li><a href='#sgs_Convert-function'>sgs_Convert [function]</a></li><li><a href='#sgs_RegisterType-function'>sgs_RegisterType [function]</a></li><li><a href='#sgs_UnregisterType-function'>sgs_UnregisterType [function]</a></li><li><a href='#sgs_FindType-function'>sgs_FindType [function]</a></li><li><a href='#sgs_IsObject-function'>sgs_IsObject [function]</a></li><li><a href='#sgs_IsType-function-alias'>sgs_IsType [function alias]</a></li><li><a href='#sgs_IsCallable-function'>sgs_IsCallable [function]</a></li><li><a href='#sgs_IsNumericString-function'>sgs_IsNumericString [function]</a></li><li><a href='#sgs_[ParseBool|ParseInt|ParseReal|ParseString]-functions'>sgs_[ParseBool|ParseInt|ParseReal|ParseString] [functions]</a></li><li><a href='#sgs_PushIterator-function'>sgs_PushIterator [function]</a></li><li><a href='#sgs_IterAdvance-function'>sgs_IterAdvance [function]</a></li><li><a href='#sgs_IterPushData-function'>sgs_IterPushData [function]</a></li><li><a href='#sgs_ArraySize-function'>sgs_ArraySize [function]</a></li><li><a href='#sgs_StackSize-function'>sgs_StackSize [function]</a></li><li><a href='#sgs_IsValidIndex-function'>sgs_IsValidIndex [function]</a></li><li><a href='#sgs_GetStackItem-function'>sgs_GetStackItem [function]</a></li><li><a href='#sgs_ItemType-function'>sgs_ItemType [function]</a></li><li><a href='#sgs_ItemTypeExt-function'>sgs_ItemTypeExt [function]</a></li><li><a href='#sgs_Method-function'>sgs_Method [function]</a></li><li><a href='#sgs_Acquire-function'>sgs_Acquire [function]</a></li><li><a href='#sgs_Release-function'>sgs_Release [function]</a></li><li><a href='#sgs_ReleaseOwned-function'>sgs_ReleaseOwned [function]</a></li><li><a href='#sgs_GCMark-function'>sgs_GCMark [function]</a></li><li><a href='#sgs_GetStringPtr-function'>sgs_GetStringPtr [function]</a></li><li><a href='#sgs_GetStringSize-function'>sgs_GetStringSize [function]</a></li><li><a href='#sgs_GetObjectData-function'>sgs_GetObjectData [function]</a></li><li><a href='#sgs_SetOutputFunc-function'>sgs_SetOutputFunc [function]</a></li><li><a href='#sgs_Write-function'>sgs_Write [function]</a></li><li><a href='#sgs_WriteStr-function-alias'>sgs_WriteStr [function alias]</a></li><li><a href='#sgs_Writef-function'>sgs_Writef [function]</a></li><li><a href='#sgs_SetPrintFunc-function'>sgs_SetPrintFunc [function]</a></li><li><a href='#sgs_Printf-function'>sgs_Printf [function]</a></li><li><a href='#sgs_HasFuncName-function'>sgs_HasFuncName [function]</a></li><li><a href='#sgs_FuncName-function'>sgs_FuncName [function]</a></li><li><a href='#SGSFN-function-alias'>SGSFN [function alias]</a></li><li><a href='#SGSBASEFN-function-alias'>SGSBASEFN [function alias]</a></li><li><a href='#sgs_SetHookFunc-function'>sgs_SetHookFunc [function]</a></li><li><a href='#sgs_GetHookFunc-function'>sgs_GetHookFunc [function]</a></li><li><a href='#sgs_Memory-function'>sgs_Memory [function]</a></li><li><a href='#memory-allocation-macros-macros'>memory allocation macros [macros]</a></li><li><a href='#sgs_CodeString-function'>sgs_CodeString [function]</a></li><li><a href='#sgs_Abort-function'>sgs_Abort [function]</a></li><li><a href='#sgs_Stat-function'>sgs_Stat [function]</a></li><li><a href='#sgs_Cntl-function'>sgs_Cntl [function]</a></li><li><a href='#sgs_GetFramePtr-function'>sgs_GetFramePtr [function]</a></li><li><a href='#sgs_SetErrno-function-alias'>sgs_SetErrno [function alias]</a></li><li><a href='#sgs_GetLastErrno-function-alias'>sgs_GetLastErrno [function alias]</a></li><li><a href='#array-function'>array [function]</a></li><li><a href='#dict-function'>dict [function]</a></li><li><a href='#class-function'>class [function]</a></li><li><a href='#closure-function'>closure [function]</a></li><li><a href='#isset-function'>isset [function]</a></li><li><a href='#unset-function'>unset [function]</a></li><li><a href='#clone-function'>clone [function]</a></li><li><a href='#get_keys-function'>get_keys [function]</a></li><li><a href='#get_values-function'>get_values [function]</a></li><li><a href='#get_concat-function'>get_concat [function]</a></li><li><a href='#get_merged-function'>get_merged [function]</a></li><li><a href='#tobool-function'>tobool [function]</a></li><li><a href='#toint-function'>toint [function]</a></li><li><a href='#toreal-function'>toreal [function]</a></li><li><a href='#tostring-function'>tostring [function]</a></li><li><a href='#typeof-function'>typeof [function]</a></li><li><a href='#typeid-function'>typeid [function]</a></li><li><a href='#typeflags-function'>typeflags [function]</a></li><li><a href='#is_numeric-function'>is_numeric [function]</a></li><li><a href='#is_callable-function'>is_callable [function]</a></li><li><a href='#loadtypeflags-function'>loadtypeflags [function]</a></li><li><a href='#print,-println,-printlns-functions'>print, println, printlns [functions]</a></li><li><a href='#printvar_ext-function'>printvar_ext [function]</a></li><li><a href='#printvar-function'>printvar [function]</a></li><li><a href='#read_stdin-function'>read_stdin [function]</a></li><li><a href='#ftime-function'>ftime [function]</a></li><li><a href='#rand-function'>rand [function]</a></li><li><a href='#randf-function'>randf [function]</a></li><li><a href='#srand-function'>srand [function]</a></li><li><a href='#pcall-function'>pcall [function]</a></li><li><a href='#eval-function'>eval [function]</a></li><li><a href='#eval_file-function'>eval_file [function]</a></li><li><a href='#include_library-function'>include_library [function]</a></li><li><a href='#include_file-function'>include_file [function]</a></li><li><a href='#include_shared-function'>include_shared [function]</a></li><li><a href='#include-function'>include [function]</a></li><li><a href='#import_cfunc-function'>import_cfunc [function]</a></li><li><a href='#sys_curfile-function'>sys_curfile [function]</a></li><li><a href='#sys_print-function'>sys_print [function]</a></li><li><a href='#sys_abort-function'>sys_abort [function]</a></li><li><a href='#app_abort-function'>app_abort [function]</a></li><li><a href='#app_exit-function'>app_exit [function]</a></li><li><a href='#sys_replevel-function'>sys_replevel [function]</a></li><li><a href='#sys_stat-function'>sys_stat [function]</a></li><li><a href='#errno-function'>errno [function]</a></li><li><a href='#errno_string-function'>errno_string [function]</a></li><li><a href='#errno_value-function'>errno_value [function]</a></li><li><a href='#dumpvar_ext-function'>dumpvar_ext [function]</a></li><li><a href='#dumpvar-function'>dumpvar [function]</a></li><li><a href='#gc_collect-function'>gc_collect [function]</a></li><li><a href='#serialize-function'>serialize [function]</a></li><li><a href='#unserialize-function'>unserialize [function]</a></li><li><a href='#SGS_[INFO|WARNING|ERROR]-constants'>SGS_[INFO|WARNING|ERROR] [constants]</a></li><li><a href='#VT_[NULL|BOOL|INT|REAL|STRING|FUNC|CFUNC|OBJECT]-constants'>VT_[NULL|BOOL|INT|REAL|STRING|FUNC|CFUNC|OBJECT] [constants]</a></li><li><a href='#_G-superglobal'>_G [superglobal]</a></li><li><a href='#array-object'>array [object]</a></li><li><a href='#array.push-method'>array.push [method]</a></li><li><a href='#array.pop-method'>array.pop [method]</a></li><li><a href='#array.shift-method'>array.shift [method]</a></li><li><a href='#array.unshift-method'>array.unshift [method]</a></li><li><a href='#array.insert-method'>array.insert [method]</a></li><li><a href='#array.erase-method'>array.erase [method]</a></li><li><a href='#array.clear-method'>array.clear [method]</a></li><li><a href='#array.reverse-method'>array.reverse [method]</a></li><li><a href='#array.resize-method'>array.resize [method]</a></li><li><a href='#array.reserve-method'>array.reserve [method]</a></li><li><a href='#array.sort-method'>array.sort [method]</a></li><li><a href='#array.sort_custom-method'>array.sort_custom [method]</a></li><li><a href='#array.sort_mapped-method'>array.sort_mapped [method]</a></li><li><a href='#array.find-method'>array.find [method]</a></li><li><a href='#array.remove-method'>array.remove [method]</a></li><li><a href='#dict-object'>dict [object]</a></li><li><a href='#class-object'>class [object]</a></li><li><a href='#closure-object'>closure [object]</a></li><li><a href='#fmt_pack-function'>fmt_pack [function]</a></li><li><a href='#fmt_unpack-function'>fmt_unpack [function]</a></li><li><a href='#fmt_pack_count-function'>fmt_pack_count [function]</a></li><li><a href='#fmt_pack_size-function'>fmt_pack_size [function]</a></li><li><a href='#fmt_base64_encode-function'>fmt_base64_encode [function]</a></li><li><a href='#fmt_base64_decode-function'>fmt_base64_decode [function]</a></li><li><a href='#fmt_text-function'>fmt_text [function]</a></li><li><a href='#fmt_parser-function'>fmt_parser [function]</a></li><li><a href='#fmt_string_parser-function'>fmt_string_parser [function]</a></li><li><a href='#fmt_charcc-function'>fmt_charcc [function]</a></li><li><a href='#fmt_parser-object'>fmt_parser [object]</a></li><li><a href='#fmt_parser.read-method'>fmt_parser.read [method]</a></li><li><a href='#fmt_parser.getchar-method'>fmt_parser.getchar [method]</a></li><li><a href='#fmt_parser.readcc-method'>fmt_parser.readcc [method]</a></li><li><a href='#fmt_parser.skipcc-method'>fmt_parser.skipcc [method]</a></li><li><a href='#io_setcwd-function'>io_setcwd [function]</a></li><li><a href='#io_getcwd-function'>io_getcwd [function]</a></li><li><a href='#io_rename-function'>io_rename [function]</a></li><li><a href='#io_file_exists-function'>io_file_exists [function]</a></li><li><a href='#io_dir_exists-function'>io_dir_exists [function]</a></li><li><a href='#io_stat-function'>io_stat [function]</a></li><li><a href='#io_dir_create-function'>io_dir_create [function]</a></li><li><a href='#io_dir_delete-function'>io_dir_delete [function]</a></li><li><a href='#io_file_delete-function'>io_file_delete [function]</a></li><li><a href='#io_file_write-function'>io_file_write [function]</a></li><li><a href='#io_file_read-function'>io_file_read [function]</a></li><li><a href='#io_file-object'>io_file [object]</a></li><li><a href='#io_file.open-method'>io_file.open [method]</a></li><li><a href='#io_file.close-method'>io_file.close [method]</a></li><li><a href='#io_file.read-method'>io_file.read [method]</a></li><li><a href='#io_file.write-method'>io_file.write [method]</a></li><li><a href='#io_file.seek-method'>io_file.seek [method]</a></li><li><a href='#io_file.flush-method'>io_file.flush [method]</a></li><li><a href='#io_file.setbuf-method'>io_file.setbuf [method]</a></li><li><a href='#io_file-function'>io_file [function]</a></li><li><a href='#io_dir-(directory_iterator)-object'>io_dir (directory_iterator) [object]</a></li><li><a href='#io_dir-function'>io_dir [function]</a></li><li><a href='#FILE_[READ|WRITE]-constants'>FILE_[READ|WRITE] [constants]</a></li><li><a href='#SEEK_[SET|CUR|END]-constants'>SEEK_[SET|CUR|END] [constants]</a></li><li><a href='#FST_[UNKNOWN|FILE|DIR]-constants'>FST_[UNKNOWN|FILE|DIR] [constants]</a></li><li><a href='#abs-function'>abs [function]</a></li><li><a href='#floor-function'>floor [function]</a></li><li><a href='#ceil-function'>ceil [function]</a></li><li><a href='#round-function'>round [function]</a></li><li><a href='#pow-function'>pow [function]</a></li><li><a href='#sqrt-function'>sqrt [function]</a></li><li><a href='#log-function'>log [function]</a></li><li><a href='#sin-function'>sin [function]</a></li><li><a href='#cos-function'>cos [function]</a></li><li><a href='#tan-function'>tan [function]</a></li><li><a href='#asin-function'>asin [function]</a></li><li><a href='#acos-function'>acos [function]</a></li><li><a href='#atan-function'>atan [function]</a></li><li><a href='#atan2-function'>atan2 [function]</a></li><li><a href='#deg2rad-function'>deg2rad [function]</a></li><li><a href='#rad2deg-function'>rad2deg [function]</a></li><li><a href='#M_[PI|E]-constants'>M_[PI|E] [constants]</a></li><li><a href='#os_gettype-function'>os_gettype [function]</a></li><li><a href='#os_command-function'>os_command [function]</a></li><li><a href='#os_getenv-function'>os_getenv [function]</a></li><li><a href='#os_putenv-function'>os_putenv [function]</a></li><li><a href='#os_time-function'>os_time [function]</a></li><li><a href='#os_get_timezone-function'>os_get_timezone [function]</a></li><li><a href='#os_date_string-function'>os_date_string [function]</a></li><li><a href='#os_parse_time-function'>os_parse_time [function]</a></li><li><a href='#os_make_time-function'>os_make_time [function]</a></li><li><a href='#string_cut-function'>string_cut [function]</a></li><li><a href='#string_part-function'>string_part [function]</a></li><li><a href='#string_reverse-function'>string_reverse [function]</a></li><li><a href='#string_pad-function'>string_pad [function]</a></li><li><a href='#string_repeat-function'>string_repeat [function]</a></li><li><a href='#string_count-function'>string_count [function]</a></li><li><a href='#string_find-function'>string_find [function]</a></li><li><a href='#string_find_rev-function'>string_find_rev [function]</a></li><li><a href='#string_replace-function'>string_replace [function]</a></li><li><a href='#string_translate-function'>string_translate [function]</a></li><li><a href='#string_trim-function'>string_trim [function]</a></li><li><a href='#string_toupper-function'>string_toupper [function]</a></li><li><a href='#string_tolower-function'>string_tolower [function]</a></li><li><a href='#string_compare-function'>string_compare [function]</a></li><li><a href='#string_implode-function'>string_implode [function]</a></li><li><a href='#string_explode-function'>string_explode [function]</a></li><li><a href='#string_charcode-function'>string_charcode [function]</a></li><li><a href='#string_frombytes-function'>string_frombytes [function]</a></li><li><a href='#string_utf8_decode-function'>string_utf8_decode [function]</a></li><li><a href='#string_utf8_encode-function'>string_utf8_encode [function]</a></li><li><a href='#string_format-function'>string_format [function]</a></li></ul></div><div><div class='item'><a name='SGScript---description-info'></a><hr><h2>SGScript - description [info]</h2><p></p><p>
This is a programming language that is made to be fast, accessible and simple. It is similar to many but the exact combination makes it unique in comparison to others. Thus, it might be best to describe it in comparison to others, especially the ones that heavily influenced the development of SGScript.
</p><p>
</p><hr /><p>
<em class='notice-bgr'>language  !            what it DOESN&#39;T have in comparison to SGScript             !</em>
|     C      |  dynamic typing, built-in serialization                               |
|    Lua     |  built-in serialization, C-like syntax, proper indexing, arrays, ...  |
|    PHP     |  consistency, lightweight design                                      |
| JavaScript |  environmental awareness, determinism, built-in serialization, ...    |
|   Python   |  C-like syntax, lightweight design                                    |
</p><hr /><p>
</p><p>
With this in mind, technologies get upgraded occasionally, thus be sure to take this comparison with a grain of salt and recheck it and perhaps even report the factual errors along with the version number that marked the introduction of changes.
</p><p>
However, SGScript has all of the things mentioned, and some more, possibly making it one of the most balanced languages ever created.
</p><p>
The language supports:
</p><p>
</p><ul><li><code>if/else</code>, <code>while</code>, <code>for</code>, <code>do/while</code>, <code>foreach</code>
</li><li>8 variable types: null, bool, int, real, string, function, C function, object
</li><li>Multi-level break/continue
</li><li>Multiple return values
</li><li>First-class functions</li></ul><p>
</p><p>
The standard library includes:
</p><p>
</p><ul><li>array, dict, class, closure
</li><li>math, string, I/O, O/S and formatting functions
</li><li><code>eval</code>, file import, DLL import</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='SGScript-Virtual-Machine-info'></a><hr><h2>SGScript Virtual Machine [info]</h2><p></p><p>
...or the interface that it defines, is one of the driving forces of SGScript. It is heavily influenced by Lua, while also adding some features of PHP (Zend Engine) and Python.
</p><p>
The overview: register-based, single-stack, highly customizable / extensible bytecode interpreter.
</p><p>
The most important difference is in error handling and triggers: errors detected in C can easily be non-fatal. Just like with PHP, minor errors are emitted as warnings that also propagate invalid (null) values throughout the system to effectively disable the subsequent calls and notify whoever is interested of the exact trail of failures. Furthermore, this behavior can be modified by using protected calls (pcall function) in SGScript and custom error printing callbacks in C.
</p><p>
The virtual machine supports:
</p><p>
</p><ul><li>Operator overloading
</li><li>On-demand garbage collection
</li><li>Full introspection of machine state
</li><li>Type registration for simplified cross-library data reuse</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='Commonly-required-advanced-tasks-info'></a><hr><h2>Commonly required advanced tasks [info]</h2><p></p><p>
</p><h4>Method handling</h4><p>
</p><p>
</p><ul><li>version 1: plain method handling:</li></ul><p>
</p><p>
</p><pre>SGSFN( &quot;&lt;object&gt;.&lt;method&gt;&quot; );
if( !sgs_Method( C ) || !sgs_IsObject( C, 0, Object_interface_pointer ) )
    return sgs_ArgErrorExt( C, 0, 1, &quot;&lt;object&gt;&quot;, &quot;&quot; );
ObjectDataStruct* data = (ObjectDataStruct*) sgs_GetObjectData( C, 0 )-&gt;data;</pre><p>
</p><p>
</p><p>
</p><ul><li>version 2: Method + function handling (function that can be called as a method too)</li></ul><p>
</p><p>
</p><pre>int method_call = sgs_Method( C );
SGSFN( method_call ? &quot;&lt;object&gt;.&lt;method&gt;&quot; : &quot;&lt;object_function&gt;&quot; );
if( !sgs_IsObject( C, 0, Object_interface_pointer ) )
    return sgs_ArgErrorExt( C, 0, method_call, &quot;&lt;object&gt;&quot;, &quot;&quot; );
ObjectDataStruct* data = (ObjectDataStruct*) sgs_GetObjectData( C, 0 )-&gt;data;</pre><p>
</p><p>
</p><p>
</p><p>
</p><p></p></div><div class='item'><a name='Main-types-info'></a><hr><h2>Main types [info]</h2><p></p><p>
Return types:
</p><ul><li>SGSRESULT [int]: output code (success = 0, failure: &lt; 0 )
</li><li>SGSBOOL [int]: simplified output code (success = 1, failure = 0)
</li><li>SGSMIXED [int32_t] output code / value (success + value: &gt;= 0, failure: &lt; 0)</li></ul><p>
</p><p>
Virtual machine / language types:
</p><ul><li>sgs_Bool [int32_t]: boolean value
</li><li>sgs_Int [int64_t]: integer
</li><li>sgs_Real [double]: real (floating point) value
</li><li>sgs_SizeVal [int32_t]: size type
</li><li>sgs_CFunc [int ( sgs_Context* )]: C function type
</li><li>sgs_ObjCallback [int ( sgs_Context*, sgs_VarObj*, int )]: object interface function
</li><li>sgs_Variable [struct]: the combined variable type</li></ul><p>
</p><p>
System types:
</p><ul><li>sgs_Context [struct]: the virtual machine
</li><li>sgs_StackFrame [struct]: the function call info object</li></ul><p>
</p><p>
Interface types:
</p><ul><li>sgs_MemFunc [void* ( void* userdata, void* ptr, size_t size )]: memory interface function
</li><li>sgs_OutputFunc [void ( void* userdata, sgs_Context* C, const void* buf, sgs_SizeVal size )]: output function
</li><li>sgs_PrintFunc [void ( void* userdata, sgs_Context* C, int code, const char* text )]: error printing function
</li><li>sgs_HookFunc [void ( void*, sgs_Context*, int )]: debug hook function</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='Error-codes-info'></a><hr><h2>Error codes [info]</h2><p></p><p>
These are the default meanings for error codes that are honored throughout the API.
</p><p>
</p><ul><li>Generated by the C API
<ul><li>SGS_SUCCESS: operation was successful
</li><li>SGS_ENOTFND: item was not found
</li><li>SGS_ECOMP: compile error
</li><li>SGS_ENOTOBJ: argument was not an object
</li><li>SGS_ENOTSUP: operation is not supported
</li><li>SGS_EINVAL: invalid value was passed
</li><li>SGS_EINPROC: process was interrupted</li></ul></li></ul><p>
</p><p>
</p><ul><li>Generated by SGScript VM
<ul><li>SGS_INFO: information about potential issues and state of the system
</li><li>SGS_WARNING: non-fatal issues
</li><li>SGS_ERROR: fatal issues
</li><li>any other integer may be defined and returned by other interfaces</li></ul></li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='Variable-type-flags-info'></a><hr><h2>Variable type flags [info]</h2><p></p><p>
</p><ul><li>primary flags
<ul><li>SGS_VT_NULL: (primary null flag, actually - lack of a primary flag)
</li><li>SGS_VT_[BOOL|INT|REAL|STRING|FUNC|CFUNC|OBJECT]: primary flags</li></ul></li></ul><p>
</p><p>
</p><ul><li>property flags
<ul><li>SGS_VTF_NUM: numeric type flag
</li><li>SGS_VTF_CALL: always-callable type flag
</li><li>SGS_VTF_REF: reference-counted type flag
</li><li>SGS_VTF_ARRAY: array type flag
</li><li>SGS_VTF_ARRAY_ITER: array iterator type flag
</li><li>SGS_VTF_DICT: dict type flag</li></ul></li></ul><p>
</p><p>
</p><ul><li>complete flag combos
<ul><li>SGS_VTC_[NULL|BOOL|INT|REAL|STRING|FUNC|CFUNC|OBJECT]: complete variable flags
</li><li>SGS_VTC_[ARRAY|ARRAY_ITER|DICT]: complete specialized variable flags</li></ul></li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='Object-operation-types-info'></a><hr><h2>Object operation types [info]</h2><p></p><p>
</p><ul><li>SGS_OP_END: &lt;end of list&gt; marker op
</li><li>SGS_OP_DESTRUCT: object destruction op (argument: whether should free child variables - 1/0)
</li><li>SGS_OP_GETINDEX: object index/property retrieval (argument: whether is a property)
</li><li>SGS_OP_SETINDEX: object index/property store (argument: whether is a property)
</li><li>SGS_OP_CONVERT: object conversion (argument: subtype)
<ul><li>subtype = SGS_VT_[BOOL|INT|REAL|STRING]: convert to boolean/integer/real/string
</li><li>subtype = SGS_CONVOP_CLONE: create a clone of the object
</li><li>subtype = SGS_CONVOP_TOTYPE: return the type name as string
</li><li>subtype = SGS_TOITER: return a new iterator object for the current one
</li></ul><li>SGS_OP_SERIALIZE: generate serialized code
</li><li>SGS_OP_DUMP: print anything informational about the variable
</li><li>SGS_OP_GCMARK: mark the object as reachable by the GC
</li><li>SGS_OP_GETNEXT: [for iterators] return the data / advance to next item
<ul><li>subtype = SGS_GETNEXT_[KEY|VALUE]: return the key/value from the iterator
</li><li>subtype = 0: advance to next item
</li></ul><li>SGS_OP_CALL: call the object
</li><li>SGS_OP_EXPR: perform an expression between this and another object
<ul><li>subtype = SGS_EOP_[ADD|SUB|MUL|DIV|MOD]: return A [+|-|*|/|%] B
</li><li>subtype = SGS_EOP_COMPARE: if A &lt; B, return -1; if A &gt; B, return 1; otherwise return 0;
</li><li>subtype = SGS_EOP_NEGATE: return the current value, negated</li></ul></li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='Interaction-with-the-native-environment-info'></a><hr><h2>Interaction with the native environment [info]</h2><p></p><p>
</p><h4>Memory allocation</h4><p>
</p><ul><li>sgs_MemFunc must be specified in creation of the scripting engine context
</li><li>sgs_MemFunc (re)allocates and frees memory
</li><li>unlike realloc, if size = 0, this function must return NULL
</li><li>sgs_DefaultMemFunc is the sample implementation
</li><li>the expected behavior is same as for @sgs_Memory()</li></ul><p>
</p><p>
</p><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_CreateEngine-function-alias'></a><hr><h2>sgs_CreateEngine [function alias]</h2><p></p><p>
</p><h3>sgs_Context* sgs_CreateEngine()</h3><p>
</p><h4>returns a new scripting engine context</h4><p>
</p><p>
</p><ul><li>alias to <code>sgs_CreateEngineExt( sgs_DefaultMemFunc, NULL )</code></li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_CreateEngineExt-function'></a><hr><h2>sgs_CreateEngineExt [function]</h2><p></p><p>
</p><h3>sgs_Context* sgs_CreateEngineExt( sgs_MemFunc memfunc, void* mfuserdata )</h3><p>
</p><h4>returns a new scripting engine context, attached to the specified allocator</h4><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_DestroyEngine-function'></a><hr><h2>sgs_DestroyEngine [function]</h2><p></p><p>
</p><h3>sgs_DestroyEngine( sgs_Context* C )</h3><p>
</p><h4>destroys the passed context and frees all memory associated to it</h4><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_ExecString-function-alias'></a><hr><h2>sgs_ExecString [function alias]</h2><p></p><p>
</p><h3>SGSRESULT sgs_ExecString( sgs_Context* C, const char* str )</h3><p>
</p><h4>compiles and executes a string of text</h4><p>
</p><p>
</p><ul><li>leaves the stack the same as it was before the call
</li><li>alias to <code>sgs_ExecBuffer( C, str, SGS_STRINGLENGTHFUNC( str ) )</code>
</li><li>theoretically bytecode is supported but it will most probably be trimmed by the string length function, unless a different string termination mark is used, and a different string length function to detect it is set</li></ul><p>
</p><p>
</p><h4>error codes</h4><p>
</p><ul><li>SGS_ECOMP: compiler error
</li><li>SGS_EINVAL: passed data was not recognized</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_ExecBuffer-function-alias'></a><hr><h2>sgs_ExecBuffer [function alias]</h2><p></p><p>
</p><h3>SGSRESULT sgs_ExecBuffer( sgs_Context* C, const char* buf, sgs_SizeVal size )</h3><p>
</p><h4>compiles and executes a buffer of text or bytecode</h4><p>
</p><p>
</p><ul><li>leaves the stack the same as it was before the call
</li><li>alias to <code>sgs_EvalBuffer( C, buf, size, NULL )</code></li></ul><p>
</p><p>
</p><h4>error codes</h4><p>
</p><ul><li>SGS_ECOMP: compiler error
</li><li>SGS_EINVAL: passed data was not recognized</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_EvalString-function-alias'></a><hr><h2>sgs_EvalString [function alias]</h2><p></p><p>
</p><h3>SGSRESULT sgs_EvalString( sgs_Context* C, const char* str, int* rvc )</h3><p>
</p><h4>compiles and executes a string of text, optionally leaving the return values on stack and returning the number of values via <code>rvc</code></h4><p>
</p><p>
</p><ul><li>if <code>rvc</code> is not set (NULL), return values are removed - the stack is the same as it was before the call
</li><li>alias to sgs_EvalBuffer( C, str, SGS_STRINGLENGTHFUNC( str ), rvc )</li></ul><p>
</p><p>
</p><h4>error codes</h4><p>
</p><ul><li>SGS_ECOMP: compiler error
</li><li>SGS_EINVAL: passed data was not recognized</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_EvalBuffer-function'></a><hr><h2>sgs_EvalBuffer [function]</h2><p></p><p>
</p><h3>SGSRESULT sgs_EvalBuffer( sgs_Context* C, const char* buf, sgs_SizeVal size, int* rvc )</h3><p>
</p><h4>compiles and executes a buffer of text or bytecode, optionally leaving the return values on stack and returning the number of values via <code>rvc</code></h4><p>
</p><p>
</p><ul><li>if <code>rvc</code> is not set (NULL), return values are removed - the stack is the same as it was before the call</li></ul><p>
</p><p>
</p><h4>error codes</h4><p>
</p><ul><li>SGS_ECOMP: compiler error
</li><li>SGS_EINVAL: passed data was not recognized</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_ExecFile-function-alias'></a><hr><h2>sgs_ExecFile [function alias]</h2><p></p><p>
</p><h3>SGSRESULT sgs_ExecFile( sgs_Context* C, const char* filename )</h3><p>
</p><h4>compiles and executes a file containing script text or bytecode</h4><p>
</p><p>
</p><ul><li>leaves the stack the same as it was before the call
</li><li>alias to <code>sgs_EvalFile( C, filename, NULL )</code></li></ul><p>
</p><p>
</p><h4>error codes</h4><p>
</p><ul><li>SGS_ECOMP: compiler error
</li><li>SGS_EINVAL: passed data was not recognized</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_EvalFile-function'></a><hr><h2>sgs_EvalFile [function]</h2><p></p><p>
</p><h3>SGSRESULT sgs_ExecFile( sgs_Context* C, const char* filename, int* rvc )</h3><p>
</p><h4>compiles and executes a file containing script text or bytecode, optionally leaving the return values on stack and returning the number of values via <code>rvc</code></h4><p>
</p><p>
</p><ul><li>if <code>rvc</code> is not set (NULL), return values are removed - the stack is the same as it was before the call</li></ul><p>
</p><p>
</p><h4>error codes</h4><p>
</p><ul><li>SGS_ECOMP: compiler error
</li><li>SGS_EINVAL: passed data was not recognized</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_LoadLib_[Fmt|IO|Math|OS|String]-functions'></a><hr><h2>sgs_LoadLib_[Fmt|IO|Math|OS|String] [functions]</h2><p></p><p>
</p><h3>SGSRESULT sgs_LoadLib_Fmt( sgs_Context* C )</h3><p>
</p><h3>SGSRESULT sgs_LoadLib_IO( sgs_Context* C )</h3><p>
</p><h3>SGSRESULT sgs_LoadLib_Math( sgs_Context* C )</h3><p>
</p><h3>SGSRESULT sgs_LoadLib_OS( sgs_Context* C )</h3><p>
</p><h3>SGSRESULT sgs_LoadLib_String( sgs_Context* C )</h3><p>
</p><h4>loads the library into the specified context</h4><p>
</p><p>
</p><ul><li>it is generally unnecessary to check for these error codes</li></ul><p>
</p><p>
</p><h4>error codes</h4><p>
</p><ul><li>SGS_E**<b>: first error encountered (operation stopped somewhere in the middle)</b></li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_Reg[Func|Int|Real]Const-struct'></a><hr><h2>sgs_Reg[Func|Int|Real]Const [struct]</h2><p></p><p>
</p><h3>sgs_RegFuncConst { char* name; sgs_CFunc value; }</h3><p>
</p><h3>sgs_RegIntConst { char* name; sgs_Int value; }</h3><p>
</p><h3>sgs_RegRealConst { char* name; sgs_Real value; }</h3><p>
</p><h4>a pair of null-terminated string and a scripting engine value type</h4><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_Reg[Func|Int|Real]Consts-function'></a><hr><h2>sgs_Reg[Func|Int|Real]Consts [function]</h2><p></p><p>
</p><h3>SGSRESULT sgs_RegFuncConsts( sgs_Context* C, const sgs_RegFuncConst* list, int size )</h3><p>
</p><h3>SGSRESULT sgs_RegIntConsts( sgs_Context* C, const sgs_RegIntConst* list, int size )</h3><p>
</p><h3>SGSRESULT sgs_RegRealConsts( sgs_Context* C, const sgs_RegRealConst* list, int size )</h3><p>
</p><h4>loads the specified list of constants in the context</h4><p>
</p><p>
</p><ul><li>the end of list can be specified in two ways
<ul><li>set the size to <code>sizeof(list)/sizeof(list[0])</code>
</li><li>set the size to -1 and end the list with <code>SGS_RC_END()</code>
</li><li>using both at the same time should be reserved to special cases only</li></ul></li></ul><p>
</p><p>
</p><h4>error codes</h4><p>
</p><ul><li>SGS_E**<b>: first error encountered (operation stopped somewhere in the middle)</b></li></ul><p>
</p><p>
</p><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_Push[Null|Bool|Int|Real|StringBuf|String|CFunction|Object|ObjectIPA|Variable]-functions'></a><hr><h2>sgs_Push[Null|Bool|Int|Real|StringBuf|String|CFunction|Object|ObjectIPA|Variable] [functions]</h2><p></p><p>
</p><h3>void sgs_PushNull( sgs_Context* C )</h3><p>
</p><h3>void sgs_PushBool( sgs_Context* C, sgs_Bool value )</h3><p>
</p><h3>void sgs_PushInt( sgs_Context* C, sgs_Int value )</h3><p>
</p><h3>void sgs_PushReal( sgs_Context* C, sgs_Real value )</h3><p>
</p><h3>void sgs_PushStringBuf( sgs_Context* C, const char* str, sgs_SizeVal size )</h3><p>
</p><h3>void sgs_PushString( sgs_Context* C, const char* str )</h3><p>
</p><h3>void sgs_PushCFunction( sgs_Context* C, sgs_CFunc func )</h3><p>
</p><h3>void sgs_PushObject( sgs_Context* C, void* data, void** iface )</h3><p>
</p><h3>void* sgs_PushObjectIPA( sgs_Context* C, sgs_SizeVal added, void** iface )</h3><p>
</p><h3>void sgs_PushVariable( sgs_Context* C, sgs_Variable* var )</h3><p>
</p><h4>pushes the data on the stack, as a new entry, appended to the end</h4><p>
</p><p>
</p><ul><li>sgs_Bool is transformed to 0/1 before pushing, everything else is unchanged
</li><li>sgs_PushStringBuf( C, NULL, size ) would allocate an uninitialized buffer
<ul><li>it is accessible immediately by @sgs_GetString[Ptr|Size]( C, -1 )
</li></ul><li>sgs_PushObjectIPA stands for &quot;push object, allocate memory in-place&quot;
<ul><li>it means that the <code>added</code> memory space will be appended to the end of object allocation
</li><li>this allows to allocate all object data for most objects with just one allocation, instead of two
</li><li>the allocated memory will be returned and also available via sgs_GetObjectData( C, -1 )-&gt;data
</li></ul><li>sgs_PushVariable will increment the reference count of strings, SGS functions and objects
</li><li>these functions do not throw an error when the stack is full since there is no way to handle that</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_Pop-function'></a><hr><h2>sgs_Pop [function]</h2><p></p><p>
</p><h3>SGSRESULT sgs_Pop( sgs_Context* C, int count )</h3><p>
</p><h4>pops <code>count</code> variables off the current frame of the stack</h4><p>
</p><p>
</p><h4>error codes</h4><p>
</p><ul><li>SGS_EINVAL: <code>count</code> was bigger than the number of items in the current stack frame or <code>count</code> is less than 0</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_PopSkip-function'></a><hr><h2>sgs_PopSkip [function]</h2><p></p><p>
</p><h3>SGSRESULT sgs_PopSkip( sgs_Context* C, int count, int skip )</h3><p>
</p><h4>pops <code>count</code> variables off the current frame of the stack, skipping the last <code>skip</code> elements</h4><p>
</p><p>
</p><h4>error codes</h4><p>
</p><ul><li>SGS_EINVAL: <code>count+skip</code> was bigger than the number of items in the current stack frame or <code>count</code> is less than 0 or <code>skip</code> is less than 0</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_InsertVariable-function'></a><hr><h2>sgs_InsertVariable [function]</h2><p></p><p>
</p><h3>SGSRESULT sgs_InsertVariable( sgs_Context* C, int pos, sgs_Variable* var )</h3><p>
</p><h4>inserts a variable <code>var</code> at a given index <code>pos</code> of the current stack frame, increasing its reference count</h4><p>
</p><p>
</p><h4>error codes</h4><p>
</p><ul><li>SGS_EBOUNDS: index out of bounds</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_PushArray-function'></a><hr><h2>sgs_PushArray [function]</h2><p></p><p>
</p><h3>SGSRESULT sgs_PushArray( sgs_Context* C, sgs_SizeVal numitems )</h3><p>
</p><h4>creates an array from <code>numitems</code> last items on the stack, pops those items and pushes the array</h4><p>
</p><p>
</p><h4>error codes</h4><p>
</p><ul><li>SGS_EINVAL: more items are selected than exist in the current stack frame</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_PushDict-function'></a><hr><h2>sgs_PushDict [function]</h2><p></p><p>
</p><h3>SGSRESULT sgs_PushDict( sgs_Context* C, sgs_SizeVal numitems )</h3><p>
</p><h4>creates a dict from <code>numitems</code> last items on the stack, pops those items and pushes the dict</h4><p>
</p><p>
</p><ul><li><code>numitems</code> can be even or 0, since all odd arguments are keys and all even arguments are values</li></ul><p>
</p><p>
</p><h4>error codes</h4><p>
</p><ul><li>SGS_EINVAL: more items are selected than exist in the current stack frame or <code>numitems</code> wasn&#39;t even or 0</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_PushItem-function'></a><hr><h2>sgs_PushItem [function]</h2><p></p><p>
</p><h3>SGSRESULT sgs_PushItem( sgs_Context* C, int item )</h3><p>
</p><h4>copy an item from the current stack frame and append it to the end of the stack</h4><p>
</p><p>
</p><h4>error codes</h4><p>
</p><ul><li>SGS_EBOUNDS: index out of bounds</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_StoreItem-function'></a><hr><h2>sgs_StoreItem [function]</h2><p></p><p>
</p><h3>SGSRESULT sgs_StoreItem( sgs_Context* C, int item )</h3><p>
</p><h4>copy last item in current stack frame to index <code>item</code> and pop it</h4><p>
</p><p>
</p><ul><li><code>item</code> refers to a position after the pop operation, therefore -1 means one element before the last etc.</li></ul><p>
</p><p>
</p><h4>error codes</h4><p>
</p><ul><li>SGS_EBOUNDS: index out of bounds</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_PushProperty-function'></a><hr><h2>sgs_PushProperty [function]</h2><p></p><p>
</p><h3>SGSRESULT sgs_PushProperty( sgs_Context* C, const char* name )</h3><p>
</p><h4>load and push the property of the topmost item in the current stack frame</h4><p>
</p><p>
</p><h4>error codes</h4><p>
</p><ul><li>SGS_EINPROC: current stack frame is empty
</li><li>SGS_ENOTFND: property was not found
</li><li>other codes may appear if returned by custom objects</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_StoreProperty-function'></a><hr><h2>sgs_StoreProperty [function]</h2><p></p><p>
</p><h3>SGSRESULT sgs_StoreProperty( sgs_Context* C, int obj, const char* name )</h3><p>
</p><h4>copy and pop the topmost item of the current stack frame to the property <code>name</code> of variable <code>obj</code></h4><p>
</p><p>
</p><h4>error codes</h4><p>
</p><ul><li>SGS_EBOUNDS: <code>obj</code> was not pointing inside the current stack frame
</li><li>SGS_ENOTFND: property was not found
</li><li>other codes may appear if returned by custom objects</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_PushNumIndex-function'></a><hr><h2>sgs_PushNumIndex [function]</h2><p></p><p>
</p><h3>SGSRESULT sgs_PushNumIndex( sgs_Context* C, int obj, sgs_Int idx )</h3><p>
</p><h4>load and push the integer index <code>idx</code> of the variable <code>obj</code></h4><p>
</p><p>
</p><h4>error codes:</h4><p>
</p><ul><li>SGS_EBOUNDS: <code>obj</code> was not pointing inside the current stack frame / array index out of bounds
</li><li>SGS_ENOTFND: index was not found
</li><li>other codes may appear if returned by custom objects</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_StoreNumIndex-function'></a><hr><h2>sgs_StoreNumIndex [function]</h2><p></p><p>
</p><h3>SGSRESULT sgs_StoreNumIndex( sgs_Context* C, int obj, sgs_Int idx )</h3><p>
</p><h4>copy and pop the topmost item of the current stack to the integer index <code>idx</code> of variable <code>obj</code></h4><p>
</p><p>
</p><h4>error codes</h4><p>
</p><ul><li>SGS_EBOUNDS: <code>obj</code> was not pointing inside the current stack frame / array index out of bounds
</li><li>SGS_ENOTFND: index was not found
</li><li>other codes may appear if returned by custom objects</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_PushIndexExt-function'></a><hr><h2>sgs_PushIndexExt [function]</h2><p></p><p>
</p><h3>SGSRESULT sgs_PushIndexExt( sgs_Context* C, int obj, int idx, int prop )</h3><p>
</p><h4>load and push the indexed item/property (if <code>prop</code> is nonzero) <code>idx</code> of the item <code>obj</code> in the current stack frame</h4><p>
</p><p>
</p><h4>error codes</h4><p>
</p><ul><li>SGS_EBOUNDS: <code>obj</code> or <code>idx</code> were not pointing inside the current stack frame / array index out of bounds
</li><li>SGS_ENOTFND: property/index was not found
</li><li>SGS_EINVAL: index is not of string or integer type
</li><li>other codes may appear if returned by custom objects</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_PushIndex-function-alias'></a><hr><h2>sgs_PushIndex [function alias]</h2><p></p><p>
</p><h3>SGSRESULT sgs_PushIndex( sgs_Context* C, int obj, int idx )</h3><p>
</p><h4>load and push the indexed item <code>idx</code> of the item <code>obj</code> in the current stack frame</h4><p>
</p><p>
</p><ul><li>alias of <code>sgs_PushIndexExt( C, obj, idx, 0 )</code></li></ul><p>
</p><p>
</p><h4>error codes</h4><p>
</p><ul><li>SGS_EBOUNDS: <code>obj</code> or <code>idx</code> were not pointing inside the current stack frame / array index out of bounds
</li><li>SGS_ENOTFND: index was not found
</li><li>SGS_EINVAL: index is not of string or integer type
</li><li>other codes may appear if returned by custom objects</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_PushIndexP-function'></a><hr><h2>sgs_PushIndexP [function]</h2><p></p><p>
</p><h3>SGSRESULT sgs_PushIndexP( sgs_Context* C, sgs_Variable* obj, sgs_Variable* idx )</h3><p>
</p><h4>load and push the indexed item <code>idx</code> of the item <code>obj</code></h4><p>
</p><p>
</p><h4>error codes</h4><p>
</p><ul><li>SGS_EBOUNDS: array index out of bounds
</li><li>SGS_ENOTFND: index was not found
</li><li>SGS_EINVAL: index is not of string or integer type
</li><li>other codes may appear if returned by custom objects</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_StoreIndexExt-function'></a><hr><h2>sgs_StoreIndexExt [function]</h2><p></p><p>
</p><h3>SGSRESULT sgs_StoreIndexExt( sgs_Context* C, int obj, int idx, int prop )</h3><p>
</p><h4>copy and pop the topmost stack item to the indexed item/property (if <code>prop</code> is nonzero) <code>idx</code> of the item <code>obj</code> in the current stack frame</h4><p>
</p><p>
</p><h4>error codes</h4><p>
</p><ul><li>SGS_EBOUNDS: <code>obj</code> or <code>idx</code> were not pointing inside the current stack frame / array index out of bounds
</li><li>SGS_ENOTFND: property/index was not found
</li><li>SGS_EINVAL: index is not of string or integer type
</li><li>other codes may appear if returned by custom objects</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_StoreIndex-function-alias'></a><hr><h2>sgs_StoreIndex [function alias]</h2><p></p><p>
</p><h3>SGSRESULT sgs_StoreIndex( sgs_Context* C, int obj, int idx )</h3><p>
</p><h4>copy and pop the topmost stack item to the indexed item <code>idx</code> of the item <code>obj</code> in the current stack frame</h4><p>
</p><p>
</p><h4>error codes</h4><p>
</p><ul><li>SGS_EBOUNDS: <code>obj</code> or <code>idx</code> were not pointing inside the current stack frame / array index out of bounds
</li><li>SGS_ENOTFND: index was not found
</li><li>SGS_EINVAL: index is not of string or integer type
</li><li>other codes may appear if returned by custom objects</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_StoreIndexP-function'></a><hr><h2>sgs_StoreIndexP [function]</h2><p></p><p>
</p><h3>SGSRESULT sgs_StoreIndexP( sgs_Context* C, sgs_Variable* obj, sgs_Variable* idx )</h3><p>
</p><h4>copy and pop the topmost stack item to the indexed item <code>idx</code> of the item <code>obj</code></h4><p>
</p><p>
</p><h4>error codes</h4><p>
</p><ul><li>SGS_EBOUNDS: array index out of bounds
</li><li>SGS_EINPROC: current stack frame is empty
</li><li>SGS_ENOTFND: index was not found
</li><li>SGS_EINVAL: index is not of string or integer type
</li><li>other codes may appear if returned by custom objects</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_PushGlobal-function'></a><hr><h2>sgs_PushGlobal [function]</h2><p></p><p>
</p><h3>SGSRESULT sgs_PushGlobal( sgs_Context* C, const char* name )</h3><p>
</p><h4>push the global variable <code>name</code> on the stack</h4><p>
</p><p>
</p><h4>error codes</h4><p>
</p><ul><li>SGS_ENOTFND: variable was not found</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_StoreGlobal-function'></a><hr><h2>sgs_StoreGlobal [function]</h2><p></p><p>
</p><h3>SGSRESULT sgs_StoreGlobal( sgs_Context* C, const char* name )</h3><p>
</p><h4>copy and pop the topmost stack item to the global variable <code>name</code></h4><p>
</p><p>
</p><ul><li>_G is the environment table (a superglobal, list of global variable names and values)</li></ul><p>
</p><p>
</p><h4>error codes</h4><p>
</p><ul><li>SGS_EINPROC: current stack frame was empty
</li><li>SGS_ENOTSUP: _G only accepts dict values</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_PushPath-function'></a><hr><h2>sgs_PushPath [function]</h2><p></p><p>
</p><h3>sgs_PushPath( sgs_Context* C, int item, const char* path, ... )</h3><p>
</p><h4>push the variable specified by starting point <code>item</code> and traversal path <code>path</code></h4><p>
</p><p>
<em class='notice-bgr'>The safety of this function is similar to that of the printf family of functions. Be explicit in what types you pass to the variable argument list to avoid errors.</em>
</p><p>
</p><ul><li>the syntax of <code>path</code>:
<ul><li>a list of letters, specifying a sub-variable to request (o,p,s,i,k,n)</li></ul></li></ul><p>
</p><p>
</p><h5>table of accepted letters</h5><p>
</p><hr /><p>
<em class='notice-bgr'>letter ! property? ! variable arguments ! virtual machine access mode / description !</em>
|    o   |    yes    |  SizeVal           |   integer property                        |
|    p   |    yes    |  C string          |   string property                         |
|    s   |    yes    |  SizeVal, buffer   |   special string property                 |
|    i   |    no     |  SizeVal           |   integer index                           |
|    k   |    no     |  C string          |   string index                            |
|    n   |    no     |  SizeVal, buffer   |   special string index                    |
</p><hr /><p>
</p><ul><li>legend:
<ul><li>SizeVal: sgs_SizeVal / int32_t
</li><li>C string: null-terminated char* string
</li><li>buffer: char* byte array, size is specified in the previous argument
</li><li>property?: if yes, property access is used (object.property), otherwise index access is used (object[index])</li></ul></li></ul><p>
</p><p>
</p><h4>error codes</h4><p>
</p><ul><li>SGS_EINVAL: invalid symbol found in path / corresponding variable arguments had an invalid value
</li><li>other errors, as returned by @sgs_PushIndexExt()</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_StorePath-function'></a><hr><h2>sgs_StorePath [function]</h2><p></p><p>
</p><h3>sgs_StorePath( sgs_Context* C, int item, const char* path, ... )</h3><p>
</p><h4>copy and pop the topmost item on stack to variable specified by starting point <code>item</code> and traversal path <code>path</code></h4><p>
</p><p>
<em class='notice-bgr'>The safety of this function is similar to that of the printf family of functions. Be explicit in what types you pass to the variable argument list to avoid errors.</em>
</p><p>
</p><ul><li>the syntax of <code>path</code> is the same as with @sgs_PushPath()
</li><li>the last item on the path (or in the case of an empty path, the starting point) is accessed with a store operation, the rest - with a push operation</li></ul><p>
</p><p>
</p><h4>error codes</h4><p>
</p><ul><li>SGS_EINVAL: invalid symbol found in path / corresponding variable arguments had an invalid value
</li><li>SGS_EINPROC: current stack frame is empty
</li><li>other errors, as returned by @sgs_PushIndexExt() or @sgs_StoreIndexExt()</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_ArgErrorExt-function'></a><hr><h2>sgs_ArgErrorExt [function]</h2><p></p><p>
</p><h3>int sgs_ArgErrorExt( SGS_CTX, int argid, int method, const char* expect, const char* expfx )</h3><p>
</p><h4>prints the argument type mismatch error</h4><p>
</p><p>
</p><ul><li>always returns 0 so it can be used to return and print an error in the same statement</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_ArgError-function'></a><hr><h2>sgs_ArgError [function]</h2><p></p><p>
</p><h3>int sgs_ArgError( sgs_Context* C, int argid, int expect, int is_strict )</h3><p>
</p><h4>prints the argument type mismatch error</h4><p>
</p><p>
</p><ul><li>always returns 0 so it can be used to return and print an error in the same statement</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_[FuncArgError|MethodArgError]-function-aliases'></a><hr><h2>sgs_[FuncArgError|MethodArgError] [function aliases]</h2><p></p><p>
</p><h3>int sgs_FuncArgError( sgs_Context* C, int argid, int expect, int is_strict )</h3><p>
</p><h3>int sgs_MethodArgError( sgs_Context* C, int argid, int expect, int is_strict )</h3><p>
</p><h4>prints the argument type mismatch error</h4><p>
</p><p>
</p><ul><li>always returns 0 so it can be used to return and print an error in the same statement
</li><li>alias to <code>sgs_ArgError( C, argid, Func/Method =&gt; 0/1, expect, is_strict )</code></li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_LoadArgsExt-function'></a><hr><h2>sgs_LoadArgsExt [function]</h2><p></p><p>
</p><h3>SGSMIXED sgs_LoadArgsExt( sgs_Context* C, int from, const char* cmd, ... )</h3><p>
</p><h4>parse the stack items and retrieve their data according to <code>cmd</code>, starting from item <code>from</code></h4><p>
</p><p>
</p><ul><li>for anything function requires, pass the value; for anything it returns - the pointer to the value
</li><li><code>cmd</code> is a string consisting of one-character commands
</li><li>the commands are grouped into two kinds: control commands and parsing commands
</li><li>function returns whether all required arguments have been parsed successfully
<ul><li>thus, if function returns &lt; 1, state of outputs is somewhat unknown unless filled with defaults
</li><li>it is guaranteed that all arguments will be parsed from first (specified) forward, not in any other way</li></ul></li></ul><p>
</p><p>
<em class='notice-bgr'>unlike sgs_LoadArgs, it returns <code>SGSMIXED</code> and must be checked differently (&quot;ret.val. &gt; 0&quot;, if same output needed)</em>
</p><p>
</p><h5>control commands</h5><p>
</p><ul><li><code>?</code> -- only check, do not write the result and do not require a pointer to write the data to
</li><li><code>!</code> -- enable strict parsing for the next item (requires exactly the type specified
</li><li><code>-</code>,<code>+</code> -- enable (-) or disable (+) treating integers as signed (default = true)
</li><li><code>|</code> -- mark the point where required arguments end and optional arguments begin
</li><li><code>#</code> -- do range checking on integer arguments (min/max of the required types)
</li><li><code>^</code> -- clamp the argument to the range of the required type
</li><li><code>~</code> -- ignore ranges and chop out-of-range integers (default)
</li><li><code>&lt;</code> -- move argument pointer 1 item back (cannot move it before 0)
</li><li><code>&gt;</code> -- move argument pointer 1 item forward
</li><li><code>@</code> -- specify that this is a method (argument 0 = &#39;this&#39;; shifts argument indices on error printing by -1)
</li><li><code>.</code> -- specify the end of argument list (how many arguments are expected)</li></ul><p>
</p><p>
</p><h5>parsing commands</h5><p>
</p><ul><li><code>n</code> -- check for <code>null</code> (returns SGSBOOL = 1, always strict)
</li><li><code>b</code> -- check for <code>bool</code> (returns SGSBOOL)
</li><li><code>c</code> -- check for <code>int</code> (returns int8_t or uint8_t, depending on sign settings, may check ranges)
</li><li><code>w</code> -- check for <code>int</code> (returns int16_t or uint16_t, depending on sign settings, may check ranges)
</li><li><code>l</code> -- check for <code>int</code> (returns int32_t or uint32_t, depending on sign settings, may check ranges)
</li><li><code>q</code> -- check for <code>int</code> (returns int64_t or uint64_t, depending on sign settings, may check ranges)
</li><li><code>i</code> -- check for <code>int</code> (returns sgs_Int, may check ranges)
</li><li><code>f</code> -- check for <code>real</code> (returns float)
</li><li><code>d</code> -- check for <code>real</code> (returns double)
</li><li><code>r</code> -- check for <code>real</code> (returns sgs_Real)
</li><li><code>s</code> -- check for <code>string</code> (returns char*)
</li><li><code>m</code> -- check for <code>string</code> (returns char* string and sgs_SizeVal size)
</li><li><code>p</code> -- check for <code>func/cfunc/object with SGS_OP_CALL</code> (callables) (returns SGSBOOL = 1)
</li><li><code>a</code> -- check for <code>array</code> (returns sgs_SizeVal size, use -1 as starting value to check optional arguments)
</li><li><code>t</code> -- check for <code>dict</code> (returns sgs_SizeVal size, use -1 as starting value to check optional arguments)
</li><li><code>o</code> -- check for <code>object</code> (requires void** interface, returns sgs_VarObj* data)
</li><li><code>v</code> -- check for any (non-null if strict, returns sgs_Variable data)
</li><li><code>x</code> -- call a custom checking function (requires sgs_ArgCheckFunc, everything else depends on function)</li></ul><p>
</p><p>
</p><h4>error codes</h4><p>
</p><ul><li>SGS_EINVAL: error in <code>cmd</code> (wrong character/argument pointer moved before 0)</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_LoadArgs-function-alias'></a><hr><h2>sgs_LoadArgs [function alias]</h2><p></p><p>
</p><h3>SGSBOOL sgs_LoadArgs( sgs_Context* C, const char* cmd, ... )</h3><p>
</p><h4>parse the stack items and retrieve their data according to <code>cmd</code>, starting from item 0</h4><p>
</p><p>
<em class='notice-bgr'>unlike sgs_LoadArgsExt, it returns <code>bool</code> - whether all required arguments have been successfully parsed</em>
</p><p>
</p><ul><li>for more info on syntax and usage, refer to @sgs_LoadArgsExt
</li><li>alias to <code>sgs_LoadArgsExt( C, 0, cmd, ... )&gt;0</code></li></ul><p>
</p><p>
</p><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_FCall-function'></a><hr><h2>sgs_FCall [function]</h2><p></p><p>
</p><h3>SGSRESULT sgs_FCall( sgs_Context* C, int args, int expect, int gotthis )</h3><p>
</p><h4>call the topmost variable on stack with the arguments before it, returning the expected number of variables on stack</h4><p>
</p><p>
</p><ul><li><code>args</code>: the primary variables to be passed to the function, in the same order they are in the stack
</li><li><code>expect</code>: the number of variables to be left after a successful call
</li><li><code>gotthis</code>: whether the function is a method and an additional argument needs to be passed as the &#39;this&#39; value before others</li></ul><p>
</p><p>
After a successful call, all arguments and the function will be popped off the stack and the expected number of variables will appear in their place. If the underlying callable does not return enough arguments, &#39;null&#39; variables will be pushed instead. If the number of returned values is bigger than expected, only the first expected return values will stay on the stack.
</p><p>
</p><ul><li>expected stack structure:
<ul><li>(if gotthis != 0) [this]
</li><li>[argument] x <code>args</code>
</li><li>[callable]</li></ul></li></ul><p>
</p><p>
</p><ul><li>a callable is one of the following:
<ul><li>SGS function
</li><li>C function
</li><li>object with SGS_OP_CALL interface function defined</li></ul></li></ul><p>
</p><p>
<em class='notice-bgr'>Stack is returned to the expected state only if the return value is equal to SGS_SUCCESS or SGS_EINPROC. Otherwise, it&#39;s left exactly as it was before the call.</em>
</p><p>
</p><h4>error codes</h4><p>
</p><ul><li>SGS_EINPROC: topmost item on stack was not callable
</li><li>SGS_EINVAL: not enough values in current stack frame (must have at least <code>args + (gotthis?1:0) + 1</code>)</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_[Call|ThisCall]-function-aliases'></a><hr><h2>sgs_[Call|ThisCall] [function aliases]</h2><p></p><p>
</p><h3>SGSRESULT sgs_Call( sgs_Context* C, int args, int expect )</h3><p>
</p><h3>SGSRESULT sgs_ThisCall( sgs_Context* C, int args, int expect )</h3><p>
</p><h4>call the topmost variable on stack with the arguments before it, returning the expected number of variables on stack</h4><p>
</p><p>
</p><ul><li>aliases to @sgs_FCall(), for the first <code>gotthis = 0</code>, for the second <code>gotthis = 1</code>.</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_GlobalCall-function'></a><hr><h2>sgs_GlobalCall [function]</h2><p></p><p>
</p><h3>SGSRESULT sgs_GlobalCall( sgs_Context* C, const char* name, int args, int expect )</h3><p>
</p><h4>call the global variable <code>name</code> as a function</h4><p>
</p><p>
</p><ul><li>combination of @sgs_PushGlobal() and @sgs_Call()</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_TypeOf-function'></a><hr><h2>sgs_TypeOf [function]</h2><p></p><p>
</p><h3>SGSRESULT sgs_TypeOf( sgs_Context* C )</h3><p>
</p><h4>return the type name string of topmost variable in current stack frame</h4><p>
</p><p>
</p><ul><li>if the object does not support the specific part of the conversion interface function, a string of format &quot;object (%p)&quot; is returned to ensure expected type name comparison capabilities</li></ul><p>
</p><p>
</p><h4>error codes</h4><p>
</p><ul><li>SGS_EINPROC: current stack frame was empty</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_DumpVar-function'></a><hr><h2>sgs_DumpVar [function]</h2><p></p><p>
</p><h3>SGSRESULT sgs_DumpVar( sgs_Context* C, int maxdepth )</h3><p>
</p><h4>convert the topmost variable of current stack frame to a highly informative string that should display the contents of the variable, up to <code>maxdepth</code> depth</h4><p>
</p><p>
</p><ul><li>if object does not have the SGS_OP_DUMP interface function implemented, only its pointer in memory and reference count are displayed</li></ul><p>
</p><p>
</p><h4>error codes</h4><p>
</p><ul><li>SGS_EINPROC: current stack frame was empty
</li><li>SGS_EINVAL: invalid base variable type found in variable (not really expected to happen unless custom variable creation is done)</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_GCExecute-function'></a><hr><h2>sgs_GCExecute [function]</h2><p></p><p>
</p><h3>SGSRESULT sgs_GCExecute( sgs_Context* C )</h3><p>
</p><h4>call the garbage collector on the VM</h4><p>
</p><p>
</p><ul><li>this procedure may take some time if the object graph is big
</li><li>during the procedure, the SGS_OP_GCMARK interface functions of objects are invoked for the objects visible from entry points (like stack and global table)
</li><li>aborting of the procedure (via error codes) would lead the system into an unrecoverable state (TODO: is that really necessary?)</li></ul><p>
</p><p>
</p><h4>error codes</h4><p>
</p><ul><li>any code can be returned by SGS_OP_GCMARK and SGS_OP_DESTRUCT functions, doing so would abort the process if the code is not either SGS_SUCCESS or SGS_ENOTFND</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_PadString-function'></a><hr><h2>sgs_PadString [function]</h2><p></p><p>
</p><h3>SGSRESULT sgs_PadString( sgs_Context* C )</h3><p>
</p><h4>append two spaces after every newline in the topmost variable of current stack frame</h4><p>
</p><p>
</p><h4>error codes</h4><p>
</p><ul><li>SGS_EINPROC: current stack frame is empty
</li><li>SGS_EINVAL: topmost variable is not a string</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_StringConcat-function'></a><hr><h2>sgs_StringConcat [function]</h2><p></p><p>
</p><h3>SGSRESULT sgs_StringConcat( sgs_Context* C )</h3><p>
</p><h4>concatenate the two topmost string variables in the current stack frame</h4><p>
</p><p>
</p><h4>error codes</h4><p>
</p><ul><li>SGS_EINPROC: not enough variables were found in the current stack frame</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_StringMultiConcat-function'></a><hr><h2>sgs_StringMultiConcat [function]</h2><p></p><p>
</p><h3>SGSRESULT sgs_StringMultiConcat( sgs_Context* C, int args )</h3><p>
</p><h4>concatenate the <code>args</code> number of topmost string variables in the current stack frame</h4><p>
</p><p>
</p><h4>error codes</h4><p>
</p><ul><li>SGS_EINVAL: not enough (less than <code>args</code>) variables were found in the current stack frame</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_CloneItem-function'></a><hr><h2>sgs_CloneItem [function]</h2><p></p><p>
</p><h3>SGSRESULT sgs_CloneItem( sgs_Context* C, int item )</h3><p>
</p><h4>push a copy of the specified stack item</h4><p>
</p><p>
<em class='notice-bgr'>Even though operations with functions and strings succeed, functions and strings are not actually cloned since they are immutable.</em>
</p><p>
</p><h4>error codes</h4><p>
</p><ul><li>SGS_EBOUNDS: stack item index was out of bounds
</li><li>SGS_ENOTFND: the object does not support cloning</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_Serialize-function'></a><hr><h2>sgs_Serialize [function]</h2><p></p><p>
</p><h3>SGSRESULT sgs_Serialize( sgs_Context* C )</h3><p>
</p><h4>serialize the topmost variable of the current stack frame (convert to a binary recreation instruction stream)</h4><p>
</p><p>
</p><ul><li>the following variable types can be serialized:
<ul><li>null, bool, int, real, string, func (SGS function)
</li><li>objects with the SGS_OP_SERIALIZE interface function defined</li></ul></li></ul><p>
</p><p>
</p><ul><li>serialized data has the following format:
<ul><li>a list of &#39;P&#39; or &#39;C&#39; commands
</li><li>&#39;P&#39; (push) command: byte - variable type; variable data
<ul><li>variable data: nothing for null, byte for bool, int64 for int, double for real, int32 + char[] for string
</li></ul><li>&#39;C&#39; (call) command: int32 - number of arguments; byte - function name size; char[] - function name</li></ul></li></ul><p>
</p><p>
</p><h4>error codes</h4><p>
</p><ul><li>SGS_EBOUNDS: current stack frame was empty
</li><li>SGS_EINVAL: an unserializable topmost variable was found (function)
</li><li>SGS_EINPROC: unknown memory error</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_SerializeObject-function'></a><hr><h2>sgs_SerializeObject [function]</h2><p></p><p>
</p><h3>SGSRESULT sgs_SerializeObject( sgs_Context* C, int args, const char* func )</h3><p>
</p><h4>write the serialized code for an object&#39;s unserializing function</h4><p>
</p><p>
</p><h4>error codes</h4><p>
</p><ul><li>SGS_EINVAL: function name was too long (255 characters or more)
</li><li>SGS_EINPROC: function was used outside serialization interface function</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_Unserialize-function'></a><hr><h2>sgs_Unserialize [function]</h2><p></p><p>
</p><h3>SGSRESULT sgs_Unserialize( sgs_Context* C )</h3><p>
</p><h4>unserialize the topmost string variable of the current stack frame (run the binary recreation instruction stream)</h4><p>
</p><p>
<em class='notice-bgr'>Be mindful of the data sources you use - calls to any global function can be placed in the instruction stream. (TODO: need the ability to change global variable lists completely)</em>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_CompareF-function'></a><hr><h2>sgs_CompareF [function]</h2><p></p><p>
</p><h3>sgs_Real sgs_CompareF( sgs_Context* C, sgs_Variable* v1, sgs_Variable* v2 )</h3><p>
</p><h4>return the difference between variables, as <code>real</code></h4><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_Compare-function-alias'></a><hr><h2>sgs_Compare [function alias]</h2><p></p><p>
</p><h3>int sgs_Compare( sgs_Context* C, sgs_Variable* v1, sgs_Variable* v2 )</h3><p>
</p><h4>return the difference between variables, as int -1/0/1</h4><p>
</p><p>
</p><ul><li>alias to <a href="sgs_CompareF() + conversion (if result "> 0, return -1; if result </a> 0, return 1; otherwise return 0)</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_EqualTypes-function'></a><hr><h2>sgs_EqualTypes [function]</h2><p></p><p>
</p><h3>SGSBOOL sgs_EqualTypes( sgs_Context* C, sgs_Variable* v1, sgs_Variable* v2 )</h3><p>
</p><h4>return if types of both variables are exactly equal</h4><p>
</p><p>
</p><ul><li>both type variables and interface pointers (only if both variables are objects) are checked for equality</li></ul><p>
</p><p>
</p><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_[GetBool|GetInt|GetReal]-functions'></a><hr><h2>sgs_[GetBool|GetInt|GetReal] [functions]</h2><p></p><p>
</p><h3>sgs_Bool sgs_GetBool( sgs_Context* C, int item )</h3><p>
</p><h3>sgs_Int sgs_GetInt( sgs_Context* C, int item )</h3><p>
</p><h3>sgs_Real sgs_GetReal( sgs_Context* C, int item )</h3><p>
</p><h4>return an item from the current stack frame, converted to the specified type</h4><p>
</p><p>
</p><ul><li>if <code>item</code> is out of bounds, 0 is returned</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_[ToBool|ToInt|ToReal]-functions'></a><hr><h2>sgs_[ToBool|ToInt|ToReal] [functions]</h2><p></p><p>
</p><h3>sgs_Bool sgs_ToBool( sgs_Context* C, int item )</h3><p>
</p><h3>sgs_Int sgs_ToInt( sgs_Context* C, int item )</h3><p>
</p><h3>sgs_Real sgs_ToReal( sgs_Context* C, int item )</h3><p>
</p><h4>return an item from the current stack frame, converted in-place to the specified type</h4><p>
</p><p>
</p><ul><li>in-place conversion means that if the function succeeds, the item in the stack might have a different type, most likely the requested type</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_[ToStringBuf|ToStringBufFast]-functions'></a><hr><h2>sgs_[ToStringBuf|ToStringBufFast] [functions]</h2><p></p><p>
</p><h3>char* sgs_ToStringBuf( sgs_Context* C, int item, sgs_SizeVal* outsize )</h3><p>
</p><h3>char* sgs_ToStringBufFast( sgs_Context* C, int item, sgs_SizeVal* outsize )</h3><p>
</p><h4>return an item from the current stack frame, converted in-place to string</h4><p>
</p><p>
</p><ul><li>if <code>item</code> is out of bounds or conversion fails, NULL is returned
</li><li>the &#39;fast&#39; version uses type name conversion on object, instead of string conversion - this is to avoid recursion while generating a short description about object contents
</li><li>length of string is returned to the value that <code>outsize</code> points to</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_[ToString|ToStringFast]-function-aliases'></a><hr><h2>sgs_[ToString|ToStringFast] [function aliases]</h2><p></p><p>
</p><h3>char* sgs_ToString( sgs_Context* C, int item )</h3><p>
</p><h3>char* sgs_ToStringFast( sgs_Context* C, int item )</h3><p>
</p><h4>return an item from the current stack frame, converted in-place to string</h4><p>
</p><p>
</p><ul><li>aliases of @sgs_ToStringBuf() and @sgs_ToStringBufFast() with the third argument set to NULL</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_Convert-function'></a><hr><h2>sgs_Convert [function]</h2><p></p><p>
</p><h3>SGSRESULT sgs_Convert( sgs_Context* C, int item, int type )</h3><p>
</p><h4>convert an item from the current stack frame to the specified base type</h4><p>
</p><p>
</p><ul><li><code>type</code> expects one of the SGS_VT_* constants</li></ul><p>
</p><p>
</p><h4>error codes</h4><p>
</p><ul><li>SGS_EBOUNDS: index out of bounds
</li><li>SGS_ENOTSUP: object does not support the specific conversion
</li><li>SGS_ENOTFND: object does not support conversions</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_RegisterType-function'></a><hr><h2>sgs_RegisterType [function]</h2><p></p><p>
</p><h3>SGSRESULT sgs_RegisterType( SGS_CTX, const char* name, void** iface )</h3><p>
</p><h4>register a type interface by mapping it to a name</h4><p>
</p><p>
</p><h4>error codes</h4><p>
</p><ul><li>SGS_EINVAL: iface was NULL
</li><li>SGS_EINPROC: the name is already used</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_UnregisterType-function'></a><hr><h2>sgs_UnregisterType [function]</h2><p></p><p>
</p><h3>SGSRESULT sgs_UnregisterType( SGS_CTX, const char* name )</h3><p>
</p><h4>unregister a type interface by its name</h4><p>
</p><p>
</p><h4>error codes</h4><p>
</p><ul><li>SGS_ENOTFND: the specified type name was not mapped to any interface</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_FindType-function'></a><hr><h2>sgs_FindType [function]</h2><p></p><p>
</p><h3>void** sgs_FindType( SGS_CTX, const char* name )</h3><p>
</p><h4>finds the type interface that is mapped to the specified name or returns NULL if that type name cannot be found</h4><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_IsObject-function'></a><hr><h2>sgs_IsObject [function]</h2><p></p><p>
</p><h3>SGSBOOL sgs_IsObject( sgs_Context* C, int item, void** iface )</h3><p>
</p><h4>returns whether the specified stack item <code>item</code> is an object with the interface pointer <code>iface</code></h4><p>
</p><p>
</p><ul><li>if <code>item</code> is out of bounds or not an object or doesn&#39;t have the specified interface, 0 is returned</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_IsType-function-alias'></a><hr><h2>sgs_IsType [function alias]</h2><p></p><p>
</p><h3>SGSBOOL sgs_IsType( sgs_Context* C, int item, const char* type )</h3><p>
</p><h4>returns whether the specified stack item <code>item</code> is an object of the specified type</h4><p>
</p><p>
</p><ul><li>alias of <code>sgs_IsObject( C, item, sgs_FindType( C, type ) )</code></li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_IsCallable-function'></a><hr><h2>sgs_IsCallable [function]</h2><p></p><p>
</p><h3>SGSBOOL sgs_IsCallable( sgs_Context* C, int item )</h3><p>
</p><h4>returns whether the specified stack item <code>item</code> is callable</h4><p>
</p><p>
</p><ul><li>callable variables are either SGS functions or C functions or objects with the SGS_OP_CALL interface implemented
</li><li>if <code>item</code> is out of bounds, 0 is returned</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_IsNumericString-function'></a><hr><h2>sgs_IsNumericString [function]</h2><p></p><p>
</p><h3>SGSBOOL sgs_IsNumericString( const char* str, sgs_SizeVal size )</h3><p>
</p><h4>checks if the string is convertible to an integer/real</h4><p>
</p><p>
</p><ul><li>TODO: link to parsing rules</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_[ParseBool|ParseInt|ParseReal|ParseString]-functions'></a><hr><h2>sgs_[ParseBool|ParseInt|ParseReal|ParseString] [functions]</h2><p></p><p>
</p><h3>SGSBOOL sgs_ParseBool( sgs_Context* C, int item, sgs_Bool* out )</h3><p>
</p><h3>SGSBOOL sgs_ParseInt( sgs_Context* C, int item, sgs_Int* out )</h3><p>
</p><h3>SGSBOOL sgs_ParseReal( sgs_Context* C, int item, sgs_Real* out )</h3><p>
</p><h3>SGSBOOL sgs_ParseString( sgs_Context* C, int item, char** out, sgs_SizeVal* size )</h3><p>
</p><h4>attempts to parse the specified item of the current stack frame, returning whether parsing was successful</h4><p>
</p><p>
</p><ul><li>the parsing rules:
<ul><li>if <code>item</code> is out of bounds, fail
</li><li>if item has the type <code>null</code>, <code>func</code> or <code>cfunc</code>, fail
</li><li>if item is of <code>string</code> type and <code>bool</code> is requested, fail
</li><li>if item is of <code>string</code> type and <code>int</code>/<code>real</code> is requested, try to convert
</li><li>if item is of <code>object</code> type, success of conversion depends on implementation of the object interface and the rules of sgs_GetBool/sgs_GetInt/sgs_GetReal/sgs_ToStringBuf
</li><li>everything else succeeds</li></ul></li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_PushIterator-function'></a><hr><h2>sgs_PushIterator [function]</h2><p></p><p>
</p><h3>SGSRESULT sgs_PushIterator( sgs_Context* C, int item )</h3><p>
</p><h4>create an iterator from the specified item of the current stack frame</h4><p>
</p><p>
</p><ul><li>iterators are objects that enable sequential, ordered traversal of object contents, allowing to read up to 2 variables at each position: the key and the value
</li><li>iterator starts at the pre-first position, so nothing can be read before the initial state</li></ul><p>
</p><p>
</p><h4>error codes</h4><p>
</p><ul><li>SGS_EBOUNDS: index out of bounds
</li><li>SGS_ENOTSUP: variable type does not support iterators (only objects support them)
</li><li>SGS_ENOTFND: object type does not support iterators (iterator conversion request failed)
</li><li>any other code can be returned by the object</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_IterAdvance-function'></a><hr><h2>sgs_IterAdvance [function]</h2><p></p><p>
</p><h3>SGSMIXED sgs_IterAdvance( sgs_Context* C, int item )</h3><p>
</p><h4>advance the iterator to the next position, returning if the current position is still in range or an error code on failure</h4><p>
</p><p>
</p><ul><li>this is the way it&#39;s expected to be usually called: <code>while( sgs_IterAdvance( C, item ) &gt; 0 ){ ... sgs_IterPushData ... }</code></li></ul><p>
</p><p>
</p><h4>error codes</h4><p>
</p><ul><li>SGS_EBOUNDS: index out of bounds
</li><li>SGS_EINVAL: iterated object changed in a way that iterator does not support (currently a size equality test) (TODO: what about any other structural changes? can we have a revision number?)
</li><li>SGS_EINPROC: internal failure in the object interface</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_IterPushData-function'></a><hr><h2>sgs_IterPushData [function]</h2><p></p><p>
</p><h3>SGSRESULT sgs_IterPushData( sgs_Context* C, int item, int key, int value )</h3><p>
</p><h4>load and push the data associated with the current position</h4><p>
</p><p>
</p><ul><li><code>key</code> and <code>value</code> are booleans that specify if the respective value should be returned
</li><li>first the key is pushed, then the value
</li><li>if neither <code>key</code> nor <code>value</code> are expected, the call succeeds and doesn&#39;t push anything</li></ul><p>
</p><p>
</p><h4>error codes</h4><p>
</p><ul><li>SGS_EBOUNDS: index out of bounds
</li><li>SGS_EINVAL: iterated object changed in a way that iterator does not support
</li><li>SGS_EINPROC: internal failure in the object interface</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_ArraySize-function'></a><hr><h2>sgs_ArraySize [function]</h2><p></p><p>
</p><h3>SGSMIXED sgs_ArraySize( sgs_Context* C, int item )</h3><p>
</p><h4>check if the specified stack item is an array and return its size or error code on failure</h4><p>
</p><p>
</p><h4>error codes</h4><p>
</p><ul><li>SGS_EINVAL: index out of bounds / variable was not an array</li></ul><p>
</p><p>
</p><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_StackSize-function'></a><hr><h2>sgs_StackSize [function]</h2><p></p><p>
</p><h3>int sgs_StackSize( sgs_Context* C )</h3><p>
</p><h4>return the size of the current stack frame</h4><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_IsValidIndex-function'></a><hr><h2>sgs_IsValidIndex [function]</h2><p></p><p>
</p><h3>SGSBOOL sgs_IsValidIndex( sgs_Context* C, int item )</h3><p>
</p><h4>return whether the specified stack index points to an item in the current stack frame</h4><p>
</p><p>
</p><ul><li>both positive (first = 0) and negative (last = -1) indices are supported</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_GetStackItem-function'></a><hr><h2>sgs_GetStackItem [function]</h2><p></p><p>
</p><h3>SGSBOOL sgs_GetStackItem( sgs_Context* C, int item, sgs_Variable* out )</h3><p>
</p><h4>write the data of the specified stack variable if the index is valid</h4><p>
</p><p>
</p><ul><li>function returns whether the stack index was valid</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_ItemType-function'></a><hr><h2>sgs_ItemType [function]</h2><p></p><p>
</p><h3>int sgs_ItemType( sgs_Context* C, int item )</h3><p>
</p><h4>return the base type (first 8 bits, mask 0xff) of the specified stack item</h4><p>
</p><p>
</p><ul><li>return value will be equal to one of the SGS_VT_* macro
</li><li>if index is invalid, return value will be 0</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_ItemTypeExt-function'></a><hr><h2>sgs_ItemTypeExt [function]</h2><p></p><p>
</p><h3>int sgs_ItemTypeExt( sgs_Context* C, int item )</h3><p>
</p><h4>return the full type of the specified stack item</h4><p>
</p><p>
</p><ul><li>return value expected to be equal to one of the SGS_VTC_* macro
</li><li>if index is invalid, return value will be 0</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_Method-function'></a><hr><h2>sgs_Method [function]</h2><p></p><p>
</p><h3>SGSBOOL sgs_Method( sgs_Context* C )</h3><p>
</p><h4>unlock the &#39;this&#39; variable, return if the function was called as a method (and thus variable was unlocked)</h4><p>
</p><p>
</p><ul><li>method calls look like this: &quot;object.method(...)&quot;</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_Acquire-function'></a><hr><h2>sgs_Acquire [function]</h2><p></p><p>
</p><h3>void sgs_Acquire( sgs_Context* C, sgs_Variable* var )</h3><p>
</p><h4>increment the reference count of the variable (if it counts references)</h4><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_Release-function'></a><hr><h2>sgs_Release [function]</h2><p></p><p>
</p><h3>void sgs_Release( sgs_Context* C, sgs_Variable* var )</h3><p>
</p><h4>decrement and possibly deallocate the reference count of the variable (if it counts references)</h4><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_ReleaseOwned-function'></a><hr><h2>sgs_ReleaseOwned [function]</h2><p></p><p>
</p><h3>void sgs_ReleaseOwned( sgs_Context* C, sgs_Variable* var, int dco )</h3><p>
</p><h4>decrement and possibly deallocate the reference count of the variable (if it counts references), depending on <code>dco</code></h4><p>
</p><p>
</p><ul><li><code>dco</code> stands for &quot;destroy child objects&quot;, which essentially means that if it&#39;s zero and the variable is an object, it prevents the object from being destroyed
</li><li>expected to be called in destructors of objects may that contain reference-counted variables, using the parameter passed in the callback
</li><li>the child objects need to be preserved in exactly once case: the garbage collector destruction phase - when all objects are scheduled for deletion, it is important to avoid destroying them twice</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_GCMark-function'></a><hr><h2>sgs_GCMark [function]</h2><p></p><p>
</p><h3>SGSRESULT sgs_GCMark( sgs_Context* C, sgs_Variable* var )</h3><p>
</p><h4>mark the specified variable as reachable for the garbage collector</h4><p>
</p><p>
</p><ul><li>to be called in the SGS_OP_GCMARK object callback</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_GetStringPtr-function'></a><hr><h2>sgs_GetStringPtr [function]</h2><p></p><p>
</p><h3>char* sgs_GetStringPtr( sgs_Context* C, int item )</h3><p>
</p><h4>return the string data pointer of the specified stack item, using BreakIf to validate the call</h4><p>
</p><p>
</p><ul><li>if item is out of bounds or not a string, one of the BreakIf macros will go off and stop the action</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_GetStringSize-function'></a><hr><h2>sgs_GetStringSize [function]</h2><p></p><p>
</p><h3>sgs_SizeVal sgs_GetStringSize( sgs_Context* C, int item )</h3><p>
</p><h4>return the string size of the specified stack item, using BreakIf to validate the call</h4><p>
</p><p>
</p><ul><li>if item is out of bounds or not a string, one of the BreakIf macros will go off and stop the action</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_GetObjectData-function'></a><hr><h2>sgs_GetObjectData [function]</h2><p></p><p>
</p><h3>sgs_VarObj* sgs_GetObjectData( sgs_Context* C, int item )</h3><p>
</p><h4>return the object data pointer of the specified stack item, using BreakIf to validate the call</h4><p>
</p><p>
</p><ul><li>if item is out of bounds or not an object, one of the BreakIf macros will go off and stop the action</li></ul><p>
</p><p>
</p><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_SetOutputFunc-function'></a><hr><h2>sgs_SetOutputFunc [function]</h2><p></p><p>
</p><h3>void sgs_SetOutputFunc( sgs_Context* C, sgs_OutputFunc func, void* userdata )</h3><p>
</p><h4>sets the function used in &#39;print&#39; function</h4><p>
</p><p>
</p><ul><li>default implementation copies data to FILE* stream, specified in userdata, it can be found in sgs_ctx.c</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_Write-function'></a><hr><h2>sgs_Write [function]</h2><p></p><p>
</p><h3>void sgs_Write( sgs_Context* C, const void* ptr, sgs_SizeVal size )</h3><p>
</p><h4>passes the specified data to the output function</h4><p>
</p><p>
</p><ul><li>the default output function prints the data to the specified FILE* stream (stdout by default)</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_WriteStr-function-alias'></a><hr><h2>sgs_WriteStr [function alias]</h2><p></p><p>
</p><h3>void sgs_Write( sgs_Context* C, const char* str )</h3><p>
</p><h4>passes the specified string to the output function</h4><p>
</p><p>
</p><ul><li>alias to <code>sgs_Write( C, str, SGS_STRINGLENGTHFUNC( str ) )</code></li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_Writef-function'></a><hr><h2>sgs_Writef [function]</h2><p></p><p>
</p><h3>void sgs_Writef( sgs_Context* C, const char* what, ... )</h3><p>
</p><h4>passes the arguments through a vsprintf-like function to expand the data and passes it to the specified output function</h4><p>
</p><p>
</p><ul><li>printf rules apply here</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_SetPrintFunc-function'></a><hr><h2>sgs_SetPrintFunc [function]</h2><p></p><p>
</p><h3>void sgs_SetPrintFunc( sgs_Context* C, sgs_PrintFunc func, void* userdata )</h3><p>
</p><h4>sets the function that handles and prints the error that has occured, while still being physically in that context</h4><p>
</p><p>
</p><ul><li>both subtypes of the default printing function can be set by passing these flags for <code>func</code> and a FILE* pointer for <code>userdata</code>:
<ul><li>&#39;SGSPRINTFN_DEFAULT&#39; - default behavior (write stack frame, write error, abort on SGS_ERROR)
</li><li>&#39;SGSPRINTFN_DEFAULT_NOABORT&#39; - default behavior without the abort-on-errors feature
</li></ul><li>default implementation writes error and stack trace to FILE* stream, specified in userdata, it can be found in sgs_ctx.c</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_Printf-function'></a><hr><h2>sgs_Printf [function]</h2><p></p><p>
</p><h3>int sgs_Printf( sgs_Context* C, int type, const char* what, ... )</h3><p>
</p><h4>prepares and prints the error specified</h4><p>
</p><p>
</p><ul><li><code>type</code> is the output code (SGS_WARNING, SGS_ERROR etc.)
</li><li><code>what</code> is the error text
<ul><li>additional function name prefix can be specified with @sgs_FuncName or the SGSFN/SGSBASEFN macros
</li></ul><li><code>what</code>, the function name prefix (if set) and the variable arguments are passed to a vsprintf-like function so printf syntax rules apply
</li><li>function always returns 0 to be compatible with most error handling cases in C functions: &quot;return sgs_Printf( ... );&quot;</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_HasFuncName-function'></a><hr><h2>sgs_HasFuncName [function]</h2><p></p><p>
</p><h3>int sgs_HasFuncName( sgs_Context* C )</h3><p>
</p><h4>checks if the currently executed function (last stack frame) has a name literal set</h4><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_FuncName-function'></a><hr><h2>sgs_FuncName [function]</h2><p></p><p>
</p><h3>void sgs_FuncName( sgs_Context* C, const char* fnliteral )</h3><p>
</p><h4>sets the function name string for the currently executed function (last stack frame)</h4><p>
</p><p>
</p><ul><li>the argument is expected to stay alive for the duration of the function call
<ul><li>this makes string literals safe for the call, everything else should be avoided</li></ul></li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='SGSFN-function-alias'></a><hr><h2>SGSFN [function alias]</h2><p></p><p>
</p><h3>void SGSFN( const char* fnliteral )</h3><p>
</p><h4>sets the function name string, more info at @sgs_FuncName</h4><p>
</p><p>
</p><ul><li>alias for <code>sgs_FuncName( &lt;implicit&gt; C, fnliteral )</code></li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='SGSBASEFN-function-alias'></a><hr><h2>SGSBASEFN [function alias]</h2><p></p><p>
</p><h3>void SGSBASEFN( const char* fnliteral )</h3><p>
</p><h4>sets the function name string if it hasn&#39;t already been set for the function</h4><p>
</p><p>
</p><ul><li>alias for <code>if( !sgs_HasFuncName( &lt;implicit&gt; C ) ) sgs_FuncName( &lt;implicit&gt; C, x )</code></li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_SetHookFunc-function'></a><hr><h2>sgs_SetHookFunc [function]</h2><p></p><p>
</p><h3>void sgs_SetHookFunc( sgs_Context* C, sgs_HookFunc func, void* ctx )</h3><p>
</p><h4>sets the hook function and user data pointer</h4><p>
</p><p>
</p><ul><li>hook function is called on function entry, exit and instruction change events
</li><li>setting a new hook function disables the one that was set before (if any)</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_GetHookFunc-function'></a><hr><h2>sgs_GetHookFunc [function]</h2><p></p><p>
</p><h3>SGSBOOL sgs_GetHookFunc( sgs_Context* C, sgs_HookFunc* outfunc, void** outctx )</h3><p>
</p><h4>writes the hook function and user data pointer that was set (if any), returns whether anything was written</h4><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_Memory-function'></a><hr><h2>sgs_Memory [function]</h2><p></p><p>
</p><h3>void sgs_Memory( sgs_Context* C, void* ptr, size_t size )</h3><p>
</p><h4>allocates and frees memory, as specified in arguments</h4><p>
</p><p>
</p><ul><li>there are four possible cases that are handled by the function:
<ul><li><code>ptr</code> != NULL, <code>size</code> != 0: <code>ptr</code> is reallocated with new size, keeping as much data as possible, new block of memory is returned
</li><li><code>ptr</code> != NULL, <code>size</code> == 0: <code>ptr</code> is freed, NULL is returned
</li><li><code>ptr</code> == NULL, <code>size</code> != 0: a new block of memory is allocated and returned
</li><li><code>ptr</code> == NULL, <code>size</code> == 0: nothing is done, NULL is returned</li></ul></li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='memory-allocation-macros-macros'></a><hr><h2>memory allocation macros [macros]</h2><p></p><p>
</p><h3>Memory allocation macros</h3><p>
</p><h4>these macros allow slightly simplified handling of memory</h4><p>
</p><p>
</p><ul><li><code>sgs_Malloc( C, size )</code>: allocates the memory (alias to <code>sgs_Memory( C, NULL, size )</code>)
</li><li><code>sgs_Free( C, ptr )</code>: frees the memory (alias to <code>sgs_Memory( C, ptr, 0 )</code>)
</li><li>sgs_Realloc: alias to sgs_Memory
</li><li>the following macros expect that the variable sgs_Context* C is in the scope
<ul><li><code>sgs_Alloc( what )</code>: allocates enough memory to fit the specified type <code>what</code>
</li><li><code>sgs_Alloc_n( what, n )</code>: allocates enough memory to fit <code>n</code> instances of the specified type <code>what</code>
</li><li><code>sgs_Alloc_a( what, app )</code>: allocates enough memory to fit the specified type <code>what</code> and <code>app</code> more bytes
</li><li><code>sgs_Dealloc( ptr )</code>: frees the memory
</li></ul><li>all of these functions, including sgs_Memory, work on the same heap, thus they are interchangeable</li></ul><p>
</p><p>
</p><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_CodeString-function'></a><hr><h2>sgs_CodeString [function]</h2><p></p><p>
</p><h3>const char* sgs_CodeString( int type, int val )</h3><p>
</p><h4>returns a string for the enumeration <code>type</code> value <code>val</code></h4><p>
</p><p>
</p><ul><li>there are 4 enumerations to have value names returned for:
<ul><li>SGS_CODE_ER: error codes (SGS_ERROR, SGS_WARNING, ...)
</li><li>SGS_CODE_VT: variable types (SGS_VT_BOOL, SGS_VT_FUNC, ...)
</li><li>SGS_CODE_OP: VM instructions (SGS_SI_PUSH, SGS_SI_FORPREP, ... [internal])
</li><li>SGS_CODE_OI: object interface function types (SGS_OP_GETINDEX, SGS_OP_GCMARK, ...)</li></ul></li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_Abort-function'></a><hr><h2>sgs_Abort [function]</h2><p></p><p>
</p><h3>SGSRESULT sgs_Abort( sgs_Context* C )</h3><p>
</p><h4>stops execution of current SGS functions up to the last C function in the stack, excluding the current</h4><p>
</p><p>
</p><h4>error codes</h4><p>
</p><ul><li>SGS_ENOTFND: last or next to last function in the stack was not a SGS function</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_Stat-function'></a><hr><h2>sgs_Stat [function]</h2><p></p><p>
</p><h3>SGSMIXED sgs_Stat( sgs_Context* C, int type )</h3><p>
</p><h4>returns or prints information about state of SGScript VM</h4><p>
</p><p>
</p><ul><li>the following <code>type</code> values are supported:
<ul><li>SGS_STAT_VERSION: returns the version number of the VM
</li><li>SGS_STAT_APIVERSION: returns the API version numver of the VM
</li><li>SGS_STAT_OBJCOUNT: returns the number of objects created in the VM
</li><li>SGS_STAT_MEMSIZE: returns the number of bytes allocated through this SGScript context
</li><li>SGS_STAT_NUMALLOCS: returns the number of memory allocations (incremented on each alloc/realloc)
</li><li>SGS_STAT_NUMFREES: returns the number of memory frees (incremented on each free/realloc)
</li><li>SGS_STAT_NUMBLOCKS: number of memory blocks currently allocated (incremented on alloc, decremented on free)
</li><li>SGS_STAT_DUMP_STACK: prints all of the variables in the stack
</li><li>SGS_STAT_DUMP_GLOBALS: prints all variables in the global dictionary
</li><li>SGS_STAT_DUMP_OBJECTS: prints all objects in the context
</li><li>SGS_STAT_DUMP_FRAMES: prints all functions in the call stack
</li><li>SGS_STAT_DUMP_STATS: dump some info about memory and objects</li></ul></li></ul><p>
</p><p>
</p><ul><li>tips:
<ul><li>compare return value of SGS_STAT_VERSION against SGS_VERSION_INT if the code is version-sensitive
</li><li>compare return value of SGS_STATE_APIVERSION against SGS_API_VERSION if dynamic loading is used and multiple versions should be supported</li></ul></li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_Cntl-function'></a><hr><h2>sgs_Cntl [function]</h2><p></p><p>
</p><h3>int32_t sgs_Cntl( sgs_Context* C, int what, int32_t val )</h3><p>
</p><h4>modifies the state of the VM or returns info about it</h4><p>
</p><p>
</p><ul><li>the following <code>what</code> values are supported:
<ul><li>SGS_CNTL_STATE: sets the new compilation state from <code>val</code>, returns the previous value
</li><li>SGS_CNTL_GET_STATE: returns the currently set compilation state
</li><li>SGS_CNTL_MINLEV: sets the new minimum error level from <code>val</code>, returns the previous value
</li><li>SGS_CNTL_GET_MINLEV: returns the currently set minimum error level
</li><li>SGS_CNTL_ERRNO: if <code>val</code> is true, sets internal errno to 0, otherwise - to <code>errno</code>, returns the previous value
</li><li>SGS_CNTL_SET_ERRNO: sets internal errno to <code>val</code>, returns the previous value
</li><li>SGS_CNTL_GET_ERRNO: returns the currently set internal errno
</li></ul><li>everything else does nothing and returns 0</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_GetFramePtr-function'></a><hr><h2>sgs_GetFramePtr [function]</h2><p></p><p>
</p><h3>sgs_StackFrame* sgs_GetFramePtr( sgs_Context* C, int end )</h3><p>
</p><h4>returns a call stack frame pointer</h4><p>
</p><p>
</p><ul><li>if <code>end</code> is not 0, pointer to topmost frame is returned, otherwise a pointer to first frame is returned</li></ul><p>
</p><p>
</p><p>
sgs_Errno [function (inline)]
</p><p>
</p><h3>int sgs_Errno( sgs_Context* C, int clear )</h3><p>
</p><h4>copies errno to internal errno value if <code>clear</code> is not 0, otherwise internal errno value is set to 0, returns <code>clear</code></h4><p>
</p><p>
</p><ul><li>used with a boolean expression and chaining to set errno if the expression returned false, like this:
<ul><li><code>sgs_PushBool( C, sgs_Errno( C, rename( a, b ) == 0 ) )</code></li></ul></li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_SetErrno-function-alias'></a><hr><h2>sgs_SetErrno [function alias]</h2><p></p><p>
</p><h3>int sgs_SetErrno( sgs_Context* C, int err )</h3><p>
</p><h4>sets a specific value <code>err</code> to the internal errno variable</h4><p>
</p><p>
</p><ul><li>alias to <code>sgs_Cntl( C, SGS_CNTL_SET_ERRNO, err )</code></li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sgs_GetLastErrno-function-alias'></a><hr><h2>sgs_GetLastErrno [function alias]</h2><p></p><p>
</p><h3>int sgs_GetLastErrno( sgs_Context* C )</h3><p>
</p><h4>returns the currently set internal errno variable</h4><p>
</p><p>
</p><ul><li>alias to <code>sgs_Cntl( C, SGS_CNTL_GET_ERRNO, 0 )</code></li></ul><p>
</p><p>
</p><p>
</p><p>
</p><p></p></div><div class='item'><a name='array-function'></a><hr><h2>array [function]</h2><p></p><p>
</p><h3>array( ... )</h3><p>
</p><h4>returns an array, containing the arguments</h4><p>
</p><p>
</p><ul><li>similar to the array literal, though somewhat limited</li></ul><p>
</p><p>
</p><pre>array( &quot;5&quot;, 6, 7.0 ) // same as [&quot;5&quot;,6,7.0]</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='dict-function'></a><hr><h2>dict [function]</h2><p></p><p>
</p><h3>dict( [key, value, ...] )</h3><p>
</p><h4>returns a &#39;dict&#39; (dictionary/hash table) object, containing the even arguments mapped to respective previous arguments</h4><p>
</p><p>
</p><ul><li>if no arguments are passed, an empty dictionary is returned
</li><li>if an even number of arguments is passed, function returns null and emits a warning
</li><li>all even arguments must be strings or convertible to strings</li></ul><p>
</p><p>
</p><pre>dict( &quot;name&quot;, &quot;John&quot;, &quot;phone&quot;, 1234567890 ); // same as { name = &quot;John&quot;, phone = 1234567890 }</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='class-function'></a><hr><h2>class [function]</h2><p></p><p>
</p><h3>class( first, second )</h3><p>
</p><h4>returns a class object with <code>first</code> set as the primary data source and <code>second</code> set as the secondary/backup data source</h4><p>
</p><p>
</p><ul><li>both arguments accept all kinds of variables but it&#39;s generally preferred to use only dicts / special objects
</li><li>refer to @CLASSES for more information on how class objects work and how to use them</li></ul><p>
</p><p>
</p><pre>someCommonInterface = { printdata = function(){ print( this.data ); } };
c = class( { data = &quot;5&quot; }, someCommonInterface );
c.data = &quot;6&quot;;
c.printdata(); // prints 6</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='closure-function'></a><hr><h2>closure [function]</h2><p></p><p>
</p><h3>closure( callable, data )</h3><p>
</p><h4>returns a closure object with <code>callable</code> set as the callable variable and <code>data</code> set as the first argument for the closure call</h4><p>
</p><p>
</p><ul><li>second argument accepts all kinds of variables, first requires a variable that can be called (SGScript function / C function / object with OP_CALL interface function defined)
</li><li>refer to @CLOSURES for more information on how closure objects work and how to use them</li></ul><p>
</p><p>
</p><pre>counter = closure( function( data ){ return data[0]++; }, [0] );
print( counter() ); print( counter() ); // prints &quot;01&quot;</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='isset-function'></a><hr><h2>isset [function]</h2><p></p><p>
</p><h3>isset( var, string key )</h3><p>
</p><h4>returns whether a property named <code>key</code> is accessible (exists) in variable <code>var</code></h4><p>
</p><p>
</p><pre>x = { a = 5 };
isset( x, &quot;a&quot; ); // returns &#39;true&#39;
isset( x, &quot;b&quot; ); // returns &#39;false&#39;
isset( print, &quot;thiscall&quot; ); // returns &#39;true&#39; -- works with built-in special properties too</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='unset-function'></a><hr><h2>unset [function]</h2><p></p><p>
</p><h3>unset( dict var, string key )</h3><p>
</p><h4>removes an entry named <code>key</code> from the dictionary <code>var</code></h4><p>
</p><p>
</p><p></p></div><div class='item'><a name='clone-function'></a><hr><h2>clone [function]</h2><p></p><p>
</p><h3>clone( var )</h3><p>
</p><h4>creates a one-reference copy of the variable <code>var</code> or returns null and emits a warning on failure</h4><p>
</p><p>
</p><ul><li>variables that are passed by value (null, bool, int, real, cfunc) or functions are returned as-is, since for value types all copies are same and functions are immutable -- TODO: what about strings? they&#39;re currently cloned</li></ul><p>
</p><p>
</p><pre>x = { a = 5 };
y = clone( x );
z = x;
x.a = 6;
print( y.a ); // prints &quot;5&quot;
print( z.a ); // prints &quot;6&quot;</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='get_keys-function'></a><hr><h2>get_keys [function]</h2><p></p><p>
</p><h3>get_keys( iterable var )</h3><p>
</p><h4>returns an array of keys found in the iterable object <code>var</code> or returns null and emits a warning on failure</h4><p>
</p><p>
</p><ul><li><code>var</code> must be an iterable object (has interface OP_CONVERT defined and successfully handles a CONVOP_TOITER request) - such objects are <code>array</code>, <code>dict</code> and <code>io_dir</code></li></ul><p>
</p><p>
</p><pre>get_keys( [5,7,0] ); // returns [0,1,2]
get_keys( {b=5,a=2} ); // returns [&quot;b&quot;,&quot;a&quot;]</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='get_values-function'></a><hr><h2>get_values [function]</h2><p></p><p>
</p><h3>get_values( iterable var )</h3><p>
</p><h4>returns an array of values found in the iterable object <code>var</code> or returns null and emits a warning on failure</h4><p>
</p><p>
</p><ul><li><code>var</code> must be an iterable object (has interface OP_CONVERT defined and successfully handles a CONVOP_TOITER request) - such objects are <code>array</code>, <code>dict</code> and <code>io_dir</code></li></ul><p>
</p><p>
</p><pre>get_values( [5,7,0] ); // returns [5,7,0]
get_values( {b=5,a=2} ); // returns [5,2]</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='get_concat-function'></a><hr><h2>get_concat [function]</h2><p></p><p>
</p><h3>get_concat( iterable var, iterable var1, ... )</h3><p>
</p><h4>returns an array of values found in all iterable objects passed to the function or returns null and emits a warning on failure</h4><p>
</p><p>
</p><pre>get_concat( [1,2], {a=&quot;5&quot;,b=8} ); // returns [1,2,&quot;5&quot;,8]</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='get_merged-function'></a><hr><h2>get_merged [function]</h2><p></p><p>
</p><h3>get_merged( iterable var, iterable var1, ... )</h3><p>
</p><h4>returns a dict of all key-value pairs found in all iterable objects passed to the function or returns null and emits a warning on failure</h4><p>
</p><p>
</p><pre>get_merged( [1,2], [3], {a=&quot;4&quot;} ); // return {0=3,1=2,a=&quot;4&quot;}</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='tobool-function'></a><hr><h2>tobool [function]</h2><p></p><p>
</p><h3>tobool( var )</h3><p>
</p><h4>returns a boolean, generated from variable <code>var</code> using the @conversion rules</h4><p>
</p><p>
</p><ul><li>this function is equivalent to @sgs_GetBool / @sgs_ToBool in the C API</li></ul><p>
</p><p>
</p><pre>tobool( 5 ); // returns &#39;true&#39;
tobool( &quot;&quot; ); // returns &#39;false&#39;</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='toint-function'></a><hr><h2>toint [function]</h2><p></p><p>
</p><h3>toint( var )</h3><p>
</p><h4>returns an integer, generated from variable <code>var</code> using the @conversion rules</h4><p>
</p><p>
</p><ul><li>this function is equivalent to @sgs_GetInt / @sgs_ToInt in the C API</li></ul><p>
</p><p>
</p><pre>toint( 5.4 ); // returns 5
toint( &quot;0xff&quot; ); // returns 255</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='toreal-function'></a><hr><h2>toreal [function]</h2><p></p><p>
</p><h3>toreal( var )</h3><p>
</p><h4>returns a real value, generated from variable <code>var</code> using the @conversion rules</h4><p>
</p><p>
</p><ul><li>this function is equivalent to @sgs_GetReal / @sgs_ToReal in the C API</li></ul><p>
</p><p>
</p><pre>toreal( 5 ); // returns 5.0
toreal( &quot;3e+2&quot; ); // returns 3.0 -- exponential string values don&#39;t work (TODO: why)
toreal( &quot;0xff&quot; ); // returns 255.0</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='tostring-function'></a><hr><h2>tostring [function]</h2><p></p><p>
</p><h3>tostring( var )</h3><p>
</p><h4>returns a string value, generated from variable <code>var</code> using the @conversion rules</h4><p>
</p><p>
</p><ul><li>this function is equivalent to @sgs_ToString in the C API</li></ul><p>
</p><p>
</p><pre>tostring( 5 ); // returns &quot;5&quot;
tostring( { &quot;a&quot; = &quot;b&quot; } ); // returns &quot;{a=b}&quot;</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='typeof-function'></a><hr><h2>typeof [function]</h2><p></p><p>
</p><h3>typeof( var )</h3><p>
</p><h4>returns the type name of variable <code>var</code>, as string</h4><p>
</p><p>
</p><ul><li>this function is equivalent to @sgs_Typeof in the C API</li></ul><p>
</p><p>
</p><pre>typeof( 5 ); // returns &quot;real&quot;
typeof( [] ); // returns &quot;array&quot;</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='typeid-function'></a><hr><h2>typeid [function]</h2><p></p><p>
</p><h3>typeid( var )</h3><p>
</p><h4>returns the first 4 bits of the variable <code>var</code> type flags, as <code>int</code></h4><p>
</p><p>
</p><ul><li>returns one of the values mapped to VT_NULL/VT_BOOL/VT_INT/VT_REAL/VT_STRING/VT_FUNC/VT_CFUNC/VT_OBJECT
</li><li>this function is equivalent to @sgs_ItemType in the C API</li></ul><p>
</p><p>
</p><pre>typeid( 5 ) == VT_REAL; // returns &#39;true&#39;
typeid( [] ); // returns 0x80 / VT_OBJECT</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='typeflags-function'></a><hr><h2>typeflags [function]</h2><p></p><p>
</p><h3>typeflags( var )</h3><p>
</p><h4>returns the type flags of the variable <code>var</code>, as <code>int</code></h4><p>
</p><p>
</p><ul><li>returns a bitfield, consisting of many different VT_* and VTF_* value combos, matching one of VTC_* values
</li><li>this function is equivalent to @sgs_ItemTypeExt in the C API</li></ul><p>
</p><p>
</p><pre>typeflags( 5 ) == VTC_REAL; // returns &#39;true&#39;
typeid( [] ) &amp; VT_OBJECT != 0; // returns &#39;true&#39;
typeid( &quot;&quot; ) &amp; VTF_NUMERIC != 0; // returns &#39;false&#39;</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='is_numeric-function'></a><hr><h2>is_numeric [function]</h2><p></p><p>
</p><h3>is_numeric( var )</h3><p>
</p><h4>returns whether the variable <code>var</code> is numeric - one of bool/int/real or a numeric string</h4><p>
</p><p>
</p><ul><li>all types that can always be converted to numbers are considered numeric, with two exceptions:
<ul><li>convertible objects are not numeric since validation requires an interface call and unnecessary interface calls cannot be made
</li><li>null value is considered to be the lack of a better value, thus it cannot be considered valid, even though it always maps implicitly to the integer 0</li></ul></li></ul><p>
</p><p>
</p><pre>is_numeric( 12.124 ); // returns true
is_numeric( &quot;what&quot; ); // returns false</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='is_callable-function'></a><hr><h2>is_callable [function]</h2><p></p><p>
</p><h3>is_callable( var )</h3><p>
</p><h4>returns whether the variable <code>var</code> is callable - a function (func/cfunc) or an object with OP_CALL defined</h4><p>
</p><p>
</p><ul><li>this function is equivalent to @sgs_IsCallable in the C API</li></ul><p>
</p><p>
</p><pre>is_callable( print ); // returns &#39;true&#39;
is_callable( closure( print, 5 ) ); // returns &#39;true&#39;
is_callable( 5 ); // returns &#39;false&#39;</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='loadtypeflags-function'></a><hr><h2>loadtypeflags [function]</h2><p></p><p>
</p><h3>loadtypeflags()</h3><p>
</p><h4>sets the globals beginning with VTF_ and VTC_</h4><p>
</p><p>
</p><ul><li>since these features are expected to be rarely used, they&#39;re set to be loaded on-demand, not on startup</li></ul><p>
</p><p>
</p><pre>isset( _G, &quot;VTF_NUM&quot; ); // returns &#39;false&#39;
loadtypeflags();
isset( _G, &quot;VTF_NUM&quot; ); // returns &#39;true&#39;</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='print,-println,-printlns-functions'></a><hr><h2>print, println, printlns [functions]</h2><p></p><p>
</p><h3>print( ... ), println( ... ), printlns( ... ),</h3><p>
</p><h4>passes all arguments, converted to strings, to the @output callback</h4><p>
</p><ul><li>print passes arguments without modifications
</li><li>println passes a newline character after all variables
</li><li>printlns passes a newline character after each variable</li></ul><p>
</p><p>
</p><pre>print( 5, &quot;x&quot; ); // prints &quot;5x&quot;
println( 5, &quot;x&quot; ); // prints &quot;5x\n&quot;
printlns( 5, &quot;x&quot; ); // prints &quot;5\nx\n&quot;</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='printvar_ext-function'></a><hr><h2>printvar_ext [function]</h2><p></p><p>
</p><h3>printvar( var, int maxdepth = 5 )</h3><p>
</p><h4>passes a dump of the variable (informative string version) to the @output callback, allowing to optionally specify the maximum depth of the dump (how deep it is allowed to look for sub-variables)</h4><p>
</p><p>
</p><pre>printvar( 5 ); // prints &quot;real (5)&quot;
printvar( &quot;wat&quot; ); // prints &quot;string [3] &quot;wat&quot;&quot;
printvar( [{a=[{}]}], 2 ); /* prints:
object (003C5F90) [0] array (1)
[
  object (003C60A8) [1] dict (1)
  {
    ...
  }
]
*/</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='printvar-function'></a><hr><h2>printvar [function]</h2><p></p><p>
</p><h3>printvars( var, ... )</h3><p>
</p><h4>same as a list of printvar(var); calls for each argument</h4><p>
</p><p>
</p><ul><li>refer to @printvar_ext() for more info</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='read_stdin-function'></a><hr><h2>read_stdin [function]</h2><p></p><p>
</p><h3>read_stdin( bool all = false )</h3><p>
</p><h4>reads from the standard input</h4><p>
</p><p>
</p><ul><li>if <code>all</code> is set to &#39;true&#39;, all standard input is read up to EOF (useful for piped input)
</li><li>if <code>all</code> is set to &#39;false&#39; or not set at all, input is read up to (and excluding) the next newline character</li></ul><p>
</p><p>
</p><pre>print &quot;Name: &quot;; name = read_stdin(); // waits for user input
process( read_stdin(true) ); // loads all piped input</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='ftime-function'></a><hr><h2>ftime [function]</h2><p></p><p>
</p><h3>ftime()</h3><p>
</p><h4>returns a value that is increased by a total of 1 each second (time), as real</h4><p>
</p><p>
</p><ul><li>guaranteed to offer sub-second precision unless stated otherwise for any specific platform</li></ul><p>
</p><p>
</p><pre>start = ftime();
do_something_big();
println( &quot;That took &quot; $ ftime() - start $ &quot; seconds.&quot; );</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='rand-function'></a><hr><h2>rand [function]</h2><p></p><p>
</p><h3>rand()</h3><p>
</p><h4>returns a random &#39;int&#39; value in the range [0;RAND_MAX) - from 0, inclusive, to RAND_MAX, exclusive</h4><p>
</p><p>
</p><p></p></div><div class='item'><a name='randf-function'></a><hr><h2>randf [function]</h2><p></p><p>
</p><h3>randf()</h3><p>
</p><h4>returns a random &#39;real&#39; value in the range [0;1) - from 0, inclusive, to 1, exclusive</h4><p>
</p><p>
</p><p></p></div><div class='item'><a name='srand-function'></a><hr><h2>srand [function]</h2><p></p><p>
</p><h3>srand( int seed )</h3><p>
</p><h4>specify a different seed value for the built-in pseudo-random number generator</h4><p>
</p><p>
</p><pre>srand( 5 ); // restart the generator with the value specified
srand( ftime() ); // restart the generator depending on the second the code was executed</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='pcall-function'></a><hr><h2>pcall [function]</h2><p></p><p>
</p><h3>pcall( callable func[, callable errh ])</h3><p>
</p><h4>calls the callable <code>func</code>, hiding internal errors from the caller or optionally passing them to callable <code>errh</code></h4><p>
</p><p>
</p><ul><li><code>errh</code> error handler is called with two arguments - <code>int error_type, string message</code> - and expected to return 0-1 arguments ([int])
</li><li>error handler must return 0/null/nothing if the error has been successfully processed or the new error type otherwise
<ul><li>errors thrown inside the handler will not be caught so any error can be transformed to any other
</li><li>an empty function behaves the same way as <code>pcall</code> without function</li></ul></li></ul><p>
</p><p>
</p><pre>include &quot;string&quot;;

function handler( type, msg )
{
    if( string_find( msg, &quot;not found&quot; ) !== null )
        sys_print( type, &quot;nooooooooooo&quot; );
}

function handler2( type, msg )
{
    if( string_find( msg, &quot;not found&quot; ) !== null )
        return SGS_ERROR;
}

pcall(function(){ print x; }); // nothing
pcall(function(){ print x; }, handler ); // renamed warning
pcall(function(){ print x; }, handler2 ); // changed type to error</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='eval-function'></a><hr><h2>eval [function]</h2><p></p><p>
</p><h3>eval( string code )</h3><p>
</p><h4>returns the result of evaluating the passed <code>code</code> string as SGScript code</h4><p>
</p><p>
</p><ul><li>this function is equivalent to @sgs_EvalBuffer/@sgs_EvalString in the C API</li></ul><p>
</p><p>
</p><pre>eval(&quot;print 5;&quot;); // prints 5</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='eval_file-function'></a><hr><h2>eval_file [function]</h2><p></p><p>
</p><h3>eval_file( string filename )</h3><p>
</p><h4>returns the result of evaluating the file pointed to by <code>filename</code> as SGScript code</h4><p>
</p><p>
</p><ul><li>this function is equivalent to @sgs_EvalFile in the C API</li></ul><p>
</p><p>
</p><pre>eval_file(&quot;myfile.sgs&quot;); // ???</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='include_library-function'></a><hr><h2>include_library [function]</h2><p></p><p>
</p><h3>include_library( string lib[, bool override ] )</h3><p>
</p><h4>loads the global variables of the specific library <code>lib</code> in the state, returns success, as <code>bool</code>, emits a warning on failure</h4><p>
</p><p>
</p><ul><li>lib must be one of &#39;fmt&#39;, &#39;io&#39;, &#39;math&#39;, &#39;os&#39;, &#39;string&#39;
</li><li>if <code>override</code> is specified, library will be reloaded even if it was already loaded before
</li><li>this function is equivalent to the sgs_LoadLib_* functions in the C API</li></ul><p>
</p><p>
</p><pre>printvar( sin ); // warning, null
include_library( &quot;math&quot; );
printvar( sin ); // C function</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='include_file-function'></a><hr><h2>include_file [function]</h2><p></p><p>
</p><h3>include_file( string file[, bool override ] )</h3><p>
</p><h4>executes the file pointed to by <code>file</code>, returns success, as <code>bool</code>, emits a warning on failure</h4><p>
</p><p>
</p><ul><li><code>file</code> must be available in one of the include paths (TODO: we don&#39;t have &#39;em yet)
</li><li>if <code>override</code> is specified, file will be reloaded even if it was already loaded before
</li><li>this function is equivalent to @sgs_ExecFile in the C API</li></ul><p>
</p><p>
</p><pre>include_file( &quot;something.sgs&quot; ); // loads something
include_file( &quot;something.sgs&quot; ); // does not load it again
include_file( &quot;something.sgs&quot;, true ); // loads it again</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='include_shared-function'></a><hr><h2>include_shared [function]</h2><p></p><p>
</p><h3>include_shared( string file[, bool override ] )</h3><p>
</p><h4>runs the shared library pointed to by <code>file</code>, returns success, as <code>bool</code>, emits a warning on failure</h4><p>
</p><p>
</p><ul><li><code>file</code> must be available according to the platform-specific rules of dynamic libraries (shared objects)
</li><li>the library must contain a &#39;sgscript_main&#39; function that will be called on initialization
</li><li>if <code>override</code> is specified, file will be reloaded even if it was already loaded before</li></ul><p>
</p><p>
</p><pre>include_shared( &quot;sgsjson.dll&quot; ); // load the JSON library DLL on Windows</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='include-function'></a><hr><h2>include [function]</h2><p></p><p>
</p><h3>include( string file[, bool override ] )</h3><p>
</p><h4>tries to load a library or a file according to the include path</h4><p>
</p><p>
</p><ul><li>the order of actions:
<ul><li>first, a library load is attempted
</li><li>on failure, a file is looked for by every entry of the sys_include_path variable (? - the file replacement symbol, ; - separator)
</li><li>if file is not found, everything stops
</li><li>if file is found, first - a library load is attempted, on failure - bytecode &amp; source code loading
</li></ul><li>this function is also available as a replicating statement &#39;include&#39; (ex. &#39;include &quot;fmt&quot;, &quot;io&quot;;&#39; works the same way as include(&quot;fmt&quot;); include(&quot;io&quot;);)</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='import_cfunc-function'></a><hr><h2>import_cfunc [function]</h2><p></p><p>
</p><h3>import_cfunc( string file, string funcname )</h3><p>
</p><h4>retrieves the <code>funcname</code> function of the shared library <code>file</code>, returns success, as <code>bool</code>, emits a warning on failure</h4><p>
</p><p>
<em class='notice-bgr'>Do not call &#39;sgscript_main&#39; using this function! That function has different return value semantics so at best, something will work, a warning could be emitted and the worst case is that something will crash.</em>
</p><p>
</p><ul><li><code>file</code> must be available according to the platform-specific rules of dynamic libraries (shared objects)</li></ul><p>
</p><p>
</p><pre>import_cfunc( &quot;mydll.dll&quot;, &quot;someSGScriptFunc&quot; )();</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='sys_curfile-function'></a><hr><h2>sys_curfile [function]</h2><p></p><p>
</p><h3>sys_curfile()</h3><p>
</p><h4>returns the path of the file (as passed on load) that contains the currently executed code or <code>null</code> if the file cannot be determined (eval, C functions)</h4><p>
</p><p>
</p><pre>// a.sgs
print( sys_curfile() ); // prints &quot;a.sgs&quot;
// b.sgs
include &quot;a.sgs&quot;;</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='sys_print-function'></a><hr><h2>sys_print [function]</h2><p></p><p>
</p><h3>sys_print( int code, string message )</h3><p>
</p><h4>passes a message to the internal messaging system (one that&#39;s commonly used to report errors and warnings)</h4><p>
</p><p>
<em class='notice-bgr'>Different codes can be handled differently by the system. By default, SGS_ERROR code will stop execution and return to C code as soon as possible.</em>
</p><p>
</p><ul><li><code>code</code> is the code to use to pass the message (ex. SGS_INFO, SGS_WARNING, SGS_ERROR)</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='sys_abort-function'></a><hr><h2>sys_abort [function]</h2><p></p><p>
</p><h3>sys_abort()</h3><p>
</p><h4>stops execution and returns to C code as soon as possible</h4><p>
</p><p>
</p><ul><li>this function is equivalent to @sgs_Abort in the C API</li></ul><p>
</p><p>
</p><pre>sys_abort();
print( 5 ); // this line is not reached</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='app_abort-function'></a><hr><h2>app_abort [function]</h2><p></p><p>
</p><h3>app_abort()</h3><p>
</p><h4>calls the abort() function of the C standard library (crashes the application)</h4><p>
</p><p>
</p><p></p></div><div class='item'><a name='app_exit-function'></a><hr><h2>app_exit [function]</h2><p></p><p>
</p><h3>app_exit( code = 0 )</h3><p>
</p><h4>calls the exit() function of the C standard library (exits the application)</h4><p>
</p><p>
</p><p></p></div><div class='item'><a name='sys_replevel-function'></a><hr><h2>sys_replevel [function]</h2><p></p><p>
</p><h3>sys_replevel([ level ])</h3><p>
</p><h4>returns the current reported error level and optionally sets a new one</h4><p>
</p><p>
<em class='notice-bgr'>The effects of this function are not reverted automatically at any moment (unless implemented manually with hooks).</em>
</p><p>
</p><pre>old_level = sys_replevel( SGS_ERROR ); // report only errors or worse
magic = calculate_magic(); // any warnings are never processed at this point
sys_replevel( old_level ); // restore the old reported level</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='sys_stat-function'></a><hr><h2>sys_stat [function]</h2><p></p><p>
</p><h3>sys_stat( code )</h3><p>
</p><h4>prints info about virtual machine state, everything is implementation-defined</h4><p>
</p><p>
</p><ul><li>accepted codes are the same as for @sgs_Stat, which this function is equivalent to</li></ul><p>
</p><p>
</p><pre>sys_stat( 11 ); // dumps all globals</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='errno-function'></a><hr><h2>errno [function]</h2><p></p><p>
</p><h3>errno( as_string = false )</h3><p>
</p><h4>returns the last relevant error number for the C standard library, as an integer or a string if <code>as_string</code> is set</h4><p>
</p><p>
</p><ul><li>last relevant error number is defined by @sgs_Errno/@sgs_SetErrno C API functions</li></ul><p>
</p><p>
</p><pre>data = io_file_read( &quot;doesnotexist&quot; ); // file that does not exist
print errno(); // prints 2
print errno(true); // prints &quot;No such file or directory&quot; on Windows</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='errno_string-function'></a><hr><h2>errno_string [function]</h2><p></p><p>
</p><h3>errno_string( int code )</h3><p>
</p><h4>returns the error string for the given code</h4><p>
</p><p>
</p><ul><li>errno_string(errno()) is equivalent to errno(true)</li></ul><p>
</p><p>
</p><pre>print errno_string(2); // prints &quot;No such file or directory&quot; on Windows</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='errno_value-function'></a><hr><h2>errno_value [function]</h2><p></p><p>
</p><h3>errno_value( string key )</h3><p>
</p><h4>returns the number for the error key (for &quot;ENOENT&quot; it would return 2)</h4><p>
</p><p>
</p><ul><li>this function might be a bit slow considering that it currently does not use any extended lookup systems, such as hash tables</li></ul><p>
</p><p>
</p><pre>data = io_file_read( &quot;doesnotexist&quot; );
if( errno() == error_string(&quot;ENOENT&quot;) )
    println( &quot;file does not exist&quot; );</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='dumpvar_ext-function'></a><hr><h2>dumpvar_ext [function]</h2><p></p><p>
</p><h3>dumpvar( var, int depth = 5 )</h3><p>
</p><h4>similar to @printvar_ext() but returns the dump instead of printing it</h4><p>
</p><p>
</p><ul><li>this function is equivalent to @sgs_DumpVar in the C API</li></ul><p>
</p><p>
</p><pre>sys_error( SGS_INFO, &quot;Extended variable info:\n&quot; $ dumpvar(data) );</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='dumpvar-function'></a><hr><h2>dumpvar [function]</h2><p></p><p>
</p><h3>dumpvars( ... )</h3><p>
</p><h4>similar to @printvar() but returns the dumps, concatenated, instead of printing them</h4><p>
</p><p>
</p><p></p></div><div class='item'><a name='gc_collect-function'></a><hr><h2>gc_collect [function]</h2><p></p><p>
</p><h3>gc_collect()</h3><p>
</p><h4>runs the garbage collector on the virtual machine, waiting until it has finished</h4><p>
</p><p>
</p><ul><li>returns the reduction in objects or false on failure</li></ul><p>
</p><p>
</p><pre>a = [];
a.push(a); // creates a circular dependency
a = null; // a is not actually freed
gc_collect(); // a is freed now</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='serialize-function'></a><hr><h2>serialize [function]</h2><p></p><p>
</p><h3>serialize( var )</h3><p>
</p><h4>converts the variable to a byte buffer (string), containing the serialized data that can be recreated with @unserialize() or returns null and emits a warning on failure</h4><p>
</p><p>
</p><ul><li>C functions and objects without OP_SERIALIZE implemented cannot be serialized</li></ul><p>
</p><p>
</p><pre>data = serialize({ name = &quot;A&quot;, info = &quot;B&quot; });
print data; // prints random-ish garbage
print unserialize(data); // prints {name=A,info=B}</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='unserialize-function'></a><hr><h2>unserialize [function]</h2><p></p><p>
</p><h3>unserialize( string data )</h3><p>
</p><h4>recreates a variable from the buffer with serialized data or returns null and emits a warning on failure</h4><p>
</p><p>
</p><ul><li>this function will internally call global object creation functions specified in the data, so they must be defined and the state could change in the process
</li><li>for more info on serialization in SGScript, refer to @Serialization (TODO: what could this possibly lead to?)</li></ul><p>
</p><p>
</p><pre>@serialize example</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='SGS_[INFO|WARNING|ERROR]-constants'></a><hr><h2>SGS_[INFO|WARNING|ERROR] [constants]</h2><p></p><p>
</p><h3>SGS_INFO, SGS_WARNING, SGS_ERROR are defined to the values of the C macros, respectively 100, 200 and 300</h3><p>
</p><p>
</p><p></p></div><div class='item'><a name='VT_[NULL|BOOL|INT|REAL|STRING|FUNC|CFUNC|OBJECT]-constants'></a><hr><h2>VT_[NULL|BOOL|INT|REAL|STRING|FUNC|CFUNC|OBJECT] [constants]</h2><p></p><p>
</p><h3>these constants are defined to the values of the C macros (with the prefix &quot;SVT_&quot; in C) and can be compared with the values returned in @typeid() or @typeflags()</h3><p>
</p><p>
</p><p></p></div><div class='item'><a name='_G-superglobal'></a><hr><h2>_G [superglobal]</h2><p></p><p>
</p><h3>A hard-coded global value that points to the global dictionary. Can be used to access non-identifier globals and change the gloal dictionary.</h3><p>
</p><p>
</p><pre>_G[&quot;$diff&quot;] = 5; // no way to access this via usual globals
_G = {}; // global value dictionary is changed, previous functions are lost unless stored somewhere</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='array-object'></a><hr><h2>array [object]</h2><p></p><p>
</p><ul><li>read-only properties
<ul><li>[int] size
</li><li>[int] capacity
</li><li>[var] first (valid if array is not empty, otherwise a warning is thrown and &#39;null&#39; is returned)
</li><li>[var] last (same as &#39;first&#39;)
</li><li>[cfunc] push
</li><li>[cfunc] pop
</li><li>[cfunc] shift
</li><li>[cfunc] unshift
</li><li>[cfunc] insert
</li><li>[cfunc] erase
</li><li>[cfunc] clear
</li><li>[cfunc] reverse
</li><li>[cfunc] resize
</li><li>[cfunc] reserve
</li><li>[cfunc] sort
</li><li>[cfunc] sort_custom
</li><li>[cfunc] sort_mapped
</li><li>[cfunc] find
</li><li>[cfunc] remove
</li></ul><li>other features:
<ul><li>read/write integer index
</li><li>full content dump
</li><li>tostring = quick content dump
</li><li>tobool = size != 0
</li><li>iterator
</li><li>cloning
</li><li>serialization
</li><li>GC-safe
</li><li>type identification (returns the string &quot;array&quot;)</li></ul></li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='array.push-method'></a><hr><h2>array.push [method]</h2><p></p><p>
</p><h3>array.push( ... )</h3><p>
</p><h4>appends the variables passed to the end of array in the same order, returns the array for chaining</h4><p>
</p><p>
</p><pre>a = [ 5 ];
a.push( 6, 7 ).push( 8 ); // a = [5,6,7,8]</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='array.pop-method'></a><hr><h2>array.pop [method]</h2><p></p><p>
</p><h3>array.pop()</h3><p>
</p><h4>removes one item from the end of array or emits a warning if there are no items in the array, returns the removed item</h4><p>
</p><p>
</p><pre>a = [ 5 ];
a.pop(); // array is empty now
a.pop(); // warning: &quot;array is empty, cannot pop&quot;</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='array.shift-method'></a><hr><h2>array.shift [method]</h2><p></p><p>
</p><h3>array.shift()</h3><p>
</p><h4>removes one item from the beginning of array or emits a warning if there are no items in the array, returns the removed item</h4><p>
</p><p>
</p><pre>a = [ 5, 6 ];
a.shift(); // a = [6], returned 5</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='array.unshift-method'></a><hr><h2>array.unshift [method]</h2><p></p><p>
</p><h3>array.unshift( ... )</h3><p>
</p><h4>prepends the variables passed to the beginning of array in the same order, returns the array for chaining</h4><p>
</p><p>
</p><pre>a = [ 5 ];
a.unshift( 6, 7 ); // a = [6,7,5] now</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='array.insert-method'></a><hr><h2>array.insert [method]</h2><p></p><p>
</p><h3>array.insert( int pos, ... )</h3><p>
</p><h4>inserts the variables passed (all arguments after first) to the position specified in the array or emits a warning on failure (index out of bounds), returns the array for chaining</h4><p>
</p><p>
</p><ul><li><code>pos</code> accepts both positive and negative values, the meaning is &quot;which value to insert before&quot;
<ul><li>negative values are converted to positive ones by adding (&lt;size&gt; + 1) to them
</li><li>beginning of array can be inserted to using position 0 or (- &lt;size&gt; - 1)
</li><li>end of array can be inserted to using position &lt;size&gt; or -1</li></ul></li></ul><p>
</p><p>
</p><pre>a = [ 5, 7 ];
a.insert( 1, 6 ); // inserts 6 at position 1 (before item with index 1)
a.insert( -1, 8 ); // appends to the end of array, a = [5,6,7,8] now</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='array.erase-method'></a><hr><h2>array.erase [method]</h2><p></p><p>
</p><h3>array.erase( int[, int] )</h3><p>
</p><h4>erases item or a range of items from the array, depending on the arguments passed or emits a warning on failure, returns the array for chaining</h4><p>
</p><p>
</p><ul><li>both arguments have same index processing rules as @array.insert(), but with one difference - if both arguments are passed, after resolving (converting negative indices to positive ones, if there are any), first must be smaller than second</li></ul><p>
</p><p>
</p><pre>a = [ 5, 6, 7, 8 ];
a.erase( 1, 2 ); // erases all items between position 1 and 2, including; gives a = [5,8]
a.erase( 0 ); // a = [8]</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='array.clear-method'></a><hr><h2>array.clear [method]</h2><p></p><p>
</p><h3>array.clear()</h3><p>
</p><h4>erases all items from the array, returns the array for chaining</h4><p>
</p><p>
</p><pre>a = [ 1, &quot;asd&quot;, 8 ];
a.clear(); // a = []</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='array.reverse-method'></a><hr><h2>array.reverse [method]</h2><p></p><p>
</p><h3>array.reverse()</h3><p>
</p><h4>reverses the order of items in the original array, returns the original array for chaining</h4><p>
</p><p>
</p><pre>a = [ 1, 2, 3 ];
b = a;
a.reverse(); // a = [3,2,1]
print( b ); // prints [3,2,1]</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='array.resize-method'></a><hr><h2>array.resize [method]</h2><p></p><p>
</p><h3>array.resize( int size )</h3><p>
</p><h4>changes the size of the array, returns the array for chaining</h4><p>
</p><p>
</p><ul><li><code>size</code> must be larger than or equal to 0
</li><li>if previous size was less than passed to the method, null variables are appended
</li><li>if previous size was more than passed to the method, items are popped from the end of the array
</li><li>if size was not changed, nothing else will change</li></ul><p>
</p><p>
</p><pre>a = [ 5, 6, 7 ];
a.resize( 5 ); // a = [5,6,7,null,null]
a.resize( 2 ); // a = [5,6]</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='array.reserve-method'></a><hr><h2>array.reserve [method]</h2><p></p><p>
</p><h3>array.reserve( int capacity )</h3><p>
</p><h4>reserves the space for the requested number of elements in the array, returns the array for chaining</h4><p>
</p><p>
</p><ul><li><code>capacity</code> must be larger than or equal to 0
</li><li>if previous capacity was less than passed to the method, capacity will be increased to the requested amount
</li><li>if previous capacity was more than or equal to what was passed to the method, nothing will change</li></ul><p>
</p><p>
</p><pre>a = [ 5, 6, 7 ];
a.capacity( 1 ); // nothing happens
a.capacity( 5 ); // a.capacity = 5 and two variable additions can now happen without reallocations</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='array.sort-method'></a><hr><h2>array.sort [method]</h2><p></p><p>
</p><h3>array.sort([ bool reverse ])</h3><p>
</p><h4>sorts the array using the @sgs_Compare C API function for comparisons, returns the array for chaining</h4><p>
</p><p>
</p><ul><li>if <code>reverse</code> is true, array is sorted in the reverse order</li></ul><p>
</p><p>
</p><pre>a = [ 6, 8, 7, 5 ];
a.sort(); // a = [5,6,7,8]</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='array.sort_custom-method'></a><hr><h2>array.sort_custom [method]</h2><p></p><p>
</p><h3>array.sort_custom( callable[, bool reverse ] )</h3><p>
</p><h4>sorts the array using the callable for comparisons, returns the array for chaining</h4><p>
</p><p>
<em class='notice-bgr'>This function is considerably slower than @array.sort or @array.sort_mapped so prefer those if performance matters.</em>
</p><p>
</p><ul><li>callable must return an integer, specifying the relative order of the two passed arguments: less than 0 if first variable should be placed before second, greater than 0 if first variable should be placed after second, or 0 if it doesn&#39;t matter (TODO: unsafe with big integers/FP return values! something must be done)
</li><li>if <code>reverse</code> is true, array is sorted in the reverse order</li></ul><p>
</p><p>
</p><pre>a = [ 6, 8, 7, 5 ];
// this code will sort numbers into odd/even ones and in ascending order
a.sort_custom( function(a,b){return a-b+(b%2-a%2)*1000; } ); // a = [5,7,6,8]</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='array.sort_mapped-method'></a><hr><h2>array.sort_mapped [method]</h2><p></p><p>
</p><h3>array.sort_mapped( array map[, bool reverse ] );</h3><p>
</p><h4>sorts the array by sorting the passed array and applying the index map to the first one, returns the array for chaining</h4><p>
</p><p>
</p><ul><li>both arrays must have the same size, otherwise a warning is emitted
</li><li>all variables in the mapping array are interpreted as &#39;real&#39; values
</li><li>if <code>reverse</code> is true, array is sorted in the reverse order</li></ul><p>
</p><p>
</p><pre>a = [ 5, 6, 7, 8 ];
b = [ 3, 1, 4, 2 ];
a.sort_mapped( b ); // a = [6,8,5,7]</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='array.find-method'></a><hr><h2>array.find [method]</h2><p></p><p>
</p><h3>array.find( var item[, bool strict[, int from ]] )</h3><p>
</p><h4>attempts to find <code>item</code> in array, starting from 0 or the index passed with <code>from</code>, if it exists, using basic or strict equality comparisons (depending on <code>strict</code>), returning the index or &#39;null&#39; if item was not found</h4><p>
</p><p>
</p><ul><li>if strict comparisons are enabled, variable types are also checked for equality</li></ul><p>
</p><p>
</p><pre>a = [ 5, 6, 7, 8 ];
a.find( &quot;7&quot; ); // returns 2
a.find( &quot;7&quot;, true ); // returns null</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='array.remove-method'></a><hr><h2>array.remove [method]</h2><p></p><p>
</p><h3>array.remove( var item[, bool strict[, bool all[, int from ]]] )</h3><p>
</p><h4>attepts to find and remove first or all <code>item</code> variables in array (depending on <code>all</code>), according to the rules specified in @array.find(), returning the number of removed items</h4><p>
</p><p>
</p><pre>a = [ 5, 2, 6, 7, 8, 2 ];
a.remove( &quot;7&quot; ); // returns 1; a = [5,2,6,8,2]
a.remove( &quot;6&quot;, true ); // returns 0; a remains unchanged
a.remove( 2, false, true ); // returns 2; a = [5,6,8]</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='dict-object'></a><hr><h2>dict [object]</h2><p></p><p>
</p><ul><li>features:
<ul><li>read/write string index
</li><li>read/write string properties and integer index-via-property
</li><li>full content dump
</li><li>tostring = quick content dump
</li><li>tobool = size != 0
</li><li>iterator
</li><li>cloning
</li><li>serialization
</li><li>GC-safe
</li><li>type identification (returns the string &quot;dict&quot;)</li></ul></li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='class-object'></a><hr><h2>class [object]</h2><p></p><p>
</p><ul><li>read/write properties
<ul><li>[var] _super
</li></ul><li>other features
<ul><li>read/write pass-through index
</li><li>read/write pass-through properties (except string &quot;_super&quot;)
</li><li>full content dump
</li><li>tobool = ENOTSUP, overridable via &quot;__tobool&quot;
</li><li>toint = ENOTSUP, overridable via &quot;__toint&quot;
</li><li>toreal = ENOTSUP, overridable via &quot;__toreal&quot;
</li><li>tostring = &quot;class&quot;, overridable via &quot;__tostring&quot;
</li><li>cloning, overridable via &quot;__clone&quot;
</li><li>type identification (returns the string &quot;class&quot;, overridable via &quot;__typeof&quot;)
</li><li>overridable arithmetic/comparison operations
</li><li>overridable object call
</li><li>serialization
</li><li>GC-safe</li></ul></li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='closure-object'></a><hr><h2>closure [object]</h2><p></p><p>
</p><ul><li>features
<ul><li>full content dump
</li><li>tostring = &quot;closure&quot;
</li><li>type identification (returns the string &quot;closure&quot;)
</li><li>object call to callable, using the attached first argument
</li><li>GC-safe</li></ul></li></ul><p>
</p><p>
</p><p>
</p><p>
</p><p></p></div><div class='item'><a name='fmt_pack-function'></a><hr><h2>fmt_pack [function]</h2><p></p><p>
</p><h3>fmt_pack( string fmt, ... )</h3><p>
</p><h4>packs the given arguments using the format <code>fmt</code> and returns the byte buffer or returns null and emits a warning on failure</h4><p>
</p><p>
</p><ul><li>the format: character command list
<ul><li>0-9: add a digit to multiplier
</li><li>=/&lt;/&gt;/<a href=": "=" sets host byte order, "">&quot; - little endian byte order, &quot;</a>&quot; - big endian, &quot;@&quot; - inverted
</li><li>+/-: &quot;+&quot; - unsigned integers, &quot;-&quot; - signed integers
</li><li>c/w/l/q/p: integers (c - char, 1 byte, w - word, 2 bytes, l - long, 4 bytes, q - quad-word, 8 bytes, p - pointer/size, platform-specific size of 4/8 bytes, usually)
</li><li>f/d: floating-point numbers: &quot;f&quot; - single precision, &quot;d&quot; - double precision
</li><li>s: string, multiplier sets length instead of count, as with other items
</li><li>x: padding byte (does not get read or written, can be used to advance the pointer)
</li><li>space/tab/CR/LF: invisible to the parser
</li><li>everything else resets multiplier, does nothing
</li></ul><li>sign modifiers do nothing in fmt_pack, refer to @fmt_unpack() for their usage info</li></ul><p>
</p><p>
</p><pre>printvar( fmt_pack( &quot;3cf&quot;, 0, 1, 2, 3 ) ); // prints &#39;string [7] &quot;\x00\x01\x02\x00\x00@@&quot;&#39;</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='fmt_unpack-function'></a><hr><h2>fmt_unpack [function]</h2><p></p><p>
</p><h3>fmt_unpack( string fmt, string data )</h3><p>
</p><h4>unpacks the byte buffer <code>data</code> using the format <code>fmt</code>, returns array of unpacked items</h4><p>
</p><p>
</p><ul><li>unpacks c/w/l/q/p to integers, f/d to floats, s to strings
</li><li>if signed numbers are expected (as set by the &quot;-&quot; modifier), the sign bit of the expected type is extended to the end of the native integer type, this makes the loaded integer signed
</li><li>refer to @fmt_pack() for more info about the format</li></ul><p>
</p><p>
</p><pre>print fmt_unpack( &quot;3ld&quot;, fmt_pack( &quot;3ld&quot;, 0, 1, 2, 3 ) ); // prints [0,1,2,3]</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='fmt_pack_count-function'></a><hr><h2>fmt_pack_count [function]</h2><p></p><p>
</p><h3>fmt_pack_count( string fmt )</h3><p>
</p><h4>calculates the number of items to be expected in an unpacked array / required to make a successful fmt_pack call</h4><p>
</p><p>
</p><ul><li>refer to @fmt_pack() for more info about the format</li></ul><p>
</p><p>
</p><pre>print fmt_pack_count( &quot;3ld&quot; ); // prints 4</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='fmt_pack_size-function'></a><hr><h2>fmt_pack_size [function]</h2><p></p><p>
</p><h3>fmt_pack_size( string fmt )</h3><p>
</p><h4>calculates the number of bytes generated by a successful fmt_pack call / required to successfully unpack data using the given format</h4><p>
</p><p>
</p><ul><li>refer to @fmt_pack() for more info about the format</li></ul><p>
</p><p>
</p><pre>print fmt_pack_size( &quot;3ld&quot; ); // prints 20</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='fmt_base64_encode-function'></a><hr><h2>fmt_base64_encode [function]</h2><p></p><p>
</p><h3>fmt_base64_encode( string data )</h3><p>
</p><h4>encodes data to produce base64 text data</h4><p>
</p><p>
</p><ul><li>encoding is done using the following table (shortened): &quot;A-Za-z0-9+/&quot;</li></ul><p>
</p><p>
</p><pre>print fmt_base64_encode( &quot;hello world&quot; ); // prints &quot;aGVsbG8gd29ybGQ=&quot;</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='fmt_base64_decode-function'></a><hr><h2>fmt_base64_decode [function]</h2><p></p><p>
</p><h3>fmt_base64_decode( string b64text )</h3><p>
</p><h4>decodes base64 text data</h4><p>
</p><p>
</p><ul><li>decoding is done using the table mentioned in @fmt_base64_encode()</li></ul><p>
</p><p>
</p><pre>fmt_base64_decode( fmt_base64_encode( &quot;hello world&quot; ) ) == &quot;hello world&quot; // returns true</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='fmt_text-function'></a><hr><h2>fmt_text [function]</h2><p></p><p>
</p><h3>fmt_text( string text, ... )</h3><p>
</p><h4>parses all format specifiers in <code>text</code> and returns the result</h4><p>
</p><p>
</p><ul><li>the general format of a format specifier is as follows: {fmt[size][.prec][r][p&lt;char&gt;]}
<ul><li>fmt: one-character output type (b-binary, o-octal, d-decimal, x/X-hexadecimal, f-floating-point, g/G-compact floating-point, e/E-scientific floating-point, s-valid string, c-always converted to string)
</li><li>size: minimum number of characters to print
</li><li>prec: precision of floating-point variables, string length limit
</li><li>r: add &quot;r&quot; to right-pad (left-justify)
</li><li>p&lt;char&gt;: add &quot;p&quot; and any character to set that character as the padding character (default: space/0x20)
</li></ul><li>if anything unexpected happens, this function will emit a warning and put &quot;#error#&quot; in the place of a format specifier</li></ul><p>
</p><p>
</p><pre>print fmt_text( &quot;{d} -&gt; {x}&quot;, 1337, 1337 ); // prints &quot;1337 -&gt; 539&quot;
print fmt_text( &quot;null: {d}, {s}, {c}&quot;, null, null, null ); // prints &quot;null: #error#, #error#, null&quot; and emits two warnings for item 1 and item 2
print fmt_text( &quot;pi: {f10.10r} {g10r} {E10r}&quot;, M_PI, M_PI, M_PI ); // &quot;pi: 3.1415926536 3.14159    3.141593E+000&quot;
TODO: more useful examples!</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='fmt_parser-function'></a><hr><h2>fmt_parser [function]</h2><p></p><p>
</p><h3>fmt_parser( callable[, buffersize ] )</h3><p>
</p><h4>creates a @fmt_parser object, connected to the callable</h4><p>
</p><p>
</p><ul><li>the callable is a function that returns at most the number of bytes requested from the stream
<ul><li>if previous request reached end, subsequent requests must return &#39;null&#39;</li></ul></li></ul><p>
</p><p>
</p><pre>f = io_file( &quot;test.txt&quot;, FILE_READ ); // TODO: this is too complex for basic features, add fmt_file_parser
p = fmt_parser( closure( function(file,num){ if( file.eof() ) return null; return file.read( num ); }, f ) );</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='fmt_string_parser-function'></a><hr><h2>fmt_string_parser [function]</h2><p></p><p>
</p><h3>fmt_string_parser( string, offset = 0 ) TODO: what about buffer size?</h3><p>
</p><h4>creates a @fmt_parser object, connected to a string reader, initialized to the given offset</h4><p>
</p><p>
</p><pre>p = fmt_string_parser( &quot;this is a test&quot; );
p.readcc( &quot;a-z&quot; ); // returns &quot;this&quot;</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='fmt_charcc-function'></a><hr><h2>fmt_charcc [function]</h2><p></p><p>
</p><h3>fmt_charcc( string char, string class )</h3><p>
</p><h4>checks if the first character of string <code>char</code> is included in the character class <code>class</code></h4><p>
</p><p>
</p><ul><li>character class is a regex-like list of specific symbols and ranges (its low and high symbols separated by &quot;-&quot;), optionally prepended by &quot;^&quot; that inverts the scope of the class</li></ul><p>
</p><p>
</p><pre>fmt_charcc( &quot;.&quot;, &quot;a-zA-Z0-9&quot; ); // returns false
fmt_charcc( &quot;x&quot;, &quot;a-zA-Z0-9&quot; ); // returns true</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='fmt_parser-object'></a><hr><h2>fmt_parser [object]</h2><p></p><p>
* read-only properties
 - [bool] at_end
 - [bool] stream_offset
 - [cfunc] read
 - [cfunc] getchar
 - [cfunc] readcc
 - [cfunc] skipcc
* other features:
 - GC-safe
(TODO: do we need a more feature-complete object?)
</p><p>
</p><p></p></div><div class='item'><a name='fmt_parser.read-method'></a><hr><h2>fmt_parser.read [method]</h2><p></p><p>
</p><h3>fmt_parser.read( int num )</h3><p>
</p><h4>reads at most <code>num</code> bytes from stream and returns them as string</h4><p>
</p><p>
</p><ul><li>if 0 bytes are returned, it&#39;s quite safe to assume that the function has reached the end of file but check the at_end property to be sure
</li><li>may return null and emit a warning on unexpected read errors</li></ul><p>
</p><p>
</p><pre>stream = fmt_string_parser( &quot;action&quot; );
stream.read( 5 ); // returns &quot;actio&quot;</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='fmt_parser.getchar-method'></a><hr><h2>fmt_parser.getchar [method]</h2><p></p><p>
</p><h3>fmt_parser.getchar( bool peek = false, bool as_int = false )</h3><p>
</p><h4>returns a character from stream</h4><p>
</p><p>
</p><ul><li>if <code>peek</code> is true, stream is not advanced (next read operation will also work on the same character)
</li><li>if <code>as_int</code> is true, character is returned as integer (as one-character string otherwise)
</li><li>may return null and emit a warning on unexpected read errors</li></ul><p>
</p><p>
</p><pre>stream = fmt_string_parser( &quot;action&quot; );
stream.read( true ); // returns &quot;a&quot;
stream.read( true, true ); // returns 97
stream.read(); // returns &quot;a&quot;
stream.read(); // returns &quot;c&quot;</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='fmt_parser.readcc-method'></a><hr><h2>fmt_parser.readcc [method]</h2><p></p><p>
</p><h3>fmt_parser.readcc( string class, int num = 2^31-1 (0x7fffffff) )</h3><p>
</p><h4>reads and returns at most <code>num</code> bytes that match the character class <code>class</code></h4><p>
</p><p>
</p><ul><li>returns null and emits a warning if the class is empty/only contains the inversion symbol &quot;^&quot; (TODO: is this necessary?)
</li><li>may return null and emit a warning on unexpected read errors</li></ul><p>
</p><p>
</p><pre>stream = fmt_string_parser( &quot;what is this&quot; );
stream.readcc( &quot;a-z&quot; ); // returns &quot;what&quot;
stream.readcc( &quot;^a-z&quot; ); // returns &quot; &quot;</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='fmt_parser.skipcc-method'></a><hr><h2>fmt_parser.skipcc [method]</h2><p></p><p>
</p><h3>fmt_parser.skipcc( string class, int num = 2^31-1 (0x7fffffff) )</h3><p>
</p><h4>skips at most <code>num</code> bytes that match the character class <code>class</code> and returns the number of bytes skipped</h4><p>
</p><p>
</p><ul><li>returns null and emits a warning if the class is empty/only contains the inversion symbol &quot;^&quot; (TODO: is this necessary?)
</li><li>may return null and emit a warning on unexpected read errors</li></ul><p>
</p><p>
</p><pre>stream = fmt_string_parser( &quot;what is this&quot; );
stream.skipcc( &quot;a-z&quot; ); // returns 4
stream.skipcc( &quot;^a-z&quot; ); // returns 1</pre><p>
</p><p>
</p><p>
</p><p>
</p><p></p></div><div class='item'><a name='io_setcwd-function'></a><hr><h2>io_setcwd [function]</h2><p></p><p>
</p><h3>io_setcwd( string cwd )</h3><p>
</p><h4>sets the current working directory, returns bool/sets errno</h4><p>
</p><p>
</p><ul><li>wraps the C library function chdir</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='io_getcwd-function'></a><hr><h2>io_getcwd [function]</h2><p></p><p>
</p><h3>io_getcwd()</h3><p>
</p><h4>returns the current working directory or null, if for some reason an error occured (TODO: getcwd(NULL,0) is UB, how wide is support for expected behavior?)</h4><p>
</p><p>
</p><ul><li>wraps the C library function getcwd/_getcwd</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='io_rename-function'></a><hr><h2>io_rename [function]</h2><p></p><p>
</p><h3>io_rename( string path, string newname )</h3><p>
</p><h4>attempts to rename the file, returns bool/sets errno</h4><p>
</p><p>
</p><ul><li>wraps the C library function rename, with one important difference - moving the file is not allowed, regardless of platform support (TODO: is the restriction safe and necessary?)</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='io_file_exists-function'></a><hr><h2>io_file_exists [function]</h2><p></p><p>
</p><h3>io_file_exists( string file )</h3><p>
</p><h4>checks if file exists and is accessible by the process at the moment, returns true on success, false otherwise</h4><p>
</p><p>
</p><ul><li>uses the C library functions fopen/fclose</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='io_dir_exists-function'></a><hr><h2>io_dir_exists [function]</h2><p></p><p>
</p><h3>io_dir_exists( string dir )</h3><p>
</p><h4>checks if directory exists and is accessible by the process at the moment, returns true on success, false otherwise</h4><p>
</p><p>
</p><ul><li>uses the C library functions opendir,closedir where supported, _findfirst,_findclose otherwise (Windows/MSVC)</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='io_stat-function'></a><hr><h2>io_stat [function]</h2><p></p><p>
</p><h3>io_stat( string fsitem )</h3><p>
</p><h4>returns info about the file system item <code>fsitem</code>, as dict</h4><p>
</p><p>
</p><ul><li>the returned object contains the following properties:
<ul><li>atime: last access time
</li><li>ctime: creation time
</li><li>mtime: last modification time
</li><li>type: enum (one of FST_DIR/FST_FILE/FST_UNKNOWN) TODO: do we need more?
</li><li>size: size of item
</li></ul><li>uses the C library function stat/_stat</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='io_dir_create-function'></a><hr><h2>io_dir_create [function]</h2><p></p><p>
</p><h3>io_dir_create( string path, int mode = 0o777 )</h3><p>
</p><h4>attempts to create a directory at the specified path, with the specified access mode <code>mode</code>, returns bool/sets errno</h4><p>
</p><p>
</p><ul><li><code>mode</code> is ignored on Windows
</li><li>uses the C library function mkdir/_mkdir</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='io_dir_delete-function'></a><hr><h2>io_dir_delete [function]</h2><p></p><p>
</p><h3>io_dir_delete( string path )</h3><p>
</p><h4>attempts to delete a directory at the specified path, returns bool/sets errno</h4><p>
</p><p>
</p><ul><li>uses the C library function rmdir/_rmdir</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='io_file_delete-function'></a><hr><h2>io_file_delete [function]</h2><p></p><p>
</p><h3>io_file_delete( string path )</h3><p>
</p><h4>attempts to delete a file at the specified path, returns bool/sets errno</h4><p>
</p><p>
</p><ul><li>uses the C library function remove</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='io_file_write-function'></a><hr><h2>io_file_write [function]</h2><p></p><p>
</p><h3>io_file_write( string path, string data )</h3><p>
</p><h4>writes the byte buffer <code>data</code> to the file pointed to by <code>path</code>, returns bool/sets errno</h4><p>
</p><p>
</p><p></p></div><div class='item'><a name='io_file_read-function'></a><hr><h2>io_file_read [function]</h2><p></p><p>
</p><h3>io_file_read( string path )</h3><p>
</p><h4>reads the byte buffer from file at <code>path</code>, returns buffer as string or null/sets errno</h4><p>
</p><p>
</p><p></p></div><div class='item'><a name='io_file-object'></a><hr><h2>io_file [object]</h2><p></p><p>
</p><ul><li>read-only properties
<ul><li>[int] offset
</li><li>[int] size
</li><li>[bool] error
</li><li>[bool] eof
</li><li>[cfunc] open
</li><li>[cfunc] close
</li><li>[cfunc] read
</li><li>[cfunc] write
</li><li>[cfunc] seek
</li><li>[cfunc] flush
</li><li>[cfunc] setbuf
</li></ul><li>other features:
<ul><li>tostring = &quot;file&quot;
</li><li>tobool = returns whether file is open or not
</li><li>GC-safe
</li><li>type identification (returns the string &quot;file&quot;)</li></ul></li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='io_file.open-method'></a><hr><h2>io_file.open [method]</h2><p></p><p>
</p><h3>io_file.open( string name, int mode )</h3><p>
</p><h4>closes the previously open file if any, opens the file <code>name</code> for operation mode <code>mode</code>, returns bool/sets errno</h4><p>
</p><p>
</p><ul><li><code>mode</code> must be one of FILE_READ, FILE_WRITE or FILE_READ|FILE_WRITE
</li><li>file is always opened in binary mode</li></ul><p>
</p><p>
</p><pre>f = io_file();
f.open( &quot;file&quot; ); // returns true or false, sets errno accordingly</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='io_file.close-method'></a><hr><h2>io_file.close [method]</h2><p></p><p>
</p><h3>io_file.close()</h3><p>
</p><h4>closes the previously open file, if any, returns whether the file was open or not</h4><p>
</p><p>
</p><pre>f = io_file( &quot;file.txt&quot; );
f.close(); // returns true if the file existed
f.close(); // returns false</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='io_file.read-method'></a><hr><h2>io_file.read [method]</h2><p></p><p>
</p><h3>io_file.read( int num )</h3><p>
</p><h4>reads and returns at most <code>num</code> bytes from file, sets errno</h4><p>
</p><p>
</p><p></p></div><div class='item'><a name='io_file.write-method'></a><hr><h2>io_file.write [method]</h2><p></p><p>
</p><h3>io_file.write( string data )</h3><p>
</p><h4>writes the byte buffer <code>data</code> to the file, sets errno</h4><p>
</p><p>
</p><p></p></div><div class='item'><a name='io_file.seek-method'></a><hr><h2>io_file.seek [method]</h2><p></p><p>
</p><h3>io_file.seek( int off, int mode )</h3><p>
</p><h4>sets the offset in file, returns bool/sets errno</h4><p>
</p><p>
</p><ul><li><code>mode</code> must be one of SEEK_SET (sets as-is), SEEK_CUR (sets relative to current), SEEK_END (sets relative to end)</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='io_file.flush-method'></a><hr><h2>io_file.flush [method]</h2><p></p><p>
</p><h3>io_file.flush()</h3><p>
</p><h4>flushes a buffered file, returns bool</h4><p>
</p><p>
</p><p></p></div><div class='item'><a name='io_file.setbuf-method'></a><hr><h2>io_file.setbuf [method]</h2><p></p><p>
</p><h3>io_file.setbuf( int size )</h3><p>
</p><h4>sets the size of file buffer (0 to disable buffering), returns bool</h4><p>
</p><p>
</p><ul><li>buffering allows to avoid committing each write immediately to disk, resulting in a performance gain, however it may introduce issues if application is expected to fail at any moment, resulting in some data not being written in such cases</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='io_file-function'></a><hr><h2>io_file [function]</h2><p></p><p>
</p><h3>io_file([ string name, int mode ])</h3><p>
</p><h4>creates and returns a file, optionally allowing to open it on creation</h4><p>
</p><p>
</p><ul><li>see @io_file.open() for more info on opening the file</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='io_dir-(directory_iterator)-object'></a><hr><h2>io_dir (directory_iterator) [object]</h2><p></p><p>
</p><ul><li>features:
<ul><li>tostring = &quot;directory_iterator&quot;
</li><li>iterator interface (key = whether real item, value = item name)
<ul><li>real items are all except &quot;.&quot; and &quot;..&quot;
</li></ul><li>returns self as iterator
</li><li>GC-safe
</li><li>type identification (returns the string &quot;directory_iterator&quot;)</li></ul></li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='io_dir-function'></a><hr><h2>io_dir [function]</h2><p></p><p>
</p><h3>io_dir( string dir )</h3><p>
</p><h4>creates a directory iterator for the directory <code>dir</code>, sets errno, returns null and emits a warning on failure</h4><p>
</p><p>
</p><p></p></div><div class='item'><a name='FILE_[READ|WRITE]-constants'></a><hr><h2>FILE_[READ|WRITE] [constants]</h2><p></p><p>
</p><h3>mode constants for @io_file.open() / @io_file()</h3><p>
</p><p>
</p><p></p></div><div class='item'><a name='SEEK_[SET|CUR|END]-constants'></a><hr><h2>SEEK_[SET|CUR|END] [constants]</h2><p></p><p>
</p><h3>mode constants for @io_file.seek()</h3><p>
</p><p>
</p><p></p></div><div class='item'><a name='FST_[UNKNOWN|FILE|DIR]-constants'></a><hr><h2>FST_[UNKNOWN|FILE|DIR] [constants]</h2><p></p><p>
</p><h3>file system item type constants for @io_stat()</h3><p>
</p><p>
</p><p>
</p><p>
</p><p></p></div><div class='item'><a name='abs-function'></a><hr><h2>abs [function]</h2><p></p><p>
</p><h3>abs( x )</h3><p>
</p><h4>returns the absolute value of <code>x</code>, as <code>real</code></h4><p>
</p><p>
</p><pre>abs( 2.2 ); // real (2.2)
abs( -3.1 ); // real (3.1)</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='floor-function'></a><hr><h2>floor [function]</h2><p></p><p>
</p><h3>floor( x )</h3><p>
</p><h4>returns the largest integer that is not bigger than <code>x</code>, as <code>real</code></h4><p>
</p><p>
</p><pre>floor( 3.4 ); // real (3)
floor( 3.8 ); // real (3)
floor( 4.2 ); // real (4)
floor( -3.1 ); // real (-4)</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='ceil-function'></a><hr><h2>ceil [function]</h2><p></p><p>
</p><h3>ceil( x )</h3><p>
</p><h4>returns the smallest integer that is not smaller than <code>x</code>, as <code>real</code></h4><p>
</p><p>
</p><pre>ceil( 3.4 ); // real (4)
ceil( 3.8 ); // real (4)
ceil( 4.2 ); // real (5)
ceil( -3.1 ); // real (-3)</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='round-function'></a><hr><h2>round [function]</h2><p></p><p>
</p><h3>round( x )</h3><p>
</p><h4>returns the closest integer to <code>x</code>, as <code>real</code></h4><p>
</p><p>
</p><pre>round( 3.4 ); // real (3)
round( 3.8 ); // real (4)
round( 4.2 ); // real (4)
round( -3.1 ); // real (-3)</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='pow-function'></a><hr><h2>pow [function]</h2><p></p><p>
</p><h3>pow( x, y )</h3><p>
</p><h4>returns <code>x</code> raised to the power <code>y</code>, as <code>real</code></h4><p>
</p><p>
</p><ul><li>If base (<code>x</code>) is negative and exponent (<code>y</code>) is not an integral value, or if base is zero and exponent is negative, function returns <code>null</code> and emits a warning message.</li></ul><p>
</p><p>
</p><pre>pow( 2, 5 ); // real (32)
pow( 9, 0.5 ); // real (3)
pow( -1, 0.5 ); // null; Warning: pow(): mathematical error</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='sqrt-function'></a><hr><h2>sqrt [function]</h2><p></p><p>
</p><h3>sqrt( x )</h3><p>
</p><h4>returns the square root of <code>x</code>, as <code>real</code></h4><p>
</p><p>
</p><ul><li>If <code>x</code> is negative, function returns <code>null</code> and emits a warning message.</li></ul><p>
</p><p>
</p><pre>sqrt( 16 ); // real (4)
sqrt( -1 ); // null; Warning: sqrt(): mathematical error</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='log-function'></a><hr><h2>log [function]</h2><p></p><p>
</p><h3>log( x, y )</h3><p>
</p><h4>returns the base-<code>y</code> logarithm of <code>x</code>, as <code>real</code></h4><p>
</p><p>
</p><ul><li>If <code>x &lt;= 0</code>  or  <code>b &lt;= 0</code>  or  <code>b = 1</code>, function returns <code>null</code> and emits a warning message.</li></ul><p>
</p><p>
</p><pre>log( 9, 3 ); // real (2)
log( -1, 3 ); // .. or ..
log( 3, 0 ); // .. or ..
log( 3, 1 ); // null; Warning: log(): mathematical error</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='sin-function'></a><hr><h2>sin [function]</h2><p></p><p>
</p><h3>sin( x )</h3><p>
</p><h4>returns the sine of angle <code>x</code> in radians, as <code>real</code></h4><p>
</p><p>
</p><pre>sin( 0 ); // real (0)
sin( M_PI / 2 ); // real (1)
sin( M_PI / 4 ); // real (0.707107)</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='cos-function'></a><hr><h2>cos [function]</h2><p></p><p>
</p><h3>cos( x )</h3><p>
</p><h4>returns the cosine of angle <code>x</code> in radians, as <code>real</code></h4><p>
</p><p>
</p><pre>sin( 0 ); // real (1)
sin( M_PI ); // real (-1)
sin( M_PI / 4 ); // real (0.707107)</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='tan-function'></a><hr><h2>tan [function]</h2><p></p><p>
</p><h3>tan( x )</h3><p>
</p><h4>returns the tangent of angle <code>x</code> in radians, as <code>real</code></h4><p>
</p><p>
</p><pre>tan( 0 ); // real (0)
tan( 1 ); // real (1.55741)
tan( M_PI / 4 ); // real (1)</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='asin-function'></a><hr><h2>asin [function]</h2><p></p><p>
</p><h3>asin( x )</h3><p>
</p><h4>returns the arcsine of <code>x</code> (angle in radians), as <code>real</code></h4><p>
</p><p>
</p><ul><li>If <code>x</code> is outside the [-1,1] range, function returns <code>null</code> and emits a warning message</li></ul><p>
</p><p>
</p><pre>asin( -1 ); // real (-1.5708)
asin( 0 ); // real (0)
asin( 2 ); // null; Warning: asin(): mathematical error</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='acos-function'></a><hr><h2>acos [function]</h2><p></p><p>
</p><h3>acos( x )</h3><p>
</p><h4>returns the arccosine of <code>x</code> (angle in radians), as <code>real</code></h4><p>
</p><p>
</p><ul><li>If <code>x</code> is outside the [-1,1] range, function returns <code>null</code> and emits a warning message</li></ul><p>
</p><p>
</p><pre>acos( -1 ); // real (3.14159)
acos( 0 ); // real (1.5708)
acos( 2 ); // null; Warning: acos(): mathematical error</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='atan-function'></a><hr><h2>atan [function]</h2><p></p><p>
</p><h3>atan( x )</h3><p>
</p><h4>returns the arctangent of <code>x</code> (angle in radians), as <code>real</code></h4><p>
</p><p>
</p><pre>atan( 0 ); // real (0)
atan( 1 ); // real (0.785398)
atan( 9999999 ); // real (1.5708)</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='atan2-function'></a><hr><h2>atan2 [function]</h2><p></p><p>
</p><h3>atan2( y, x )</h3><p>
</p><h4>returns the extended arctangent of y/x (angle in radians), as <code>real</code></h4><p>
</p><p>
</p><ul><li>Signs of <code>x</code> and <code>y</code> are used to determine the quadrant, thus <code>y</code> is expected to be the sine of the angle to be returned (the <code>y</code> coordinate of a point) and <code>x</code> - the cosine (the <code>x</code> coordinate).</li></ul><p>
</p><p>
<em class='notice-bgr'>Due to the common requirement to use this function to determine the angle between two somewhat random points (usually from a simulation), it will not emit a warning when both arguments are 0 - it will return 0 instead.</em>
</p><p>
</p><pre>atan2( 0, 1 ); // real (0)
atan2( 1, 0 ); // real (1.5708)
atan2( -1, -1 ); // real (-2.35619)
atan2( 0, 0 ); // real (0)</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='deg2rad-function'></a><hr><h2>deg2rad [function]</h2><p></p><p>
</p><h3>deg2rad( x )</h3><p>
</p><h4>returns angle, converted from degrees to radians, as <code>real</code></h4><p>
</p><p>
</p><pre>deg2rad( 0 ); // real (0)
deg2rad( 180 ); // real (3.14159)
deg2rad( -90 ); // real (-1.5708)</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='rad2deg-function'></a><hr><h2>rad2deg [function]</h2><p></p><p>
</p><h3>rad2deg( x )</h3><p>
</p><h4>returns angle, converted from radians to degrees, as <code>real</code></h4><p>
</p><p>
</p><pre>rad2deg( 0 ); // real (0)
rad2deg( M_PI ); // real (180)
rad2deg( -M_PI / 2 ); // real (-90)</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='M_[PI|E]-constants'></a><hr><h2>M_[PI|E] [constants]</h2><p></p><p>
</p><h3>M_PI</h3><p>
</p><h4>the ratio of circumference of a circle to its diameter (pi)</h4><p>
</p><ul><li>the value of this constant is <code>3.14159265358979323846</code></li></ul><p>
</p><p>
</p><h3>M_E</h3><p>
</p><h4>the natural logarithmic base (e)</h4><p>
</p><ul><li>the value of this constant is <code>2.7182818284590452354</code></li></ul><p>
</p><p>
</p><p>
</p><p>
</p><p></p></div><div class='item'><a name='os_gettype-function'></a><hr><h2>os_gettype [function]</h2><p></p><p>
</p><h3>os_gettype()</h3><p>
</p><h4>returns the name of the closest known match for the operating system type, defined at library compile time</h4><p>
</p><p>
</p><ul><li>the function can detect and return the following OSes at the moment (with the preprocessor define in braces):
<ul><li>&quot;Windows&quot; (_WIN32)
</li><li>&quot;Linux&quot; (__linux)
</li><li>&quot;Unix&quot; (__unix)
</li><li>&quot;POSIX&quot; (__posix)
</li><li>&quot;Unknown&quot; (..any other)</li></ul></li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='os_command-function'></a><hr><h2>os_command [function]</h2><p></p><p>
</p><h3>os_command( string cmd )</h3><p>
</p><h4>passes a command to the OS command processor, returns the integer return value</h4><p>
</p><p>
<em class='notice-bgr'>this function can be extremely unsafe in multithreaded/incontrollable environments due to the completely undefined outcome of the call</em>
</p><p>
</p><ul><li>uses the C library function &#39;system&#39;</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='os_getenv-function'></a><hr><h2>os_getenv [function]</h2><p></p><p>
</p><h3>os_getenv( string var )</h3><p>
</p><h4>returns the value for the environment variable <code>var</code> or null, if there is no such value</h4><p>
</p><p>
</p><p></p></div><div class='item'><a name='os_putenv-function'></a><hr><h2>os_putenv [function]</h2><p></p><p>
</p><h3>os_putenv( string cmd )</h3><p>
</p><h4>sets the value for the environment variable specified in command <code>cmd</code>, returns success as bool</h4><p>
</p><p>
</p><ul><li><code>cmd</code> has the format &quot;&lt;name&gt;=&lt;value&gt;&quot;</li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='os_time-function'></a><hr><h2>os_time [function]</h2><p></p><p>
</p><h3>os_time( real tz = &lt;local&gt; )</h3><p>
</p><h4>returns the time in seconds, as integer, optionally from a different timezone <code>tz</code></h4><p>
</p><p>
</p><p></p></div><div class='item'><a name='os_get_timezone-function'></a><hr><h2>os_get_timezone [function]</h2><p></p><p>
</p><h3>os_get_timezone( bool as_string = false )</h3><p>
</p><h4>returns the timezone set in the operating system, optionally as string in the format &quot;(+/-)HH:MM&quot;</h4><p>
</p><p>
</p><p></p></div><div class='item'><a name='os_date_string-function'></a><hr><h2>os_date_string [function]</h2><p></p><p>
</p><h3>os_date_string( string fmt, int time = os_time() )</h3><p>
</p><h4>returns the date/time string in the format <code>fmt</code>, optionally for a different time <code>time</code></h4><p>
</p><p>
</p><ul><li>the following item specifiers are supported (*-local-specific): (TODO: what about setting the locale?)
<ul><li>%a: abbreviated weekday name *
</li><li>%A: full weekday name *
</li><li>%b: abbreviated month name *
</li><li>%B: full month name *
</li><li>%c: full date/time *
</li><li>%x: full date *
</li><li>%X: full time *
</li><li>%Z: timezone name/abbreviation (could be an empty string) *
</li><li>%U: week number with first Sunday as the first day of week one *
</li><li>%W: week number with first Monday as the first day of week one *
</li><li>%C: year/100, as integer
</li><li>%d: zero-padded day of the month (01-31)
</li><li>%e: space-padded day of the month ( 1-31)
</li><li>%F: date, shortcut of &quot;%Y-%m-%d&quot;
</li><li>%H: hour in 24h format (00-23)
</li><li>%I: hour in 12h format (01-12)
</li><li>%j: day of the year (001-366)
</li><li>%m: month number (01-12)
</li><li>%M: minute (00-59)
</li><li>%p: AM or PM
</li><li>%R: hour/minute time, shortcut to %H:%M
</li><li>%s: second (00-61)
</li><li>%T: time, shortcut to %H:%M:%S
</li><li>%u: weekday with Sunday as 0
</li><li>%w: weekday with Monday as 1
</li><li>%y: 2-digit year (00-99)
</li><li>%Y: year
</li><li>%f: file-safe full time, shortcut to %Y-%m-%d_%H-%M-%S
</li><li>%t: the UNIX timestamp
</li><li>%%: prints &quot;%&quot;
</li><li>%&lt;any other&gt;: prints both characters</li></ul></li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='os_parse_time-function'></a><hr><h2>os_parse_time [function]</h2><p></p><p>
</p><h3>os_parse_time( int time = os_time() )</h3><p>
</p><h4>returns <code>time</code> split into parts, as dict</h4><p>
</p><p>
</p><ul><li>the returned dict contains the following properties (all are integers):
<ul><li>year (1900-????)
</li><li>month (1-12)
</li><li>day (1-31)
</li><li>weekday (1-7)
</li><li>yearday (1-366)
</li><li>hours (0-23)
</li><li>minutes (0-59)
</li><li>seconds (0-61)</li></ul></li></ul><p>
</p><p>
</p><p></p></div><div class='item'><a name='os_make_time-function'></a><hr><h2>os_make_time [function]</h2><p></p><p>
</p><h3>os_make_time( int sec, int min = 0, int hour = 0, int mday = 0, int mon = 0, int year = 0 )</h3><p>
</p><h4>returns time as UNIX timestamp, generated from the arguments, using them as hints (under-/overflows may have some unexpected behavior)</h4><p>
</p><p>
</p><p>
</p><p>
</p><p></p></div><div class='item'><a name='string_cut-function'></a><hr><h2>string_cut [function]</h2><p></p><p>
</p><h3>string_cut( string str, int from[, int to[, int flags]] )</h3><p>
</p><h4>returns a part of string <code>str</code>, <code>from</code> and <code>to</code> being positions of the first and last character returned, respectively</h4><p>
</p><p>
</p><ul><li>if <code>to</code> is not specified, <code>to</code> is assumed to be the position of the last character in string <code>str</code>
</li><li>if <code>from</code> or <code>to</code> are negative, they point to characters before the end of string (-1 being the last one)
</li><li>available values for <code>flags</code>:
<ul><li><code>STRING_NO_REV_INDEX</code> - emit warnings on negative indices, instead of handling them
</li><li><code>STRING_STRICT_RANGES</code> - emit warnings on out of bounds <code>from</code>/<code>to</code> values instead of silently ignoring the outside characters</li></ul></li></ul><p>
</p><p>
</p><pre>string_cut( &quot;01234567&quot;, 3, 5 ); // string [3] &quot;345&quot;</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='string_part-function'></a><hr><h2>string_part [function]</h2><p></p><p>
</p><h3>string_part( string str, int from[, int len[, int flags]] )</h3><p>
</p><h4>returns a part of string <code>str</code>, starting at <code>from</code>, at most <code>len</code> characters</h4><p>
</p><p>
</p><ul><li>if <code>len</code> is not specified, <code>len</code> is assumed to be the number of characters between <code>from</code> and the end of string <code>str</code>
</li><li>if <code>from</code> is negative, it points to characters before the end of string (-1 being the last one)
</li><li>if <code>len</code> is negative, the maximum length of returned string is the sum of <code>len</code> and string <code>str</code> length
</li><li>available values for <code>flags</code>:
<ul><li><code>STRING_NO_REV_INDEX</code> - emit warnings on negative indices, instead of handling them
</li><li><code>STRING_STRICT_RANGES</code> - emit warnings on out of bounds <code>from</code>/<code>len</code> values instead of silently ignoring the outside characters</li></ul></li></ul><p>
</p><p>
</p><pre>string_part( &quot;01234567&quot;, 3, 3 ); // string [3] &quot;345&quot;</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='string_reverse-function'></a><hr><h2>string_reverse [function]</h2><p></p><p>
</p><h3>string_reverse( string str )</h3><p>
</p><h4>returns <code>str</code> with all the bytes in reversed order</h4><p>
</p><p>
<em class='notice-bgr'>This function will not work correctly with multibyte-encoded strings.</em>
</p><p>
</p><pre>string_reverse( &quot;noitca&quot; ); // string [6] &quot;action&quot;</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='string_pad-function'></a><hr><h2>string_pad [function]</h2><p></p><p>
</p><h3>string_pad( string str, int tgtsize, string padstr = &quot; &quot;, int flags = STRING_PAD_RIGHT )</h3><p>
</p><h4>return the string <code>str</code>, padded from template <code>padstr</code> up to the size <code>tgtsize</code> according to <code>flags</code></h4><p>
</p><p>
</p><ul><li>if <code>str</code> is longer than <code>tgtsize</code>, it is returned without changes
</li><li>available values for <code>flags</code>:
<ul><li><code>STRING_PAD_LEFT</code> - pad the string at the left side
</li><li><code>STRING_PAD_RIGHT</code> - pad the string at the right side
</li><li>if both flags are OR&#39;ed together, the string <code>str</code> is centered
</li><li>at least one of the flags must be specified if the argument is passed for the function to work</li></ul></li></ul><p>
</p><p>
</p><pre>string_pad( &quot;padded&quot;, 10 ); // string [10] &quot;padded    &quot;
string_pad( &quot;center&quot;, 10, &quot;_&quot;, STRING_PAD_LEFT | STRING_PAD_RIGHT ); // string [10] &quot;__center__&quot;</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='string_repeat-function'></a><hr><h2>string_repeat [function]</h2><p></p><p>
</p><h3>string_repeat( string str, int count )</h3><p>
</p><h4>return the string <code>str</code>, appended to itself <code>count</code>-1 times or an empty string if <code>count</code> is equal to 0</h4><p>
</p><p>
</p><ul><li><code>count</code> must be greater than or equal to 0</li></ul><p>
</p><p>
</p><pre>string_repeat( &quot;na&quot;, 6 ); // string [12] &quot;nananananana&quot;
string_repeat( &quot;none&quot;, 0 ); // string [0] &quot;&quot;</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='string_count-function'></a><hr><h2>string_count [function]</h2><p></p><p>
</p><h3>string_count( string str, string substr, bool overlap = false )</h3><p>
</p><h4>returns the number of substrings <code>substr</code> found in string <code>str</code></h4><p>
</p><p>
</p><ul><li>if <code>overlap</code> is true, function does not skip substrings when they are found</li></ul><p>
</p><p>
</p><pre>string_count( &quot;abababa&quot;, &quot;aba&quot; ); // int 2
string_count( &quot;abababa&quot;, &quot;aba&quot;, true ); // int 3</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='string_find-function'></a><hr><h2>string_find [function]</h2><p></p><p>
</p><h3>string_find( string str, string substr, int offset = 0 )</h3><p>
</p><h4>returns the position of first found substring <code>substr</code> in string <code>str</code>, starting at <code>offset</code></h4><p>
</p><p>
</p><ul><li>if <code>substr</code> was not found, &#39;null&#39; is returned
</li><li>if <code>offset</code> is less than 0, it specifies offset from the end</li></ul><p>
</p><p>
</p><pre>string_find( &quot;what hat&quot;, &quot;hat&quot; ); // int 1
string_find( &quot;what&quot;, &quot;hat&quot;, 2 ); // null</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='string_find_rev-function'></a><hr><h2>string_find_rev [function]</h2><p></p><p>
</p><h3>string_find_rev( string str, string substr, int offset = 0 )</h3><p>
</p><h4>returns the position of last found substring <code>substr</code> in string <code>str</code>, starting at <code>offset</code></h4><p>
</p><p>
</p><ul><li>if <code>substr</code> was not found, &#39;null&#39; is returned
</li><li>if <code>offset</code> is less than 0, it specifies offset from the end</li></ul><p>
</p><p>
</p><pre>string_find_rev( &quot;what hat&quot;, &quot;hat&quot; ); // int 5
string_find_rev( &quot;what&quot;, &quot;hat&quot;, 2 ); // int 1</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='string_replace-function'></a><hr><h2>string_replace [function]</h2><p></p><p>
</p><h3>string_replace( string str, string from, string to )</h3><p>
</p><h3>string_replace( string str, array from, string to )</h3><p>
</p><h3>string_replace( string str, array from, array to )</h3><p>
</p><h4>replaces parts of string <code>str</code>, specified in <code>from</code>, to the respective values passed in <code>to</code></h4><p>
</p><p>
</p><ul><li>the respective replacement is picked by taking the substring index and performing modulo operation with the number of replacement strings</li></ul><p>
</p><p>
</p><pre>string_replace( &quot;loaded %num files&quot;, &quot;%num&quot;, 5 ); // string [14] &quot;loaded 5 files&quot;
string_replace( &quot;abcd&quot;, [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;], [1,2,3,4] ); // string [4] &quot;1234&quot;
string_replace( &quot;1234&quot;, [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;], [&quot;x&quot;,&quot;y&quot;] ); // string [4] &quot;xyxy&quot;</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='string_translate-function'></a><hr><h2>string_translate [function]</h2><p></p><p>
</p><h3>string_translate( string str, iterable repmap )</h3><p>
</p><h4>replaces parts of string <code>str</code>, specified in the keys of <code>repmap</code>, to the matching values of the same iterable</h4><p>
</p><p>
</p><pre>string_translate( &quot;found %a files and %b folders&quot;, {&quot;%a&quot; = 5, &quot;%b&quot; = 17} ); // string [28] &quot;found 5 files and 17 folders&quot;</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='string_trim-function'></a><hr><h2>string_trim [function]</h2><p></p><p>
</p><h3>string_trim( string str, string chars = &quot; \t\r\n&quot;, int flags = STRING_TRIM_LEFT | STRING_TRIM_RIGHT )</h3><p>
</p><h4>removes the specified characters from the specified sides of the string</h4><p>
</p><p>
</p><ul><li>available values for <code>flags</code>:
<ul><li><code>STRING_TRIM_LEFT</code> - trim the string from the left side
</li><li><code>STRING_TRIM_RIGHT</code> - trim the string from the right side</li></ul></li></ul><p>
</p><p>
</p><pre>string_trim( &quot;  space  &quot; ); // string [5] &quot;space&quot;
string_trim( &quot;..something!..&quot;, &quot;.!&quot;, STRING_TRIM_RIGHT ); // string [11] &quot;..something&quot;</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='string_toupper-function'></a><hr><h2>string_toupper [function]</h2><p></p><p>
</p><h3>string_toupper( string str )</h3><p>
</p><h4>converts all ASCII lowercase letter characters of the string to uppercase</h4><p>
</p><p>
</p><pre>string_toupper( &quot;Test&quot; ); // string [4] &quot;TEST&quot;</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='string_tolower-function'></a><hr><h2>string_tolower [function]</h2><p></p><p>
</p><h3>string_tolower( string str )</h3><p>
</p><h4>converts all ASCII uppercase letter characters of the string to lowercase</h4><p>
</p><p>
</p><pre>string_toupper( &quot;Test&quot; ); // string [4] &quot;test&quot;</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='string_compare-function'></a><hr><h2>string_compare [function]</h2><p></p><p>
</p><h3>string_compare( string str1, string str2, int max = 0, int from = 0 )</h3><p>
</p><h4>compares the two strings or the specified portions of them</h4><p>
</p><p>
</p><pre>string_compare( &quot;what&quot;, &quot;whaT&quot; ); // int 1
string_compare( &quot;what&quot;, &quot;whaT&quot;, 3 ); // int 0
string_compare( &quot;file.txt&quot;, &quot;.txt&quot;, 0, -4 ); // int 0</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='string_implode-function'></a><hr><h2>string_implode [function]</h2><p></p><p>
</p><h3>string_implode( array items, string sep )</h3><p>
</p><h4>concatenates the string representations of array <code>items</code> values, putting a string <code>sep</code> between each two</h4><p>
</p><p>
</p><pre>string_implode( [&quot;one&quot;,&quot;two&quot;,&quot;three&quot;], &quot;, &quot; ); // string [15] &quot;one, two, three&quot;</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='string_explode-function'></a><hr><h2>string_explode [function]</h2><p></p><p>
</p><h3>string_explode( string str, string sep )</h3><p>
</p><h4>splits the string <code>str</code> into an array of substrings, separated by string <code>sep</code></h4><p>
</p><p>
</p><pre>string_explode( &quot;www.example.com&quot;, &quot;.&quot; ); // [&quot;www&quot;,&quot;example&quot;,&quot;com&quot;]
string_explode( &quot;x&quot;, &quot;-&quot; ); // [&quot;x&quot;]
string_explode( &quot;/some//data&quot;, &quot;/&quot; ); // [&quot;&quot;,&quot;some&quot;,&quot;&quot;,&quot;data&quot;]</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='string_charcode-function'></a><hr><h2>string_charcode [function]</h2><p></p><p>
</p><h3>string_charcode( string str, int offset = 0 )</h3><p>
</p><h4>returns the byte value / ASCII character code of the specified byte in the string</h4><p>
</p><p>
</p><pre>string_charcode( &quot;Test&quot; ); // int 84
string_charcode( &quot;Test&quot;, 3 ); // int 116</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='string_frombytes-function'></a><hr><h2>string_frombytes [function]</h2><p></p><p>
</p><h3>string_frombytes( int byteval )</h3><p>
</p><h3>string_frombytes( array bytes )</h3><p>
</p><h4>returns a string, created from either one byte value (overload #1) or an array of byte values (overload #2)</h4><p>
</p><p>
</p><ul><li>byte values must be in the range [0-255]</li></ul><p>
</p><p>
</p><pre>string_frombytes( 53 ); // string [1] &quot;5&quot;
string_frombytes([ 84, 101, 115, 116 ]); // string [4] &quot;Test&quot;</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='string_utf8_decode-function'></a><hr><h2>string_utf8_decode [function]</h2><p></p><p>
</p><h3>string_utf8_decode( string ustr )</h3><p>
</p><h4>returns an array of Unicode code points, decoded from the UTF-8 string <code>ustr</code></h4><p>
</p><p>
</p><ul><li>invalid byte sequences will add 0xFFFD to the array</li></ul><p>
</p><p>
</p><pre>string_utf8_decode( &quot;pie&quot; ); // [112,105,101]
string_utf8_decode( &quot;&quot; ); // [1082,1086,1076]
string_utf8_decode( &quot;&quot; ); // [27161,28310]</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='string_utf8_encode-function'></a><hr><h2>string_utf8_encode [function]</h2><p></p><p>
</p><h3>string_utf8_encode( array cplist )</h3><p>
</p><h4>returns a UTF-8 string, composed from the Unicode code point list <code>cplist</code></h4><p>
</p><p>
<em class='notice-bgr'>Without proper terminal software UTF-8 strings will not be displayed correctly (as is the case on Windows).</em>
</p><p>
</p><ul><li>invalid code points will add &quot;\xEF\xBF\xBD&quot; (0xFFFD code point as UTF-8) to the string</li></ul><p>
</p><p>
</p><pre>string_utf8_encode( [112,105,101] ); // string [3] &quot;pie&quot;
string_utf8_decode( [1082,1086,1076] ); // string [6] &quot;&quot;
string_utf8_decode( [27161,28310] ); // string [6] &quot;&quot;</pre><p>
</p><p>
</p><p></p></div><div class='item'><a name='string_format-function'></a><hr><h2>string_format [function]</h2><p></p><p>
</p><h3>string_format( string text, ... )</h3><p>
</p><h4>parses all format specifiers in <code>text</code> and returns the result</h4><p>
</p><p>
</p><ul><li>the format specifier has the form {&lt;id&gt;:&lt;specifier&gt;} where &quot;id&quot; is the argument index to use and specifier is a @fmt_text specifier
</li><li>argument indices to be used in specifiers start from 1</li></ul><p>
</p><p>
</p><pre>print string_format( &quot;{1:d} -&gt; {1:x}&quot;, 1337 ); // prints &quot;1337 -&gt; 539&quot;</pre><p>
</p><p>
</p><p>
</p><p></p></div></div>
</body></html>
