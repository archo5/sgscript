SGScript documentation - v0.9.0


# SGScript - description [info]

This is a programming language that is made to be fast, accessible and simple. It is similar to many but the exact combination makes it unique in comparison to others. Thus, it might be best to describe it in comparison to others, especially the ones that heavily influenced the development of SGScript.

--------------------------------------------------------------------------------------
!  language  !            what it DOESN'T have in comparison to SGScript             !
|     C      |  dynamic typing, built-in serialization                               |
|    Lua     |  built-in serialization, C-like syntax, proper indexing, arrays, ...  |
|    PHP     |  consistency, lightweight design                                      |
| JavaScript |  environmental awareness, determinism, built-in serialization, ...    |
|   Python   |  C-like syntax, lightweight design                                    |
--------------------------------------------------------------------------------------

With this in mind, technologies get upgraded occasionally, thus be sure to take this comparison with a grain of salt and recheck it and perhaps even report the factual errors along with the version number that marked the introduction of changes.

However, SGScript has all of the things mentioned, and some more, possibly making it one of the most balanced languages ever created.

The language supports:

- `if/else`, `while`, `for`, `do/while`, `foreach`
- 8 variable types: null, bool, int, real, string, function, C function, object
- Multi-level break/continue
- Multiple return values
- First-class functions

The standard library includes:

- array, dict, class, closure
- math, string, I/O, O/S and formatting functions
- `eval`, file import, DLL import


# Language reference [info]
# >>>


# Variable types [info]

SGScript has 8 primary variable types:

- `null`: the 'lack of a better value' type
- `bool`: boolean, true/false
- `int`: signed integer
- `real`: floating point number
- `string`: byte buffer
- `(SGS) function`: function that was defined in and compiled from SGScript code
- `C function`: function defined in C code
- `object`: the extension type and container for complex built-in types

Extended variable types (built on `object`):

- `array`: a dynamically allocated variable array
- `dict`: a map/table structure where variables are mapped to string keys
- `class`: object that uses two other objects to build its interface
- `closure`: a callable object consisting of another callable and one variable


# Code structure [info]

Code can contain constants, identifiers, expressions and statements. Statements usually include expressions but expressions can also include statements, specifically - function expressions.


# >>>


# Constants [info]

Available constant formats:

--------------------------------------------------
!     type     !   subtype    !     examples     !
|  null        |      -       |      null        |
|  bool        |      -       |    true, false   |
|  int         |   decimal    |  1413, -583, 0   |
|  int         |    binary    |   0b0101, 0b11   |
|  int         |    octal     | 0o644, 0o1, 0o77 |
|  int         |  hexadecimal |   0x1f, 0xCA5    |
|  real        |    basic     |   0.14, -25.48   |
|  real        |  scientific  |  1.5e-5, 1e+10   |
|  string      |      -       |  "text", '1\n2'  |
--------------------------------------------------


# Identifiers [info]

Identifiers can contain letters (a-z, A-Z), numbers (0-9) or underscores ("_") but they cannot begin with a number.

Special keywords and hardcoded constants:

------------------------------------------------------------------------------------
!    name    !              type                !              usage               !
|  this      |  special identifier, read-only   |  method context retrieval        |
|  _G        |  special identifier, read/write  |  global environment access       |
|  null      |             constant             |  constant                        |
|  true      |             constant             |  constant                        |
|  false     |             constant             |  constant                        |
|  var       |       restricted keyword         |  variable declaration            |
|  global    |       restricted keyword         |  variable declaration            |
|  function  |       restricted keyword         |  function definition             |
|  if        |       restricted keyword         |  "if" statement                  |
|  else      |       restricted keyword         |  "if/else" statement             |
|  do        |       restricted keyword         |  "do/while" statement            |
|  while     |       restricted keyword         |  "while", "do/while" statements  |
|  for       |       restricted keyword         |  "for" statement                 |
|  foreach   |       restricted keyword         |  "foreach" statement             |
|  break     |       restricted keyword         |  "break" statement               |
|  continue  |       restricted keyword         |  "continue" statement            |
|  return    |       restricted keyword         |  "return" statement              |
------------------------------------------------------------------------------------


# Expressions [info]

Expressions can be categorized in many different ways: type of action, appearance, whether it also assigns the value somewhere or if its purpose has a special meaning.

There are 5 types of action for expressions in SGScript: arithmetic, binary, boolean, comparison and special.

------------------------------------------------------------------------------
!     expression          !   appearance   ! type of action ! assign ! # in. !
|  add                    |`   A  +  B    `|   arithmetic   |  no    |   2   |
|  subtract               |`   A  -  B    `|   arithmetic   |  no    |   2   |
|  multiply               |`   A  *  B    `|   arithmetic   |  no    |   2   |
|  divide                 |`   A  /  B    `|   arithmetic   |  no    |   2   |
|  modulo                 |`   A  %  B    `|   arithmetic   |  no    |   2   |
|  pre-increment          |`     ++ A     `|   arithmetic   |  self  |   1   |
|  pre-decrement          |`     -- A     `|   arithmetic   |  self  |   1   |
|  post-increment         |`     A ++     `|   arithmetic   |  self  |   1   |
|  post-decrement         |`     A --     `|   arithmetic   |  self  |   1   |
|  add-assign             |`   A  +=  B   `|   arithmetic   |  yes   |   2   |
|  subtract-assign        |`   A  -=  B   `|   arithmetic   |  yes   |   2   |
|  multiply-assign        |`   A  *=  B   `|   arithmetic   |  yes   |   2   |
|  divide-assign          |`   A  /=  B   `|   arithmetic   |  yes   |   2   |
|  modulo-assign          |`   A  %=  B   `|   arithmetic   |  yes   |   2   |
|  binary AND             |`   A  &  B    `|     binary     |  no    |   2   |
|  binary OR              |`   A  |  B    `|     binary     |  no    |   2   |
|  binary XOR             |`   A  ^  B    `|     binary     |  no    |   2   |
|  left shift             |`   A  <<  B   `|     binary     |  no    |   2   |
|  right shift            |`   A  >>  B   `|     binary     |  no    |   2   |
|  binary AND-assign      |`   A  &=  B   `|     binary     |  yes   |   2   |
|  binary OR-assign       |`   A  |=  B   `|     binary     |  yes   |   2   |
|  binary XOR-assign      |`   A  ^=  B   `|     binary     |  yes   |   2   |
|  left shift-assign      |`   A  <<=  B  `|     binary     |  yes   |   2   |
|  right shift-assign     |`   A  >>=  B  `|     binary     |  yes   |   2   |
|  binary invert          |`     ~ A      `|     binary     |  no    |   1   |
|  boolean AND            |`   A  &&  B   `|     boolean    |  no    |   2   |
|  boolean OR             |`   A  ||  B   `|     boolean    |  no    |   2   |
|  boolean AND-assign     |`   A  &&=  B  `|     boolean    |  yes   |   2   |
|  boolean OR-assign      |`   A  ||=  B  `|     boolean    |  yes   |   2   |
|  boolean invert         |`     ! A      `|     boolean    |  no    |   1   |
|  less than              |`   A  <  B    `|   comparison   |  no    |   2   |
|  less than or equal     |`   A  <=  B   `|   comparison   |  no    |   2   |
|  greater than           |`   A  >  B    `|   comparison   |  no    |   2   |
|  greater than or equal  |`   A  >=  B   `|   comparison   |  no    |   2   |
|  equal                  |`   A  ==  B   `|   comparison   |  no    |   2   |
|  not equal              |`   A  !=  B   `|   comparison   |  no    |   2   |
|  strict equality        |`   A  ===  B  `|   comparison   |  no    |   2   |
|  strict inequality      |`   A  !==  B  `|   comparison   |  no    |   2   |
|  declare-local          |`   var A      `|    special     | maybe  |  any  |
|  declare-global         |`   global A   `|    special     | maybe  |  any  |
|  array literal          |` [ A, B, .. ] `|    special     |  no    |  any  |
|  dict. literal          |` {A=1,B=2,..} `|    special     |  no    |  any  |
|  assign                 |`   A  =  B    `|    special     |  yes   |   1   |
|  concatenate            |`   A  $  B    `|    special     |  no    |   2   |
|  concatenate-assign     |`   A  $=  B   `|    special     |  yes   |   2   |
|  property               |`   A  .  B    `|    special     | maybe  |   2   |
|  index                  |`   A [ B ]    `|    special     | maybe  |   2   |
|  function call          |`  A ([B,..])  `|    special     |  no    | <=256 |
|  function definition    |` function A.. `|    special     | maybe  |   0   |
|  inline if              |`  if(A,B,C)   `|    special     |  no    |  3(2) |
|  subexpression          |` ( A[, ..] )  `|    special     | maybe  |  any  |
------------------------------------------------------------------------------

Some notes on the special cases:

- [increment,decrement] pre-increment and pre-decrement operators return the modified value, post- operators - the original one
- [boolean] all boolean operators except 'boolean invert' (which returns bool) set/return one of the two operands passed
- [equality] strict (in)equality operators are the same as their non-strict counterparts with one difference: they do type checking, for example `5 == 5.0` would return 'true' and `5 === 5.0` would return 'false'
- [declare] declarations only actually set the data if they include the assignment expression, otherwise only the type is internally noted for other references
- [declare] variables can be redeclared as long as they maintain their access level
- [property,index] whether property or index expressions set data depends if they're on the receiving (left) end of an assignment expression
- [inline if] 3 inputs are required, 2 are actually used (as if `if(A){return B;}else{return C;}` was used)
- [subexpression] subexpressions can set data if they are set up like this: <subexpression> = <function-call> - this is the way to read more than one return value from a function


# Statements [info]

There are 4 statement types in SGScript:

=== Container statements

There are two types of container statements: expression statements and block statements.

- Expression statements contain zero or more expressions, separated by commas (",") and ending with semicolons (";").
- Block statements contain zero or more statements.

Format:

- expression statement: `<expression>[, <expression>[, <expression> ...]] ;`
- block statement: `{ [<statement>[, <statement>...]] }`

Examples:

    a = 5;
    a = 1, b = 2;

=== Flow control statements

These statements decide which code gets executed when. They include loops (while, for, foreach, do/while), the if/else construct, break/continue/return.

Formats:

- if/else: `if( <expression> ) <statement> [ else <statement> ]`
- while: `while( <expression> ) <statement>`
- for: `for( <expression-list>; <expression-list>; <expression-list> ) <statement>`
- foreach: `foreach( [<identifier>,][<identifier>] : <expression> ) <statement>`
- do/while: `do <statement> while( <expression> )`
- break: `break <N>;`
- continue: `continue <N>;`
- return: `return <expression-list>;`

Examples:

    if( a )
    {
        print( "a is true" );
    }
    else
        print( "a is not true" );
    
    while( b > 0 ) b--;

=== Declaration statements

Statements that begin with "var", "global" or "function" declare and set variables.

Examples:

    var x = 5, y = 6, z;
    global World = null;
    function fn(){ INFO( "'fn' was called" ); }

=== Function call statements

These statements are converted directly to function calls. Currently, 'include' and 'print' functions are available as statements.

Formats:

- include: `include [<file1>[, <file2>...]];` - for each entry, a function call is generated
- print: `print [<string>[, <string>...]];` - one function call is generated for all items

Examples:

    include "io", "string";
    print "Count: ", count;


# <<<


# Common constructs in SGScript [info]

This section shows some ways of implementing various often-used constructs in SGScript. Some of them (specifically the constructs coming from compiled languages) do not map directly to any set of native features and are considered solutions of lower quality.

# >>>


# Basic classes [info]

    global SampleClass = {}; // create a placeholder type dictionary
    
    function SampleClass.SampleMethod( a, b ) // this is the name that will show up in debug output
    {
        return a + b + this.c; // usage of "this" turns the function into a method
    }
    
    function SampleClass.SampleFunction( a, b )
    {
        return a + b;
    }
    
    // Function will show up as "<anonymous>" in debug output, so avoid this kind of function declaration if possible
    SampleClass.SampleAnonymous = function( a, b )
    {
        return a + b + this.c;
    }; // <-- the semicolon is required for this notation
    
    // Giving functions a specific name:
    function MyCustomFunction( a, b )
    {
        return a + b + this.c; // note that it is still possible to use "this"
    }
    SampleClass.Sample = MyCustomFunction;
    
    SampleClass.StaticVariable = 5;
    
    // class instantiation without custom data
    myclass = class( {}, SampleClass );
    
    // class instantiation with custom data
    CustomData = { c = 5, d = 6 };
    mydataclass = class( CustomData, SampleClass );
    
    // static construction function
    function SampleClass.Create( x )
    {
        data = { c = x };
        return class( data, SampleClass );
    }
    
    // make class interface into a construction function
    function SampleClass.__call( x )
    {
        return SampleClass.Create( x );
    }
    SampleClass = class( null, SampleClass );
    // Be aware that this method involves some runtime overhead.
    // Prefer simply giving the construction function (or the interface variable) a different name:
    function createSampleClass( x )
    {
        data = { c = x };
        return class( data, SampleClass );
    }
    
    // destructor
    function SampleClass.__destruct()
    {
        this.c = null;
    }
    
    // many more special methods are available for 'class' objects


# Inheritance [info]

    // class A - base class
    global A = {};
    function A.func()
    {
        println( "base" );
    }
    function A.create()
    {
        return class( {}, A );
    }
    
    // class B - inherits from A
    global B = {};
    function B.func()
    {
        // needless to say, this is not the preferred way to do software design in SGScript
    	this._super._super.func.thiscall( this );
        println( "override" );
    }
    A.func_A = A.func; // make a duplicate entry that will not be overridden
    // it is usually preferred to make the duplicates near the original entries where they're expected to be overridden
    function B.func()
    {
        B.func_A(); // call that entry instead of the original, obstructed entry 
        println( "override" );
    }
    function B.create()
    {
        return class( {}, class( B, A ) );
    }


# Game entities [info]

With game entities and objects of similar structure (just about any object) it is easier to simply define it as a key-value data map, without any classes, inheritance or anything of that kind. The nature of a dynamically typed scripting engine implies that almost everything is checked at runtime, making emulation of compiled language constructs pointless.

    entity =
    {
        x = 10,
        y = 20,
    };
    
    function entity.tick( dt )
    {
        this.x += dt;
    }


# <<<


# Numeric string parsing rules [info]

">>>" means "until any other symbol has been found" (the text is too dense for exact repetition)

The string is not a number if no numeric characters (0-9) could be parsed. (for example, "+" isn't a number but "0x" is)

- if string begins with 0b and has at least 3 characters, try to read a binary integer
-- >>>, 0 or 1 adds the specified bit to the integer
- if string begins with 0o and has at least 3 characters, try to read an octal integer
-- >>>, characters 0-7 add the specified 3 bits to the integer
- if string begins with 0x and has at least 3 characters, try to read a hexadecimal integer
-- >>>, characters 0-9, a-f and A-F add the specified 4 bits to the integer
- otherwise, try to read a decimal number
-- do a test to see if the number is not an integer
--- skip the sign character (+ or -)
--- skip the 0-9 characters
--- if e, E or . is found, try to read a real value
---- read the sign character (+ or -)
---- >>>, characters 0-9 add the specified decimal number to the whole part
---- if the dot character (.) is found, read the fractional part
----- >>>, characters 0-9 add the specified decimal number to the fractional part
---- if at least 3 more characters can be found and the first is "e" or "E", read the exponent part
----- read the sign character (+ or -)
----- >>>, characters 0-9 add the specified decimal number to the exponent part
--- otherwise, try to read the integer
---- read the sign character (+ or -)
---- >>>, characters 0-9 add the specified decimal number to the integer


# <<<


# C API reference [info]

The interface that it defines is one of the driving forces of SGScript. It is heavily influenced by Lua, while also adding some features of PHP (Zend Engine) and Python.

The most important difference is in error handling and triggers: errors detected in C can easily be non-fatal. Just like with PHP, minor errors are emitted as warnings that also propagate invalid (null) values throughout the system to effectively disable the subsequent calls and notify whoever is interested of the exact trail of errors. Furthermore, this behavior can be modified by using protected calls (pcall function) in SGScript and custom error printing callbacks in C.

The virtual machine supports:

- Operator overloading
- On-demand garbage collection
- Full introspection of machine state
- Type registration for simplified cross-library data reuse


# >>>


# Constants and types [info]

This part of the documentation describes the various types and definitions used in the C API.

# >>>


# Main types [info]

Return types:
- SGSRESULT [int]: output code (success = 0, failure: < 0 )
- SGSBOOL [int]: simplified output code (success = 1, failure = 0)
- SGSMIXED [int32_t] output code / value (success + value: >= 0, failure: < 0)

Virtual machine / language types:
- sgs_Bool [int32_t]: boolean value
- sgs_Int [int64_t]: integer
- sgs_Real [double]: real (floating point) value
- sgs_SizeVal [int32_t]: size type
- sgs_CFunc [int ( sgs_Context* )]: C function type
- sgs_ObjCallback [int ( sgs_Context*, sgs_VarObj*, int )]: object interface function
- sgs_Variable [struct]: the combined variable type

System types:
- sgs_Context [struct]: the virtual machine
- sgs_StackFrame [struct]: the function call info object

Interface types:
- sgs_MemFunc [void* ( void* userdata, void* ptr, size_t size )]: memory interface function
- sgs_OutputFunc [void ( void* userdata, sgs_Context* C, const void* buf, sgs_SizeVal size )]: output function
- sgs_PrintFunc [void ( void* userdata, sgs_Context* C, int code, const char* text )]: error printing function
- sgs_HookFunc [void ( void*, sgs_Context*, int )]: debug hook function


# Error codes [info]

These are the default meanings for error codes that are honored throughout the API.

- Generated by the C API
-- SGS_SUCCESS: operation was successful
-- SGS_ENOTFND: item was not found
-- SGS_ECOMP: compile error
-- SGS_ENOTOBJ: argument was not an object
-- SGS_ENOTSUP: operation is not supported
-- SGS_EINVAL: invalid value was passed
-- SGS_EINPROC: process was interrupted

- Generated by SGScript VM
-- SGS_INFO: information about potential issues and state of the system
-- SGS_WARNING: non-fatal issues
-- SGS_ERROR: fatal issues
-- any other integer may be defined and returned by other interfaces


# Variable type flags [info]

- primary flags
-- SGS_VT_NULL: (primary null flag, actually - lack of a primary flag)
-- SGS_VT_[BOOL|INT|REAL|STRING|FUNC|CFUNC|OBJECT]: primary flags

- property flags
-- SGS_VTF_NUM: numeric type flag
-- SGS_VTF_CALL: always-callable type flag
-- SGS_VTF_REF: reference-counted type flag
-- SGS_VTF_ARRAY: array type flag
-- SGS_VTF_ARRAY_ITER: array iterator type flag
-- SGS_VTF_DICT: dict type flag

- complete flag combos
-- SGS_VTC_[NULL|BOOL|INT|REAL|STRING|FUNC|CFUNC|OBJECT]: complete variable flags
-- SGS_VTC_[ARRAY|ARRAY_ITER|DICT]: complete specialized variable flags


# Object operation types [info]

- SGS_OP_END: <end of list> marker op
- SGS_OP_DESTRUCT: object destruction op (argument: whether should free child variables - 1/0)
- SGS_OP_GETINDEX: object index/property retrieval (argument: whether is a property)
- SGS_OP_SETINDEX: object index/property store (argument: whether is a property)
- SGS_OP_CONVERT: object conversion (argument: subtype)
-- subtype = SGS_VT_[BOOL|INT|REAL|STRING]: convert to boolean/integer/real/string
-- subtype = SGS_CONVOP_CLONE: create a clone of the object
-- subtype = SGS_CONVOP_TOTYPE: return the type name as string
-- subtype = SGS_TOITER: return a new iterator object for the current one
- SGS_OP_SERIALIZE: generate serialized code
- SGS_OP_DUMP: print anything informational about the variable
- SGS_OP_GCMARK: mark the object as reachable by the GC
- SGS_OP_GETNEXT: [for iterators] return the data / advance to next item
-- subtype = SGS_GETNEXT_[KEY|VALUE]: return the key/value from the iterator
-- subtype = 0: advance to next item
- SGS_OP_CALL: call the object
- SGS_OP_EXPR: perform an expression between this and another object
-- subtype = SGS_EOP_[ADD|SUB|MUL|DIV|MOD]: return A [+|-|*|/|%] B
-- subtype = SGS_EOP_COMPARE: if A < B, return -1; if A > B, return 1; otherwise return 0;
-- subtype = SGS_EOP_NEGATE: return the current value, negated


# <<<


# Primary interface [info]
# >>>


# sgs_CreateEngine [function alias]

== sgs_Context* sgs_CreateEngine()
=== returns a new scripting engine context

- alias to `sgs_CreateEngineExt( sgs_DefaultMemFunc, NULL )`


# sgs_CreateEngineExt [function]

== sgs_Context* sgs_CreateEngineExt( sgs_MemFunc memfunc, void* mfuserdata )
=== returns a new scripting engine context, attached to the specified allocator


# sgs_DestroyEngine [function]

== sgs_DestroyEngine( sgs_Context* C )
=== destroys the passed context and frees all memory associated to it


# sgs_ExecString [function alias]

== SGSRESULT sgs_ExecString( sgs_Context* C, const char* str )
=== compiles and executes a string of text

- leaves the stack the same as it was before the call
- alias to `sgs_ExecBuffer( C, str, SGS_STRINGLENGTHFUNC( str ) )`
- theoretically bytecode is supported but it will most probably be trimmed by the string length function, unless a different string termination mark is used, and a different string length function to detect it is set

=== error codes
- SGS_ECOMP: compiler error
- SGS_EINVAL: passed data was not recognized


# sgs_ExecBuffer [function alias]

== SGSRESULT sgs_ExecBuffer( sgs_Context* C, const char* buf, sgs_SizeVal size )
=== compiles and executes a buffer of text or bytecode

- leaves the stack the same as it was before the call
- alias to `sgs_EvalBuffer( C, buf, size, NULL )`

=== error codes
- SGS_ECOMP: compiler error
- SGS_EINVAL: passed data was not recognized


# sgs_EvalString [function alias]

== SGSRESULT sgs_EvalString( sgs_Context* C, const char* str, int* rvc )
=== compiles and executes a string of text, optionally leaving the return values on stack and returning the number of values via `rvc`

- if `rvc` is not set (NULL), return values are removed - the stack is the same as it was before the call
- alias to sgs_EvalBuffer( C, str, SGS_STRINGLENGTHFUNC( str ), rvc )

=== error codes
- SGS_ECOMP: compiler error
- SGS_EINVAL: passed data was not recognized


# sgs_EvalBuffer [function]

== SGSRESULT sgs_EvalBuffer( sgs_Context* C, const char* buf, sgs_SizeVal size, int* rvc )
=== compiles and executes a buffer of text or bytecode, optionally leaving the return values on stack and returning the number of values via `rvc`

- if `rvc` is not set (NULL), return values are removed - the stack is the same as it was before the call

=== error codes
- SGS_ECOMP: compiler error
- SGS_EINVAL: passed data was not recognized


# sgs_ExecFile [function alias]

== SGSRESULT sgs_ExecFile( sgs_Context* C, const char* filename )
=== compiles and executes a file containing script text or bytecode

- leaves the stack the same as it was before the call
- alias to `sgs_EvalFile( C, filename, NULL )`

=== error codes
- SGS_ECOMP: compiler error
- SGS_EINVAL: passed data was not recognized


# sgs_EvalFile [function]

== SGSRESULT sgs_ExecFile( sgs_Context* C, const char* filename, int* rvc )
=== compiles and executes a file containing script text or bytecode, optionally leaving the return values on stack and returning the number of values via `rvc`

- if `rvc` is not set (NULL), return values are removed - the stack is the same as it was before the call

=== error codes
- SGS_ECOMP: compiler error
- SGS_EINVAL: passed data was not recognized


# sgs_LoadLib_*** [functions]

== SGSRESULT sgs_LoadLib_Fmt( sgs_Context* C )
== SGSRESULT sgs_LoadLib_IO( sgs_Context* C )
== SGSRESULT sgs_LoadLib_Math( sgs_Context* C )
== SGSRESULT sgs_LoadLib_OS( sgs_Context* C )
== SGSRESULT sgs_LoadLib_RE( sgs_Context* C )
== SGSRESULT sgs_LoadLib_String( sgs_Context* C )
=== loads the library into the specified context

- it is generally unnecessary to check for these error codes

=== error codes
- SGS_E****: first error encountered (operation stopped somewhere in the middle)


# sgs_Reg***Const [struct]

== sgs_RegFuncConst { char* name; sgs_CFunc value; }
== sgs_RegIntConst { char* name; sgs_Int value; }
== sgs_RegRealConst { char* name; sgs_Real value; }
=== a pair of null-terminated string and a scripting engine value type


# sgs_Reg***Consts [function]

== SGSRESULT sgs_RegFuncConsts( sgs_Context* C, const sgs_RegFuncConst* list, int size )
== SGSRESULT sgs_RegIntConsts( sgs_Context* C, const sgs_RegIntConst* list, int size )
== SGSRESULT sgs_RegRealConsts( sgs_Context* C, const sgs_RegRealConst* list, int size )
=== loads the specified list of constants in the context

- the end of list can be specified in two ways
-- set the size to `sizeof(list)/sizeof(list[0])`
-- set the size to -1 and end the list with `SGS_RC_END()`
-- using both at the same time should be reserved to special cases only

=== error codes
- SGS_E****: first error encountered (operation stopped somewhere in the middle)


# <<<


# Data interface [info]
# >>>


# sgs_Push*** [functions]

== void sgs_PushNull( sgs_Context* C )
== void sgs_PushBool( sgs_Context* C, sgs_Bool value )
== void sgs_PushInt( sgs_Context* C, sgs_Int value )
== void sgs_PushReal( sgs_Context* C, sgs_Real value )
== void sgs_PushStringBuf( sgs_Context* C, const char* str, sgs_SizeVal size )
== void sgs_PushString( sgs_Context* C, const char* str )
== void sgs_PushCFunction( sgs_Context* C, sgs_CFunc func )
== void sgs_PushObject( sgs_Context* C, void* data, void** iface )
== void* sgs_PushObjectIPA( sgs_Context* C, sgs_SizeVal added, void** iface )
== void sgs_PushVariable( sgs_Context* C, sgs_Variable* var )
=== pushes the data on the stack, as a new entry, appended to the end

- sgs_Bool is transformed to 0/1 before pushing, everything else is unchanged
- sgs_PushStringBuf( C, NULL, size ) would allocate an uninitialized buffer
-- it is accessible immediately by @sgs_GetString[Ptr|Size]( C, -1 )
- sgs_PushObjectIPA stands for "push object, allocate memory in-place"
-- it means that the `added` memory space will be appended to the end of object allocation
-- this allows to allocate all object data for most objects with just one allocation, instead of two
-- the allocated memory will be returned and also available via sgs_GetObjectData( C, -1 )
- sgs_PushVariable will increment the reference count of strings, SGS functions and objects
- these functions do not throw an error when the stack is full since there is no way to handle that


# sgs_Pop [function]

== SGSRESULT sgs_Pop( sgs_Context* C, int count )
=== pops `count` variables off the current frame of the stack

=== error codes
- SGS_EINVAL: `count` was bigger than the number of items in the current stack frame or `count` is less than 0


# sgs_PopSkip [function]

== SGSRESULT sgs_PopSkip( sgs_Context* C, int count, int skip )
=== pops `count` variables off the current frame of the stack, skipping the last `skip` elements

=== error codes
- SGS_EINVAL: `count+skip` was bigger than the number of items in the current stack frame or `count` is less than 0 or `skip` is less than 0


# sgs_InsertVariable [function]

== SGSRESULT sgs_InsertVariable( sgs_Context* C, int pos, sgs_Variable* var )
=== inserts a variable `var` at a given index `pos` of the current stack frame, increasing its reference count

=== error codes
- SGS_EBOUNDS: index out of bounds


# sgs_PushArray [function]

== SGSRESULT sgs_PushArray( sgs_Context* C, sgs_SizeVal numitems )
=== creates an array from `numitems` last items on the stack, pops those items and pushes the array

=== error codes
- SGS_EINVAL: more items are selected than exist in the current stack frame


# sgs_PushDict [function]

== SGSRESULT sgs_PushDict( sgs_Context* C, sgs_SizeVal numitems )
=== creates a dict from `numitems` last items on the stack, pops those items and pushes the dict

- `numitems` can be even or 0, since all odd arguments are keys and all even arguments are values

=== error codes
- SGS_EINVAL: more items are selected than exist in the current stack frame or `numitems` wasn't even or 0


# sgs_PushItem [function]

== SGSRESULT sgs_PushItem( sgs_Context* C, int item )
=== copy an item from the current stack frame and append it to the end of the stack

=== error codes
- SGS_EBOUNDS: index out of bounds


# sgs_StoreItem [function]

== SGSRESULT sgs_StoreItem( sgs_Context* C, int item )
=== copy last item in current stack frame to index `item` and pop it

- `item` refers to a position after the pop operation, therefore -1 means one element before the last etc.

=== error codes
- SGS_EBOUNDS: index out of bounds


# sgs_PushProperty [function]

== SGSRESULT sgs_PushProperty( sgs_Context* C, const char* name )
=== load and push the property of the topmost item in the current stack frame

=== error codes
- SGS_EINPROC: current stack frame is empty
- SGS_ENOTFND: property was not found
- other codes may appear if returned by custom objects


# sgs_StoreProperty [function]

== SGSRESULT sgs_StoreProperty( sgs_Context* C, int obj, const char* name )
=== copy and pop the topmost item of the current stack frame to the property `name` of variable `obj`

=== error codes
- SGS_EBOUNDS: `obj` was not pointing inside the current stack frame
- SGS_ENOTFND: property was not found
- other codes may appear if returned by custom objects


# sgs_PushNumIndex [function]

== SGSRESULT sgs_PushNumIndex( sgs_Context* C, int obj, sgs_Int idx )
=== load and push the integer index `idx` of the variable `obj`

=== error codes:
- SGS_EBOUNDS: `obj` was not pointing inside the current stack frame / array index out of bounds
- SGS_ENOTFND: index was not found
- other codes may appear if returned by custom objects


# sgs_StoreNumIndex [function]

== SGSRESULT sgs_StoreNumIndex( sgs_Context* C, int obj, sgs_Int idx )
=== copy and pop the topmost item of the current stack to the integer index `idx` of variable `obj`

=== error codes
- SGS_EBOUNDS: `obj` was not pointing inside the current stack frame / array index out of bounds
- SGS_ENOTFND: index was not found
- other codes may appear if returned by custom objects


# sgs_PushIndexExt [function]

== SGSRESULT sgs_PushIndexExt( sgs_Context* C, int obj, int idx, int prop )
=== load and push the indexed item/property (if `prop` is nonzero) `idx` of the item `obj` in the current stack frame

=== error codes
- SGS_EBOUNDS: `obj` or `idx` were not pointing inside the current stack frame / array index out of bounds
- SGS_ENOTFND: property/index was not found
- SGS_EINVAL: index is not of string or integer type
- other codes may appear if returned by custom objects


# sgs_PushIndex [function alias]

== SGSRESULT sgs_PushIndex( sgs_Context* C, int obj, int idx )
=== load and push the indexed item `idx` of the item `obj` in the current stack frame

- alias of `sgs_PushIndexExt( C, obj, idx, 0 )`

=== error codes
- SGS_EBOUNDS: `obj` or `idx` were not pointing inside the current stack frame / array index out of bounds
- SGS_ENOTFND: index was not found
- SGS_EINVAL: index is not of string or integer type
- other codes may appear if returned by custom objects


# sgs_PushIndexP [function]

== SGSRESULT sgs_PushIndexP( sgs_Context* C, sgs_Variable* obj, sgs_Variable* idx )
=== load and push the indexed item `idx` of the item `obj`

=== error codes
- SGS_EBOUNDS: array index out of bounds
- SGS_ENOTFND: index was not found
- SGS_EINVAL: index is not of string or integer type
- other codes may appear if returned by custom objects


# sgs_StoreIndexExt [function]

== SGSRESULT sgs_StoreIndexExt( sgs_Context* C, int obj, int idx, int prop )
=== copy and pop the topmost stack item to the indexed item/property (if `prop` is nonzero) `idx` of the item `obj` in the current stack frame

=== error codes
- SGS_EBOUNDS: `obj` or `idx` were not pointing inside the current stack frame / array index out of bounds
- SGS_ENOTFND: property/index was not found
- SGS_EINVAL: index is not of string or integer type
- other codes may appear if returned by custom objects


# sgs_StoreIndex [function alias]

== SGSRESULT sgs_StoreIndex( sgs_Context* C, int obj, int idx )
=== copy and pop the topmost stack item to the indexed item `idx` of the item `obj` in the current stack frame

=== error codes
- SGS_EBOUNDS: `obj` or `idx` were not pointing inside the current stack frame / array index out of bounds
- SGS_ENOTFND: index was not found
- SGS_EINVAL: index is not of string or integer type
- other codes may appear if returned by custom objects


# sgs_StoreIndexP [function]

== SGSRESULT sgs_StoreIndexP( sgs_Context* C, sgs_Variable* obj, sgs_Variable* idx )
=== copy and pop the topmost stack item to the indexed item `idx` of the item `obj`

=== error codes
- SGS_EBOUNDS: array index out of bounds
- SGS_EINPROC: current stack frame is empty
- SGS_ENOTFND: index was not found
- SGS_EINVAL: index is not of string or integer type
- other codes may appear if returned by custom objects


# sgs_PushGlobal [function]

== SGSRESULT sgs_PushGlobal( sgs_Context* C, const char* name )
=== push the global variable `name` on the stack

=== error codes
- SGS_ENOTFND: variable was not found


# sgs_StoreGlobal [function]

== SGSRESULT sgs_StoreGlobal( sgs_Context* C, const char* name )
=== copy and pop the topmost stack item to the global variable `name`

- _G is the environment table (a superglobal, list of global variable names and values)

=== error codes
- SGS_EINPROC: current stack frame was empty
- SGS_ENOTSUP: _G only accepts dict values


# sgs_PushPath [function]

== sgs_PushPath( sgs_Context* C, int item, const char* path, ... )
=== push the variable specified by starting point `item` and traversal path `path`

! The safety of this function is similar to that of the printf family of functions. Be explicit in what types you pass to the variable argument list to avoid errors.

- the syntax of `path`:
-- a list of letters, specifying a sub-variable to request (o,p,s,i,k,n)

==== table of accepted letters
---------------------------------------------------------------------------------------
! letter ! property? ! variable arguments ! virtual machine access mode / description !
|    o   |    yes    |  SizeVal           |   integer property                        |
|    p   |    yes    |  C string          |   string property                         |
|    s   |    yes    |  SizeVal, buffer   |   special string property                 |
|    i   |    no     |  SizeVal           |   integer index                           |
|    k   |    no     |  C string          |   string index                            |
|    n   |    no     |  SizeVal, buffer   |   special string index                    |
---------------------------------------------------------------------------------------
- legend:
-- SizeVal: sgs_SizeVal / int32_t
-- C string: null-terminated char* string
-- buffer: char* byte array, size is specified in the previous argument
-- property?: if yes, property access is used (object.property), otherwise index access is used (object[index])

=== error codes
- SGS_EINVAL: invalid symbol found in path / corresponding variable arguments had an invalid value
- other errors, as returned by @sgs_PushIndexExt()


# sgs_StorePath [function]

== sgs_StorePath( sgs_Context* C, int item, const char* path, ... )
=== copy and pop the topmost item on stack to variable specified by starting point `item` and traversal path `path`

! The safety of this function is similar to that of the printf family of functions. Be explicit in what types you pass to the variable argument list to avoid errors.

- the syntax of `path` is the same as with @sgs_PushPath()
- the last item on the path (or in the case of an empty path, the starting point) is accessed with a store operation, the rest - with a push operation

=== error codes
- SGS_EINVAL: invalid symbol found in path / corresponding variable arguments had an invalid value
- SGS_EINPROC: current stack frame is empty
- other errors, as returned by @sgs_PushIndexExt() or @sgs_StoreIndexExt()


# sgs_ArgErrorExt [function]

== int sgs_ArgErrorExt( SGS_CTX, int argid, int method, const char* expect, const char* expfx )
=== prints the argument type mismatch error

- always returns 0 so it can be used to return and print an error in the same statement


# sgs_ArgError [function]

== int sgs_ArgError( sgs_Context* C, int argid, int expect, int is_strict )
=== prints the argument type mismatch error

- always returns 0 so it can be used to return and print an error in the same statement


# sgs_***ArgError [function aliases]

== int sgs_FuncArgError( sgs_Context* C, int argid, int expect, int is_strict )
== int sgs_MethodArgError( sgs_Context* C, int argid, int expect, int is_strict )
=== prints the argument type mismatch error

- always returns 0 so it can be used to return and print an error in the same statement
- alias to `sgs_ArgError( C, argid, Func/Method => 0/1, expect, is_strict )`


# sgs_LoadArgsExt [function]

== SGSMIXED sgs_LoadArgsExt( sgs_Context* C, int from, const char* cmd, ... )
=== parse the stack items and retrieve their data according to `cmd`, starting from item `from`

- for anything function requires, pass the value; for anything it returns - the pointer to the value
- `cmd` is a string consisting of one-character commands
- the commands are grouped into two kinds: control commands and parsing commands
- function returns whether all required arguments have been parsed successfully
-- thus, if function returns < 1, state of outputs is somewhat unknown unless filled with defaults
-- it is guaranteed that all arguments will be parsed from first (specified) forward, not in any other way

! unlike sgs_LoadArgs, it returns `SGSMIXED` and must be checked differently ("ret.val. > 0", if same output needed)

==== control commands
- `?` -- only check, do not write the result and do not require a pointer to write the data to
- `!` -- enable strict parsing for the next item (requires exactly the type specified
- `-`,`+` -- enable (-) or disable (+) treating integers as signed (default = true)
- `|` -- mark the point where required arguments end and optional arguments begin
- `#` -- do range checking on integer arguments (min/max of the required types)
- `^` -- clamp the argument to the range of the required type
- `~` -- ignore ranges and chop out-of-range integers (default)
- `<` -- move argument pointer 1 item back (cannot move it before 0)
- `>` -- move argument pointer 1 item forward
- `@` -- specify that this is a method (argument 0 = 'this'; shifts argument indices on error printing by -1)
- `.` -- specify the end of argument list (how many arguments are expected)

==== parsing commands
- `n` -- check for `null` (returns SGSBOOL = 1, always strict)
- `b` -- check for `bool` (returns SGSBOOL)
- `c` -- check for `int` (returns int8_t or uint8_t, depending on sign settings, may check ranges)
- `w` -- check for `int` (returns int16_t or uint16_t, depending on sign settings, may check ranges)
- `l` -- check for `int` (returns int32_t or uint32_t, depending on sign settings, may check ranges)
- `q` -- check for `int` (returns int64_t or uint64_t, depending on sign settings, may check ranges)
- `i` -- check for `int` (returns sgs_Int, may check ranges)
- `f` -- check for `real` (returns float)
- `d` -- check for `real` (returns double)
- `r` -- check for `real` (returns sgs_Real)
- `s` -- check for `string` (returns char*)
- `m` -- check for `string` (returns char* string and sgs_SizeVal size)
- `p` -- check for `func/cfunc/object with SGS_OP_CALL` (callables) (returns SGSBOOL = 1)
- `a` -- check for `array` (returns sgs_SizeVal size, use -1 as starting value to check optional arguments)
- `t` -- check for `dict` (returns sgs_SizeVal size, use -1 as starting value to check optional arguments)
- `o` -- check for `object` (requires void** interface, returns sgs_VarObj* data)
- `v` -- check for any (non-null if strict, returns sgs_Variable data)
- `x` -- call a custom checking function (requires sgs_ArgCheckFunc, everything else depends on function)

=== error codes
- SGS_EINVAL: error in `cmd` (wrong character/argument pointer moved before 0)


# sgs_LoadArgs [function alias]

== SGSBOOL sgs_LoadArgs( sgs_Context* C, const char* cmd, ... )
=== parse the stack items and retrieve their data according to `cmd`, starting from item 0

! unlike sgs_LoadArgsExt, it returns `bool` - whether all required arguments have been successfully parsed

- for more info on syntax and usage, refer to @sgs_LoadArgsExt
- alias to `sgs_LoadArgsExt( C, 0, cmd, ... )>0`


# <<<


# Operations [info]
# >>>


# sgs_FCall [function]

== SGSRESULT sgs_FCall( sgs_Context* C, int args, int expect, int gotthis )
=== call the topmost variable on stack with the arguments before it, returning the expected number of variables on stack

- `args`: the primary variables to be passed to the function, in the same order they are in the stack
- `expect`: the number of variables to be left after a successful call
- `gotthis`: whether the function is a method and an additional argument needs to be passed as the 'this' value before others

After a successful call, all arguments and the function will be popped off the stack and the expected number of variables will appear in their place. If the underlying callable does not return enough arguments, 'null' variables will be pushed instead. If the number of returned values is bigger than expected, only the first expected return values will stay on the stack.

- expected stack structure:
-- (if gotthis != 0) [this]
-- [argument] x `args`
-- [callable]

- a callable is one of the following:
-- SGS function
-- C function
-- object with SGS_OP_CALL interface function defined

! Stack is returned to the expected state only if the return value is equal to SGS_SUCCESS or SGS_EINPROC. Otherwise, it's left exactly as it was before the call.

=== error codes
- SGS_EINPROC: topmost item on stack was not callable
- SGS_EINVAL: not enough values in current stack frame (must have at least `args + (gotthis?1:0) + 1`)


# sgs_(This)Call [function aliases]

== SGSRESULT sgs_Call( sgs_Context* C, int args, int expect )
== SGSRESULT sgs_ThisCall( sgs_Context* C, int args, int expect )
=== call the topmost variable on stack with the arguments before it, returning the expected number of variables on stack

- aliases to @sgs_FCall(), for the first `gotthis = 0`, for the second `gotthis = 1`.


# sgs_GlobalCall [function]

== SGSRESULT sgs_GlobalCall( sgs_Context* C, const char* name, int args, int expect )
=== call the global variable `name` as a function

- combination of @sgs_PushGlobal() and @sgs_Call()


# sgs_TypeOf [function]

== SGSRESULT sgs_TypeOf( sgs_Context* C )
=== return the type name string of topmost variable in current stack frame

- if the object does not support the specific part of the conversion interface function, a string of format "object (%p)" is returned to ensure expected type name comparison capabilities

=== error codes
- SGS_EINPROC: current stack frame was empty


# sgs_DumpVar [function]

== SGSRESULT sgs_DumpVar( sgs_Context* C, int maxdepth )
=== convert the topmost variable of current stack frame to a highly informative string that should display the contents of the variable, up to `maxdepth` depth

- if object does not have the SGS_OP_DUMP interface function implemented, only its pointer in memory and reference count are displayed

=== error codes
- SGS_EINPROC: current stack frame was empty
- SGS_EINVAL: invalid base variable type found in variable (not really expected to happen unless custom variable creation is done)


# sgs_GCExecute [function]

== SGSRESULT sgs_GCExecute( sgs_Context* C )
=== call the garbage collector on the VM

- this procedure may take some time if the object graph is big
- during the procedure, the SGS_OP_GCMARK interface functions of objects are invoked for the objects visible from entry points (like stack and global table)
- aborting the procedure via error codes could lead the system into an unrecoverable state

=== error codes
- any code can be returned by SGS_OP_GCMARK and SGS_OP_DESTRUCT functions, doing so would abort the process if the code is not either SGS_SUCCESS or SGS_ENOTFND


# sgs_PadString [function]

== SGSRESULT sgs_PadString( sgs_Context* C )
=== append two spaces after every newline in the topmost variable of current stack frame

=== error codes
- SGS_EINPROC: current stack frame is empty
- SGS_EINVAL: topmost variable is not a string


# sgs_StringConcat [function]

== SGSRESULT sgs_StringConcat( sgs_Context* C )
=== concatenate the two topmost string variables in the current stack frame

=== error codes
- SGS_EINPROC: not enough variables were found in the current stack frame


# sgs_StringMultiConcat [function]

== SGSRESULT sgs_StringMultiConcat( sgs_Context* C, int args )
=== concatenate the `args` number of topmost string variables in the current stack frame

=== error codes
- SGS_EINVAL: not enough (less than `args`) variables were found in the current stack frame


# sgs_CloneItem [function]

== SGSRESULT sgs_CloneItem( sgs_Context* C, int item )
=== push a copy of the specified stack item

! Even though operations with functions and strings succeed, functions and strings are not actually cloned since they are immutable.

=== error codes
- SGS_EBOUNDS: stack item index was out of bounds
- SGS_ENOTFND: the object does not support cloning


# sgs_ObjectAction [function]

== SGSRESULT sgs_ObjectAction( sgs_Context* C, int item, int action, int arg )
=== execute an action on the specified stack item

=== actions
- SGS_ACT_ARRAY_PUSH
-- append the last `arg` items on stack to the array
-- error codes
--- SGS_EINVAL: `item` was not an array, `arg` was negative or bigger than stack frame
- SGS_ACT_ARRAY_POP
-- remove the last `arg` items from the end of the array
-- error codes
--- SGS_EINVAL: `item` was not an array, `arg` was negative or bigger than size of array
- SGS_ACT_ARRAY_POPRET
-- remove the last `arg` items from the end of the array and return them in the order they were stored (last items on array are last on stack)
-- error codes
--- SGS_EINVAL: `item` was not an array, `arg` was negative or bigger than size of array

=== error codes
- SGS_E****: action-specific
- SGS_ENOTFND: action was not found


# sgs_Serialize [function]

== SGSRESULT sgs_Serialize( sgs_Context* C )
=== serialize the topmost variable of the current stack frame (convert to a binary recreation instruction stream)

- the following variable types can be serialized:
-- null, bool, int, real, string, func (SGS function)
-- objects with the SGS_OP_SERIALIZE interface function defined

- serialized data has the following format:
-- a list of 'P' or 'C' commands
-- 'P' (push) command: byte - variable type; variable data
--- variable data: nothing for null, byte for bool, int64 for int, double for real, int32 + char[] for string
-- 'C' (call) command: int32 - number of arguments; byte - function name size; char[] - function name

=== error codes
- SGS_EBOUNDS: current stack frame was empty
- SGS_EINVAL: an unserializable topmost variable was found (function)
- SGS_EINPROC: unknown memory error


# sgs_SerializeObject [function]

== SGSRESULT sgs_SerializeObject( sgs_Context* C, int args, const char* func )
=== write the serialized code for an object's unserializing function

=== error codes
- SGS_EINVAL: function name was too long (255 characters or more)
- SGS_EINPROC: function was used outside serialization interface function


# sgs_Unserialize [function]

== SGSRESULT sgs_Unserialize( sgs_Context* C )
=== unserialize the topmost string variable of the current stack frame (run the binary recreation instruction stream)

! Be mindful of the data sources you use - calls to any global function can be placed in the instruction stream.


# sgs_CompareF [function]

== sgs_Real sgs_CompareF( sgs_Context* C, sgs_Variable* v1, sgs_Variable* v2 )
=== return the difference between variables, as `real`


# sgs_Compare [function alias]

== int sgs_Compare( sgs_Context* C, sgs_Variable* v1, sgs_Variable* v2 )
=== return the difference between variables, as int -1/0/1

- alias to @sgs_CompareF() + conversion (if result < 0, return -1; if result > 0, return 1; otherwise return 0)


# sgs_EqualTypes [function]

== SGSBOOL sgs_EqualTypes( sgs_Context* C, sgs_Variable* v1, sgs_Variable* v2 )
=== return if types of both variables are exactly equal

- both type variables and interface pointers (only if both variables are objects) are checked for equality


# <<<


# Conversion interface [info]
# >>>


# sgs_Get*** [functions]

== sgs_Bool sgs_GetBool( sgs_Context* C, int item )
== sgs_Int sgs_GetInt( sgs_Context* C, int item )
== sgs_Real sgs_GetReal( sgs_Context* C, int item )
=== return an item from the current stack frame, converted to the specified type

- if `item` is out of bounds, 0 is returned


# sgs_To*** [functions]

== sgs_Bool sgs_ToBool( sgs_Context* C, int item )
== sgs_Int sgs_ToInt( sgs_Context* C, int item )
== sgs_Real sgs_ToReal( sgs_Context* C, int item )
=== return an item from the current stack frame, converted in-place to the specified type

- in-place conversion means that if the function succeeds, the item in the stack might have a different type, most likely the requested type


# sgs_ToStringBuf(Fast) [functions]

== char* sgs_ToStringBuf( sgs_Context* C, int item, sgs_SizeVal* outsize )
== char* sgs_ToStringBufFast( sgs_Context* C, int item, sgs_SizeVal* outsize )
=== return an item from the current stack frame, converted in-place to string

- if `item` is out of bounds or conversion fails, NULL is returned
- the 'fast' version uses type name conversion on object, instead of string conversion - this is to avoid recursion while generating a short description about object contents
- length of string is returned to the value that `outsize` points to


# sgs_ToString(Fast) [function aliases]

== char* sgs_ToString( sgs_Context* C, int item )
== char* sgs_ToStringFast( sgs_Context* C, int item )
=== return an item from the current stack frame, converted in-place to string

- aliases of @sgs_ToStringBuf() and @sgs_ToStringBufFast() with the third argument set to NULL


# sgs_Convert [function]

== SGSRESULT sgs_Convert( sgs_Context* C, int item, int type )
=== convert an item from the current stack frame to the specified base type

- `type` expects one of the SGS_VT_* constants

=== error codes
- SGS_EBOUNDS: index out of bounds
- SGS_ENOTSUP: object does not support the specific conversion
- SGS_ENOTFND: object does not support conversions


# sgs_RegisterType [function]

== SGSRESULT sgs_RegisterType( SGS_CTX, const char* name, void** iface )
=== register a type interface by mapping it to a name

=== error codes
- SGS_EINVAL: iface was NULL
- SGS_EINPROC: the name is already used


# sgs_UnregisterType [function]

== SGSRESULT sgs_UnregisterType( SGS_CTX, const char* name )
=== unregister a type interface by its name

=== error codes
- SGS_ENOTFND: the specified type name was not mapped to any interface


# sgs_FindType [function]

== void** sgs_FindType( SGS_CTX, const char* name )
=== finds the type interface that is mapped to the specified name or returns NULL if that type name cannot be found


# sgs_IsObject [function]

== SGSBOOL sgs_IsObject( sgs_Context* C, int item, void** iface )
=== returns whether the specified stack item `item` is an object with the interface pointer `iface`

- if `item` is out of bounds or not an object or doesn't have the specified interface, 0 is returned


# sgs_IsType [function alias]

== SGSBOOL sgs_IsType( sgs_Context* C, int item, const char* type )
=== returns whether the specified stack item `item` is an object of the specified type

- alias of `sgs_IsObject( C, item, sgs_FindType( C, type ) )`


# sgs_IsCallable [function]

== SGSBOOL sgs_IsCallable( sgs_Context* C, int item )
=== returns whether the specified stack item `item` is callable

- callable variables are either SGS functions or C functions or objects with the SGS_OP_CALL interface implemented
- if `item` is out of bounds, 0 is returned


# sgs_IsNumericString [function]

== SGSBOOL sgs_IsNumericString( const char* str, sgs_SizeVal size )
=== checks if the string is convertible to an integer/real

- more info at @<Numeric string parsing rules>


# sgs_Parse*** [functions]

== SGSBOOL sgs_ParseBool( sgs_Context* C, int item, sgs_Bool* out )
== SGSBOOL sgs_ParseInt( sgs_Context* C, int item, sgs_Int* out )
== SGSBOOL sgs_ParseReal( sgs_Context* C, int item, sgs_Real* out )
== SGSBOOL sgs_ParseString( sgs_Context* C, int item, char** out, sgs_SizeVal* size )
=== attempts to parse the specified item of the current stack frame, returning whether parsing was successful

- the parsing rules:
-- if `item` is out of bounds, fail
-- if item has the type `null`, `func` or `cfunc`, fail
-- if item is of `string` type and `bool` is requested, fail
-- if item is of `string` type and `int`/`real` is requested, try to convert
-- if item is of `object` type, success of conversion depends on implementation of the object interface and the rules of sgs_GetBool/sgs_GetInt/sgs_GetReal/sgs_ToStringBuf
-- everything else succeeds


# sgs_PushIterator [function]

== SGSRESULT sgs_PushIterator( sgs_Context* C, int item )
=== create an iterator from the specified item of the current stack frame

- iterators are objects that enable sequential, ordered traversal of object contents, allowing to read up to 2 variables at each position: the key and the value
- iterator starts at the pre-first position, so nothing can be read before the initial state

=== error codes
- SGS_EBOUNDS: index out of bounds
- SGS_ENOTSUP: variable type does not support iterators (only objects support them)
- SGS_ENOTFND: object type does not support iterators (iterator conversion request failed)
- any other code can be returned by the object


# sgs_IterAdvance [function]

== SGSMIXED sgs_IterAdvance( sgs_Context* C, int item )
=== advance the iterator to the next position, returning if the current position is still in range or an error code on failure

- this is the way it's expected to be usually called: `while( sgs_IterAdvance( C, item ) > 0 ){ ... sgs_IterPushData ... }`

=== error codes
- SGS_EBOUNDS: index out of bounds
- SGS_EINVAL: iterated object changed in a way that iterator does not support (currently a size equality test)
- SGS_EINPROC: internal failure in the object interface


# sgs_IterPushData [function]

== SGSRESULT sgs_IterPushData( sgs_Context* C, int item, int key, int value )
=== load and push the data associated with the current position

- `key` and `value` are booleans that specify if the respective value should be returned
- first the key is pushed, then the value
- if neither `key` nor `value` are expected, the call succeeds and doesn't push anything

=== error codes
- SGS_EBOUNDS: index out of bounds
- SGS_EINVAL: iterated object changed in a way that iterator does not support
- SGS_EINPROC: internal failure in the object interface


# sgs_ArraySize [function]

== SGSMIXED sgs_ArraySize( sgs_Context* C, int item )
=== check if the specified stack item is an array and return its size or error code on failure

=== error codes
- SGS_EINVAL: index out of bounds / variable was not an array


# <<<


# Extension interface [info]
# >>>


# sgs_StackSize [function]

== int sgs_StackSize( sgs_Context* C )
=== return the size of the current stack frame


# sgs_IsValidIndex [function]

== SGSBOOL sgs_IsValidIndex( sgs_Context* C, int item )
=== return whether the specified stack index points to an item in the current stack frame

- both positive (first = 0) and negative (last = -1) indices are supported


# sgs_GetStackItem [function]

== SGSBOOL sgs_GetStackItem( sgs_Context* C, int item, sgs_Variable* out )
=== write the data of the specified stack variable if the index is valid

- function returns whether the stack index was valid


# sgs_ItemType [function]

== int sgs_ItemType( sgs_Context* C, int item )
=== return the base type (first 8 bits, mask 0xff) of the specified stack item

- return value will be equal to one of the SGS_VT_* macro
- if index is invalid, return value will be 0


# sgs_ItemTypeExt [function]

== int sgs_ItemTypeExt( sgs_Context* C, int item )
=== return the full type of the specified stack item

- return value expected to be equal to one of the SGS_VTC_* macro
- if index is invalid, return value will be 0


# sgs_Method [function]

== SGSBOOL sgs_Method( sgs_Context* C )
=== unlock the 'this' variable, return if the function was called as a method (and thus variable was unlocked)

- method calls look like this: "object.method(...)"


# sgs_Acquire [function]

== void sgs_Acquire( sgs_Context* C, sgs_Variable* var )
=== increment the reference count of the variable (if it counts references)


# sgs_Release [function]

== void sgs_Release( sgs_Context* C, sgs_Variable* var )
=== decrement and possibly deallocate the reference count of the variable (if it counts references)


# sgs_ReleaseOwned [function]

== void sgs_ReleaseOwned( sgs_Context* C, sgs_Variable* var, int dco )
=== decrement and possibly deallocate the reference count of the variable (if it counts references), depending on `dco`

- `dco` stands for "destroy child objects", which essentially means that if it's zero and the variable is an object, it prevents the object from being destroyed
- expected to be called in destructors of objects may that contain reference-counted variables, using the parameter passed in the callback
- the child objects need to be preserved in exactly once case: the garbage collector destruction phase - when all objects are scheduled for deletion, it is important to avoid destroying them twice


# sgs_GCMark [function]

== SGSRESULT sgs_GCMark( sgs_Context* C, sgs_Variable* var )
=== mark the specified variable as reachable for the garbage collector

- to be called in the SGS_OP_GCMARK object callback


# sgs_GetStringPtr [function]

== char* sgs_GetStringPtr( sgs_Context* C, int item )
=== return the string data pointer of the specified stack item

- if item is out of bounds or not a string, NULL will be returned and ...
-- in a debug build, one of the BreakIf macros will go off and stop the action


# sgs_GetStringSize [function]

== sgs_SizeVal sgs_GetStringSize( sgs_Context* C, int item )
=== return the string size of the specified stack item

- if item is out of bounds or not a string, 0 will be returned and ...
-- in a debug build, one of the BreakIf macros will go off and stop the action


# sgs_GetObjectStruct [function]

== sgs_VarObj* sgs_GetObjectStruct( sgs_Context* C, int item )
=== return the object's internal data pointer of the specified stack item

- if item is out of bounds or not an object, NULL will be returned and ...
-- in a debug build, one of the BreakIf macros will go off and stop the action


# sgs_GetObjectData [function]

== void* sgs_GetObjectData( sgs_Context* C, int item )
=== return the object data pointer of the specified stack item

- if item is out of bounds or not an object, NULL will be returned and ...
-- in a debug build, one of the BreakIf macros will go off and stop the action


# sgs_GetObjectIface [function]

== void** sgs_GetObjectIface( sgs_Context* C, int item )
=== return the object interface pointer of the specified stack item

- if item is out of bounds or not an object, NULL will be returned and ...
-- in a debug build, one of the BreakIf macros will go off and stop the action


# sgs_SetObjectData [function]

== int sgs_SetObjectData( sgs_Context* C, int item, void* data )
=== set the object data pointer of the specified stack item

- if item is out of bounds or not an object, pointer will not be set, 0 will be returned and ...
-- in a debug build, one of the BreakIf macros will go off and stop the action


# sgs_SetObjectIface [function]

== int sgs_SetObjectIface( sgs_Context* C, int item, void* iface )
=== set the object interface pointer of the specified stack item

- if item is out of bounds or not an object, pointer will not be set, 0 will be returned and ...
-- in a debug build, one of the BreakIf macros will go off and stop the action


# <<<


# Environment control interface [info]
# >>>


# sgs_SetOutputFunc [function]

== void sgs_SetOutputFunc( sgs_Context* C, sgs_OutputFunc func, void* userdata )
=== sets the function used in 'print' function

- default implementation copies data to FILE* stream, specified in userdata, it can be found in sgs_ctx.c


# sgs_Write [function]

== void sgs_Write( sgs_Context* C, const void* ptr, sgs_SizeVal size )
=== passes the specified data to the output function

- the default output function prints the data to the specified FILE* stream (stdout by default)


# sgs_WriteStr [function alias]

== void sgs_Write( sgs_Context* C, const char* str )
=== passes the specified string to the output function

- alias to `sgs_Write( C, str, SGS_STRINGLENGTHFUNC( str ) )`


# sgs_Writef [function]

== void sgs_Writef( sgs_Context* C, const char* what, ... )
=== passes the arguments through a vsprintf-like function to expand the data and passes it to the specified output function

- printf rules apply here


# sgs_SetPrintFunc [function]

== void sgs_SetPrintFunc( sgs_Context* C, sgs_PrintFunc func, void* userdata )
=== sets the function that handles and prints the error that has occured, while still being physically in that context

- both subtypes of the default printing function can be set by passing these flags for `func` and a FILE* pointer for `userdata`:
-- 'SGSPRINTFN_DEFAULT' - default behavior (write stack frame, write error, abort on SGS_ERROR)
-- 'SGSPRINTFN_DEFAULT_NOABORT' - default behavior without the abort-on-errors feature
- default implementation writes error and stack trace to FILE* stream, specified in userdata, it can be found in sgs_ctx.c


# sgs_Printf [function]

== int sgs_Printf( sgs_Context* C, int type, const char* what, ... )
=== prepares and prints the error specified

- `type` is the output code (SGS_WARNING, SGS_ERROR etc.)
- `what` is the error text
-- additional function name prefix can be specified with @sgs_FuncName or the SGSFN/SGSBASEFN macros
- `what`, the function name prefix (if set) and the variable arguments are passed to a vsprintf-like function so printf syntax rules apply
- function always returns 0 to be compatible with most error handling cases in C functions: "return sgs_Printf( ... );"


# sgs_HasFuncName [function]

== int sgs_HasFuncName( sgs_Context* C )
=== checks if the currently executed function (last stack frame) has a name literal set


# sgs_FuncName [function]

== void sgs_FuncName( sgs_Context* C, const char* fnliteral )
=== sets the function name string for the currently executed function (last stack frame)

- the argument is expected to stay alive for the duration of the function call
-- this makes string literals safe for the call, everything else should be avoided


# SGSFN [function alias]

== void SGSFN( const char* fnliteral )
=== sets the function name string, more info at @sgs_FuncName

- alias for `sgs_FuncName( <implicit> C, fnliteral )`


# SGSBASEFN [function alias]

== void SGSBASEFN( const char* fnliteral )
=== sets the function name string if it hasn't already been set for the function

- alias for `if( !sgs_HasFuncName( <implicit> C ) ) sgs_FuncName( <implicit> C, x )`


# sgs_SetHookFunc [function]

== void sgs_SetHookFunc( sgs_Context* C, sgs_HookFunc func, void* ctx )
=== sets the hook function and user data pointer

- hook function is called on function entry, exit and instruction change events
- setting a new hook function disables the one that was set before (if any)


# sgs_GetHookFunc [function]

== SGSBOOL sgs_GetHookFunc( sgs_Context* C, sgs_HookFunc* outfunc, void** outctx )
=== writes the hook function and user data pointer that was set (if any), returns whether anything was written


# sgs_Memory [function]

== void sgs_Memory( sgs_Context* C, void* ptr, size_t size )
=== allocates and frees memory, as specified in arguments

- there are four possible cases that are handled by the function:
-- `ptr` != NULL, `size` != 0: `ptr` is reallocated with new size, keeping as much data as possible, new block of memory is returned
-- `ptr` != NULL, `size` == 0: `ptr` is freed, NULL is returned
-- `ptr` == NULL, `size` != 0: a new block of memory is allocated and returned
-- `ptr` == NULL, `size` == 0: nothing is done, NULL is returned


# memory allocation macros [macros]

== Memory allocation macros
=== these macros allow slightly simplified handling of memory

- `sgs_Malloc( C, size )`: allocates the memory (alias to `sgs_Memory( C, NULL, size )`)
- `sgs_Free( C, ptr )`: frees the memory (alias to `sgs_Memory( C, ptr, 0 )`)
- sgs_Realloc: alias to sgs_Memory
- the following macros expect that the variable sgs_Context* C is in the scope
-- `sgs_Alloc( what )`: allocates enough memory to fit the specified type `what`
-- `sgs_Alloc_n( what, n )`: allocates enough memory to fit `n` instances of the specified type `what`
-- `sgs_Alloc_a( what, app )`: allocates enough memory to fit the specified type `what` and `app` more bytes
-- `sgs_Dealloc( ptr )`: frees the memory
- all of these functions, including sgs_Memory, work on the same heap, thus they are interchangeable


# <<<


# Information retrieval/control interface [info]
# >>>


# sgs_CodeString [function]

== const char* sgs_CodeString( int type, int val )
=== returns a string for the enumeration `type` value `val`

- there are 4 enumerations to have value names returned for:
-- SGS_CODE_ER: error codes (SGS_ERROR, SGS_WARNING, ...)
-- SGS_CODE_VT: variable types (SGS_VT_BOOL, SGS_VT_FUNC, ...)
-- SGS_CODE_OP: VM instructions (SGS_SI_PUSH, SGS_SI_FORPREP, ... [internal])
-- SGS_CODE_OI: object interface function types (SGS_OP_GETINDEX, SGS_OP_GCMARK, ...)


# sgs_Abort [function]

== SGSRESULT sgs_Abort( sgs_Context* C )
=== stops execution of current SGS functions up to the last C function in the stack, excluding the current

=== error codes
- SGS_ENOTFND: last or next to last function in the stack was not a SGS function


# sgs_Stat [function]

== SGSMIXED sgs_Stat( sgs_Context* C, int type )
=== returns or prints information about state of SGScript VM

- the following `type` values are supported:
-- SGS_STAT_VERSION: returns the version number of the VM
-- SGS_STAT_APIVERSION: returns the API version numver of the VM
-- SGS_STAT_OBJCOUNT: returns the number of objects created in the VM
-- SGS_STAT_MEMSIZE: returns the number of bytes allocated through this SGScript context
-- SGS_STAT_NUMALLOCS: returns the number of memory allocations (incremented on each alloc/realloc)
-- SGS_STAT_NUMFREES: returns the number of memory frees (incremented on each free/realloc)
-- SGS_STAT_NUMBLOCKS: number of memory blocks currently allocated (incremented on alloc, decremented on free)
-- SGS_STAT_DUMP_STACK: prints all of the variables in the stack
-- SGS_STAT_DUMP_GLOBALS: prints all variables in the global dictionary
-- SGS_STAT_DUMP_OBJECTS: prints all objects in the context
-- SGS_STAT_DUMP_FRAMES: prints all functions in the call stack
-- SGS_STAT_DUMP_STATS: dump some info about memory and objects

- tips:
-- compare return value of SGS_STAT_VERSION against SGS_VERSION_INT if the code is version-sensitive
-- compare return value of SGS_STATE_APIVERSION against SGS_API_VERSION if dynamic loading is used and multiple versions should be supported


# sgs_Cntl [function]

== int32_t sgs_Cntl( sgs_Context* C, int what, int32_t val )
=== modifies the state of the VM or returns info about it

- the following `what` values are supported:
-- SGS_CNTL_STATE: sets the new compilation state from `val`, returns the previous value
-- SGS_CNTL_GET_STATE: returns the currently set compilation state
-- SGS_CNTL_MINLEV: sets the new minimum error level from `val`, returns the previous value
-- SGS_CNTL_GET_MINLEV: returns the currently set minimum error level
-- SGS_CNTL_ERRNO: if `val` is true, sets internal errno to 0, otherwise - to `errno`, returns the previous value
-- SGS_CNTL_SET_ERRNO: sets internal errno to `val`, returns the previous value
-- SGS_CNTL_GET_ERRNO: returns the currently set internal errno
- everything else does nothing and returns 0


# sgs_GetFramePtr [function]

== sgs_StackFrame* sgs_GetFramePtr( sgs_Context* C, int end )
=== returns a call stack frame pointer

- if `end` is not 0, pointer to topmost frame is returned, otherwise a pointer to first frame is returned


sgs_Errno [function (inline)]

== int sgs_Errno( sgs_Context* C, int clear )
=== copies errno to internal errno value if `clear` is not 0, otherwise internal errno value is set to 0, returns `clear`

- used with a boolean expression and chaining to set errno if the expression returned false, like this:
-- `sgs_PushBool( C, sgs_Errno( C, rename( a, b ) == 0 ) )`


# sgs_SetErrno [function alias]

== int sgs_SetErrno( sgs_Context* C, int err )
=== sets a specific value `err` to the internal errno variable

- alias to `sgs_Cntl( C, SGS_CNTL_SET_ERRNO, err )`


# sgs_GetLastErrno [function alias]

== int sgs_GetLastErrno( sgs_Context* C )
=== returns the currently set internal errno variable

- alias to `sgs_Cntl( C, SGS_CNTL_GET_ERRNO, 0 )`


# <<<


# Interface implementation [info]
# >>>


# Functions [info]

A C function has the type `int CFunc( sgs_Context* )`. It receives the context that called it and must return the number of return values pushed on stack.

=== Conventions

There are no forced courses of action beyond this point. However, to simplify development, some conventions were established and are used throughout the standard library and are suggested to follow.

==== General structure
- the usage of SGS_CTX in argument list is suggested to enable the use of certain macros that assume the availability of `sgs_Context* C`
- there are no restrictions on function names, however it helps to mark the scripting engine functions with a common prefix and if they wrap a native function, including the name of the wrapped function is suggested

==== Argument loading
- prefer using sgs_LoadArgs, followed by sgs_LoadArgsExt, followed by the sgs_Parse***/sgs_Is***/sgs_ItemType(Ext)/... functions together with ArgError function family for error handling

==== Error handling
- it is preferred to do most of it at the beginning, before custom allocations (VM stack doesn't count here), where it is possible to just `return sgs_Printf( C, SGS_WARNING, "Error message" )`
- SGS_WARNING is for non-fatal errors, SGS_ERROR is for errors that make it impossible to continue (severe, undoubted logical errors fall into this category)
- on error, functions should return nothing or null

A typical function

    int sgsfunc_sample( SGS_CTX )
    {
        sgs_Int num;
        char* str;
        char* buf;
        sgs_SizeVal bufsize;
        
        if( !sgs_LoadArgs( C, "ism", &num, &str, &buf, &bufsize ) )
            return 0;
        
        if( bufsize == 0 )
            return sgs_Printf( C, SGS_WARNING, "buffer cannot be empty" );
        // sgs_Printf always returns 0
        
        // .. do something with the passed arguments ..
        
        // anything can be returned ..
        // .. but in this case, we want to say ..
        // .. that the action was successful
        sgs_PushBool( C, 1 );
        return 1;
    }


# Object interface [info]

Every interface function has the type `int ObjCallback ( sgs_Context* C, sgs_VarObj* data, int arg )`. Not every of them has to be implemented (none of them are required) but for all non-pointer objects it helps to have at least one of them.

Even if pointer objects don't require interface functions, it is suggested all objects of same type still have their own interface pointer for the type for identification.

Interface is an array of void* that contains a list of pairs, where in each the first value is a SGS_OP_*** constant and the second is an object interface function, and one SGS_OP_END value at the end. This is how interfaces are usually defined in code:

    void* object_interface[] =
    {
        SGS_OP_DESTRUCT, object_destruct,
        SGS_OP_GETINDEX, object_getindex,
        SGS_OP_END
    };

=== SGS_OP_DESTRUCT - destruction callback

**Called** before the object is about to be destroyed. Argument = 0/1, whether to destroy child objects.

**Argument** specifies whether object is destroyed via GC (if argument == 0) and cannot allow the destruction of other objects to happen at the moment.

**Stack frame** contains no additional data.

To ensure safe destruction of owned variables, call sgs_ReleaseOwned and pass the argument.

=== SGS_OP_GETINDEX - index/property retrieval callback

**Called** on A[B] and A.B reads in SGScript, as well as the PushIndex/PushProperty/Path function families in the C API.

**Argument** specifies whether a property is required (if argument != 0).

**Stack frame** contains one value: index (int or string).

Special error codes: SGS_ENOTFND if the specified index/property was not found.

=== SGS_OP_SETINDEX - index/property setting callback

**Called** on A[B] and A.B writes in SGScript, as well as the StoreIndex/StoreProperty/Path function families in the C API.

**Argument** specifies whether a property is to be set (if argument != 0).

**Stack frame** contains two values: index (int or string) and value (any type).

Special error codes: SGS_ENOTFND - the specified index/property was not found, SGS_EINVAL - the specified value could not be used.

=== SGS_OP_CONVERT - conversion callback

Depending on the argument, it is **called** by different sources and require different return values:
- type conversion: to*** function families and other conversion triggers (like operators) in SGScript and the Convert/Get/To function families in the C API, require a value of the right type.
- SGS_CONVOP_CLONE: called on clone/sgs_Clone, should return an exact copy of the same object
- SGS_CONVOP_TOTYPE: called on typeof/sgs_Typeof, should return a string containing the type name
- SGS_CONVOP_TOITER: called on foreach/sgs_PushIterator, should return an object with the SGS_OP_GETNEXT callback added

**Argument** specifies the data to return.

**Stack frame** contains no additional data.

Special error codes: SGS_ENOTSUP - specified conversion is not supported.

=== SGS_OP_SERIALIZE - serialization callback

**Called** by serialize/sgs_Serialize. Requires no data but expects that sgs_Serialize/sgs_SerializeObject is successfully called once. In the case of sgs_SerializeObject, the necessary number of sgs_Serialize calls can be made before it.

**Argument** is not used.

**Stack frame** contains no additional data.

=== SGS_OP_DUMP - debug dump callback

Called by printvar/dumpvar function families in SGScript and sgs_DumpVar in the C API. Requires a string to be passed on the stack.

**Argument** specifies the remaining depth of dump - if owned variables are to be dumped, they should have sgs_DumpVar called with reduced depth to avoid dumping the whole structure (sgs_DumpVar with maxdepth <= 0 returns "...")

**Stack frame** contains no additional data.

=== SGS_OP_GCMARK - garbage collector marking callback

**Called** by gc_collect in SGScript and sgs_GCMark/sgs_GCExecute in the C API. Requires no data but expects that sgs_GCMark is called on all of the owned variables.

**Argument** is not used.

**Stack frame** contains no additional data.

=== SGS_OP_GETNEXT - iterator control callback

**Called** by foreach in SGScript and sgs_IterAdvance/sgs_IterPushData in the C API.

**Argument** specifies behavior flags:

- if argument == 0, iterator's position must be increased by one step and the return value must contain whether iterator has not reached end (positive value if so, otherwise - 0) or an error if callback has failed
- otherwise, callback must push the data required (if SGS_GETNEXT_KEY is set, the key, and if SGS_GETNEXT_VALUE is set - the value, in exactly that order)

**Stack frame** contains no additional data.

=== SGS_OP_CALL - the "function call" callback

**Called** when an object is used like a function (function call in SGScript or Call function family in the C API).

**Argument** is not used.

**Stack frame** contains the arguments and can possibly be expanded by one unit with sgs_Method if a method call is done.

=== SGS_OP_EXPR - expression callback

**Called** when an object is used in one of the following expressions, specified by the argument:

- SGS_EOP_ADD: addition (+, +=), stack contains both operands
- SGS_EOP_SUB: subtraction (-, -=), stack contains both operands
- SGS_EOP_MUL: multiplication (*, *=), stack contains both operands
- SGS_EOP_DIV: division (/, /=), stack contains both operands
- SGS_EOP_MOD: modulo (%, %=), stack contains both operands
- SGS_EOP_COMPARE: comparison (<, <=, >, >=, ==, !=, ===, !==), stack contains 2 arguments, expects integer/real value: >0 if A > B, <0 if A < B, =0 if A = B
- SGS_EOP_NEGATE: negation (-), stack contains the object


# Interaction with the environment [info]

Most operations are directed towards the scripting engine, that is - environment makes a function call and scripting engine handles it. For everything else, there are callbacks.

=== Memory allocation
- sgs_MemFunc must be specified in creation of the scripting engine context
- sgs_MemFunc (re)allocates and frees memory
- unlike realloc, if size = 0, this function must return NULL
- sgs_DefaultMemFunc is the sample implementation
- the expected behavior is same as for @sgs_Memory()

=== Output
- sgs_PrintFunc and sgs_OutputFunc are responsible for piping the outputs to their destinations
- they can be set at any moment after the creation of the scripting engine context
- sgs_PrintFunc takes the following arguments:
-- void* data - the user data pointer
-- sgs_Context* C - the scripting engine context
-- int type - the debug type (SGS_INFO, SGS_WARNING etc.)
-- const char* message - the debug message
- sgs_OutputFunc takes the following arguments:
-- void* data - the user data pointer
-- sgs_Context* C - the scripting engine context
-- const void* ptr - the data to write
-- sgs_SizeVal size - the size of data to write

=== Execution notifications
- sgs_HookFunc must be set to retrieve events of that kind
- it can be set at any moment after the creation of the scripting engine context
- sgs_HookFunc takes the following arguments:
-- void* data - the user data pointer
-- sgs_Context* C - the scripting engine context
-- int event - the event that occured, can be one of these values:
--- SGS_HOOK_ENTER - function was entered
--- SGS_HOOK_EXIT - function was exited
--- SGS_HOOK_STEP - instruction is about to be executed


# <<<


# Commonly required advanced tasks [info]

=== Method handling

- version 1: plain method handling:

    sgs_FuncName( C, "<object>.<method>" );
    if( !sgs_Method( C ) || !sgs_IsObject( C, 0, Object_interface_pointer ) )
        return sgs_ArgErrorExt( C, 0, 1, "<object>", "" );
    ObjectDataStruct* data = (ObjectDataStruct*) sgs_GetObjectData( C, 0 );


- version 2: Method + function handling (function that can be called as a method too)

    int method_call = sgs_Method( C );
    sgs_FuncName( C, method_call ? "<object>.<method>" : "<object_function>" );
    if( !sgs_IsObject( C, 0, Object_interface_pointer ) )
        return sgs_ArgErrorExt( C, 0, method_call, "<object>", "" );
    ObjectDataStruct* data = (ObjectDataStruct*) sgs_GetObjectData( C, 0 );


# <<<


# Standard library reference [info]
# >>>


# Core library [info]

This library is loaded on initialization and contains the functions and constants necessary to do primary actions:

- execution of additional scripts
- creating and using array, class, dict, closure
- converting between variables
- serialization / deserialization
- operation control
- error handling and throwing
- global environment modification
- standard input / output
- data debugging

# >>>


# array [function]

== array( ... )
=== returns an array, containing the arguments

- similar to the array literal, though somewhat limited

    array( "5", 6, 7.0 ) // same as ["5",6,7.0]


# dict [function]

== dict( [key, value, ...] )
=== returns a 'dict' (dictionary/hash table) object, containing the even arguments mapped to respective previous arguments

- if no arguments are passed, an empty dictionary is returned
- if an even number of arguments is passed, function returns null and emits a warning
- all even arguments must be strings or convertible to strings

    dict( "name", "John", "phone", 1234567890 ); // same as { name = "John", phone = 1234567890 }


# class [function]

== class( first, second )
=== returns a class object with `first` set as the primary data source and `second` set as the secondary/backup data source

- both arguments accept all kinds of variables but it's generally preferred to use only dicts / special objects
- refer to @CLASSES for more information on how class objects work and how to use them

    someCommonInterface = { printdata = function(){ print( this.data ); } };
    c = class( { data = "5" }, someCommonInterface );
    c.data = "6";
    c.printdata(); // prints 6


# closure [function]

== closure( callable, data )
=== returns a closure object with `callable` set as the callable variable and `data` set as the first argument for the closure call

- second argument accepts all kinds of variables, first requires a variable that can be called (SGScript function / C function / object with OP_CALL interface function defined)
- refer to @CLOSURES for more information on how closure objects work and how to use them

    counter = closure( function( data ){ return data[0]++; }, [0] );
    print( counter() ); print( counter() ); // prints "01"


# array_filter [function]

== array_filter( array[, callable] )
=== return an array with the items that convert to boolean 'true', optionally preprocessed by a callable

- two arguments are passed to the callable: value, index

    array_filter([ 0, 1, 2, 3 ]); // returns [1,2,3]


# array_process [function]

== array_process( array, callable )
=== return an array with the items passed through a callable

- two arguments are passed to the callable: value, index


# dict_filter [function]

== dict_filter( dict[, callable] )
=== return a dict with the items that convert to boolean 'true', optionally preprocessed by a callable

- two arguments are passed to the callable: value, key

    dict_filter({ a = 0, b = 1 }); // returns {b=1}


# dict_process [function]

== dict_process( dict, callable )
=== return a dict with the items passed through a callable

- two arguments are passed to the callable: value, key


# isset [function]

== isset( var, string key )
=== returns whether a property named `key` is accessible (exists) in variable `var`

    x = { a = 5 };
    isset( x, "a" ); // returns 'true'
    isset( x, "b" ); // returns 'false'
    isset( print, "thiscall" ); // returns 'true' -- works with built-in special properties too


# unset [function]

== unset( dict var, string key )
=== removes an entry named `key` from the dictionary `var`


# clone [function]

== clone( var )
=== creates a one-reference copy of the variable `var` or returns null and emits a warning on failure

- variables that are passed by value (null, bool, int, real, cfunc) or strings/functions are returned as-is, since for value types all copies are same and strings/functions are immutable

    x = { a = 5 };
    y = clone( x );
    z = x;
    x.a = 6;
    print( y.a ); // prints "5"
    print( z.a ); // prints "6"


# get_keys [function]

== get_keys( iterable var )
=== returns an array of keys found in the iterable object `var` or returns null and emits a warning on failure

- `var` must be an iterable object (has interface OP_CONVERT defined and successfully handles a CONVOP_TOITER request) - such objects are `array`, `dict` and `io_dir`

    get_keys( [5,7,0] ); // returns [0,1,2]
    get_keys( {b=5,a=2} ); // returns ["b","a"]


# get_values [function]

== get_values( iterable var )
=== returns an array of values found in the iterable object `var` or returns null and emits a warning on failure

- `var` must be an iterable object (has interface OP_CONVERT defined and successfully handles a CONVOP_TOITER request) - such objects are `array`, `dict` and `io_dir`

    get_values( [5,7,0] ); // returns [5,7,0]
    get_values( {b=5,a=2} ); // returns [5,2]


# get_concat [function]

== get_concat( iterable var, iterable var1, ... )
=== returns an array of values found in all iterable objects passed to the function or returns null and emits a warning on failure

    get_concat( [1,2], {a="5",b=8} ); // returns [1,2,"5",8]


# get_merged [function]

== get_merged( iterable var, iterable var1, ... )
=== returns a dict of all key-value pairs found in all iterable objects passed to the function or returns null and emits a warning on failure

    get_merged( [1,2], [3], {a="4"} ); // return {0=3,1=2,a="4"}


# tobool [function]

== tobool( var )
=== returns a boolean, generated from variable `var` using the @conversion rules

- this function is equivalent to @sgs_GetBool / @sgs_ToBool in the C API

    tobool( 5 ); // returns 'true'
    tobool( "" ); // returns 'false'


# toint [function]

== toint( var )
=== returns an integer, generated from variable `var` using the @conversion rules

- this function is equivalent to @sgs_GetInt / @sgs_ToInt in the C API

    toint( 5.4 ); // returns 5
    toint( "0xff" ); // returns 255


# toreal [function]

== toreal( var )
=== returns a real value, generated from variable `var` using the @conversion rules

- this function is equivalent to @sgs_GetReal / @sgs_ToReal in the C API

    toreal( 5 ); // returns 5.0
    toreal( "3e+2" ); // returns 300.0
    toreal( "0xff" ); // returns 255.0


# tostring [function]

== tostring( var )
=== returns a string value, generated from variable `var` using the @conversion rules

- this function is equivalent to @sgs_ToString in the C API

    tostring( 5 ); // returns "5"
    tostring( { "a" = "b" } ); // returns "{a=b}"


# typeof [function]

== typeof( var )
=== returns the type name of variable `var`, as string

- this function is equivalent to @sgs_Typeof in the C API

    typeof( 5 ); // returns "real"
    typeof( [] ); // returns "array"


# typeid [function]

== typeid( var )
=== returns the first 4 bits of the variable `var` type flags, as `int`

- returns one of the values mapped to VT_NULL/VT_BOOL/VT_INT/VT_REAL/VT_STRING/VT_FUNC/VT_CFUNC/VT_OBJECT
- this function is equivalent to @sgs_ItemType in the C API

    typeid( 5 ) == VT_REAL; // returns 'true'
    typeid( [] ); // returns 0x80 / VT_OBJECT


# typeflags [function]

== typeflags( var )
=== returns the type flags of the variable `var`, as `int`

- returns a bitfield, consisting of many different VT_* and VTF_* value combos, matching one of VTC_* values
- this function is equivalent to @sgs_ItemTypeExt in the C API

    typeflags( 5 ) == VTC_REAL; // returns 'true'
    typeid( [] ) & VT_OBJECT != 0; // returns 'true'
    typeid( "" ) & VTF_NUMERIC != 0; // returns 'false'


# is_numeric [function]

== is_numeric( var )
=== returns whether the variable `var` is numeric - one of bool/int/real or a numeric string

- all types that can always be converted to numbers are considered numeric, with two exceptions:
-- convertible objects are not numeric since validation requires an interface call and unnecessary interface calls cannot be made
-- null value is considered to be the lack of a better value, thus it cannot be considered valid, even though it always maps implicitly to the integer 0

    is_numeric( 12.124 ); // returns true
    is_numeric( "what" ); // returns false


# is_callable [function]

== is_callable( var )
=== returns whether the variable `var` is callable - a function (func/cfunc) or an object with OP_CALL defined

- this function is equivalent to @sgs_IsCallable in the C API

    is_callable( print ); // returns 'true'
    is_callable( closure( print, 5 ) ); // returns 'true'
    is_callable( 5 ); // returns 'false'


# loadtypeflags [function]

== loadtypeflags()
=== sets the globals beginning with VTF_ and VTC_

- since these features are expected to be rarely used, they're set to be loaded on-demand, not on startup

    isset( _G, "VTF_NUM" ); // returns 'false'
    loadtypeflags();
    isset( _G, "VTF_NUM" ); // returns 'true'


# print, println, printlns [functions]

== print( ... ), println( ... ), printlns( ... ),
=== passes all arguments, converted to strings, to the @output callback
- print passes arguments without modifications
- println passes a newline character after all variables
- printlns passes a newline character after each variable

    print( 5, "x" ); // prints "5x"
    println( 5, "x" ); // prints "5x\n"
    printlns( 5, "x" ); // prints "5\nx\n"


# printvar_ext [function]

== printvar_ext( var, int maxdepth = 5 )
=== passes a dump of the variable (informative string version) to the @output callback, allowing to optionally specify the maximum depth of the dump (how deep it is allowed to look for sub-variables)

    printvar_ext( 5 ); // prints "real (5)"
    printvar_ext( "wat" ); // prints "string [3] "wat""
    printvar_ext( [{a=[{}]}], 2 ); /* prints:
    object (003C5F90) [0] array (1)
    [
      object (003C60A8) [1] dict (1)
      {
        ...
      }
    ]
    */


# printvar [function]

== printvar( var, ... )
=== same as a list of printvar(var); calls for each argument

- refer to @printvar_ext() for more info


# read_stdin [function]

== read_stdin( bool all = false )
=== reads from the standard input

- if `all` is set to 'true', all standard input is read up to EOF (useful for piped input)
- if `all` is set to 'false' or not set at all, input is read up to (and excluding) the next newline character

    print "Name: "; name = read_stdin(); // waits for user input
    process( read_stdin(true) ); // loads all piped input


# ftime [function]

== ftime()
=== returns a value that is increased by a total of 1 each second (time), as real

- guaranteed to offer sub-second precision unless stated otherwise for any specific platform

    start = ftime();
    do_something_big();
    println( "That took " $ ftime() - start $ " seconds." );


# rand [function]

== rand()
=== returns a random 'int' value in the range [0;RAND_MAX) - from 0, inclusive, to RAND_MAX, exclusive


# randf [function]

== randf()
=== returns a random 'real' value in the range [0;1) - from 0, inclusive, to 1, exclusive


# srand [function]

== srand( int seed )
=== specify a different seed value for the built-in pseudo-random number generator

    srand( 5 ); // restart the generator with the value specified
    srand( ftime() ); // restart the generator depending on the second the code was executed


# pcall [function]

== pcall( callable func[, callable errh ])
=== calls the callable `func`, hiding internal errors from the caller or optionally passing them to callable `errh`

- `errh` error handler is called with two arguments - `int error_type, string message` - and expected to return 0-1 arguments ([int])
- error handler must return 0/null/nothing if the error has been successfully processed or the new error type otherwise
-- errors thrown inside the handler will not be caught so any error can be transformed to any other
-- an empty function behaves the same way as `pcall` without function

    include "string";
    
    function handler( type, msg )
    {
        if( string_find( msg, "not found" ) !== null )
            sys_print( type, "nooooooooooo" );
    }
    
    function handler2( type, msg )
    {
        if( string_find( msg, "not found" ) !== null )
            return SGS_ERROR;
    }
    
    pcall(function(){ print x; }); // nothing
    pcall(function(){ print x; }, handler ); // renamed warning
    pcall(function(){ print x; }, handler2 ); // changed type to error


# assert [function]

== assert( var condition[, string message] )
=== if condition evaluates to 'false', emits an error "assertion failed" or if message is defined, "assertion failed: <message>"

    assert( text, "text was not defined" );


# eval [function]

== eval( string code )
=== returns the result of evaluating the passed `code` string as SGScript code

- this function is equivalent to @sgs_EvalBuffer/@sgs_EvalString in the C API

    eval("print 5;"); // prints 5


# eval_file [function]

== eval_file( string filename )
=== returns the result of evaluating the file pointed to by `filename` as SGScript code

- this function is equivalent to @sgs_EvalFile in the C API

    eval_file("myfile.sgs"); // ???


# include_library [function]

== include_library( string lib[, bool override ] )
=== loads the global variables of the specific library `lib` in the state, returns success, as `bool`, emits a warning on failure

- lib must be one of 'fmt', 'io', 'math', 'os', 'string'
- if `override` is specified, library will be reloaded even if it was already loaded before
- this function is equivalent to the sgs_LoadLib_* functions in the C API

    printvar( sin ); // warning, null
    include_library( "math" );
    printvar( sin ); // C function


# include_file [function]

== include_file( string file[, bool override ] )
=== executes the file pointed to by `file`, returns success, as `bool`, emits a warning on failure

- this function does NOT check include paths (SGS_PATH)
- if `override` is specified, file will be reloaded even if it was already loaded before
- this function is equivalent to @sgs_ExecFile in the C API

    include_file( "something.sgs" ); // loads something
    include_file( "something.sgs" ); // does not load it again
    include_file( "something.sgs", true ); // loads it again


# include_shared [function]

== include_shared( string file[, bool override ] )
=== runs the shared library pointed to by `file`, returns success, as `bool`, emits a warning on failure

- `file` must be available according to the platform-specific rules of dynamic libraries (shared objects)
- the library must contain a 'sgscript_main' function that will be called on initialization
- if `override` is specified, file will be reloaded even if it was already loaded before

    include_shared( "sgsjson.dll" ); // load the JSON library DLL on Windows


# include [function]

== include( string file[, bool override ] )
=== tries to load a library or a file according to the include path

- the order of actions:
-- first, a library load is attempted
-- on failure, a file is looked for by every entry of the sys_include_path variable (? - the file replacement symbol, | - file directory replacement symbol, ; - separator)
-- if file is not found, everything stops
-- if file is found, first - a library load is attempted, on failure - bytecode & source code loading
- this function is also available as a replicating statement 'include' (ex. 'include "fmt", "io";' works the same way as include("fmt"); include("io");)


# import_cfunc [function]

== import_cfunc( string file, string funcname )
=== retrieves the `funcname` function of the shared library `file`, returns success, as `bool`, emits a warning on failure

! Do not call 'sgscript_main' using this function! That function has different return value semantics so at best, something will work, a warning could be emitted and the worst case is that something will crash.

- `file` must be available according to the platform-specific rules of dynamic libraries (shared objects)

    import_cfunc( "mydll.dll", "someSGScriptFunc" )();


# sys_curfile [function]

== sys_curfile()
=== returns the path of the file (as passed on load) that contains the currently executed code or `null` if the file cannot be determined (eval, C functions)

    // a.sgs
    print( sys_curfile() ); // prints "a.sgs"
    // b.sgs
    include "a.sgs";


# sys_curfiledir [function]

== sys_curfiledir()
=== returns the directory path of the file (as passed on load) that contains the currently executed code or `null` if the file cannot be determined (eval, C functions)

    // ext/a.sgs
    print( sys_curfiledir() ); // prints "ext"
    // a.sgs
    print( sys_curfiledir() ); // prints "."
    // b.sgs
    include "ext/a.sgs", "a.sgs";


# sys_print [function]

== sys_print( int code, string message )
=== passes a message to the internal messaging system (one that's commonly used to report errors and warnings)

! Different codes can be handled differently by the system. By default, SGS_ERROR code will stop execution and return to C code as soon as possible.

- `code` is the code to use to pass the message (ex. SGS_INFO, SGS_WARNING, SGS_ERROR)


# INFO [function]

== INFO( string message )
=== passes a message to the internal messaging system

- the name of this function is written in all caps to avoid shadowing by a common variable name
- works exactly like `sys_print( SGS_INFO, message )`


# WARNING [function]

== WARNING( string message )
=== passes a message to the internal messaging system

- the name of this function is written in all caps for consistency with the other two
- works exactly like `sys_print( SGS_INFO, message )`


# ERROR [function]

== ERROR( string message )
=== passes a message to the internal messaging system

! By default, SGS_ERROR code (the one this function uses internally) will stop execution and return to C code as soon as possible.

- the name of this function is written in all caps to avoid shadowing by a common variable name
- works exactly like `sys_print( SGS_INFO, message )`


# sys_abort [function]

== sys_abort()
=== stops execution and returns to C code as soon as possible

- this function is equivalent to @sgs_Abort in the C API

    sys_abort();
    print( 5 ); // this line is not reached


# app_abort [function]

== app_abort()
=== calls the abort() function of the C standard library (crashes the application)


# app_exit [function]

== app_exit( code = 0 )
=== calls the exit() function of the C standard library (exits the application)


# sys_replevel [function]

== sys_replevel([ level ])
=== returns the current reported error level and optionally sets a new one

! The effects of this function are not reverted automatically at any moment (unless implemented manually with hooks).

    old_level = sys_replevel( SGS_ERROR ); // report only errors or worse
    magic = calculate_magic(); // any warnings are never processed at this point
    sys_replevel( old_level ); // restore the old reported level


# sys_stat [function]

== sys_stat( code )
=== prints info about virtual machine state, everything is implementation-defined

- accepted codes are the same as for @sgs_Stat, which this function is equivalent to

    sys_stat( 11 ); // dumps all globals


# errno [function]

== errno( as_string = false )
=== returns the last relevant error number for the C standard library, as an integer or a string if `as_string` is set

- last relevant error number is defined by @sgs_Errno/@sgs_SetErrno C API functions

    data = io_file_read( "doesnotexist" ); // file that does not exist
    print errno(); // prints 2
    print errno(true); // prints "No such file or directory" on Windows


# errno_string [function]

== errno_string( int code )
=== returns the error string for the given code

- errno_string(errno()) is equivalent to errno(true)

    print errno_string(2); // prints "No such file or directory" on Windows


# errno_value [function]

== errno_value( string key )
=== returns the number for the error key (for "ENOENT" it would return 2)

- this function might be a bit slow considering that it currently does not use any extended lookup systems, such as hash tables

    data = io_file_read( "doesnotexist" );
    if( errno() == error_string("ENOENT") )
        println( "file does not exist" );


# dumpvar_ext [function]

== dumpvar_ext( var, int depth = 5 )
=== similar to @printvar_ext() but returns the dump instead of printing it

- this function is equivalent to @sgs_DumpVar in the C API

    sys_error( SGS_INFO, "Extended variable info:\n" $ dumpvar(data) );


# dumpvar [function]

== dumpvar( ... )
=== similar to @printvar() but returns the dumps, concatenated, instead of printing them


# gc_collect [function]

== gc_collect()
=== runs the garbage collector on the virtual machine, waiting until it has finished

- returns the reduction in objects or false on failure

    a = [];
    a.push(a); // creates a circular dependency
    a = null; // a is not actually freed
    gc_collect(); // a is freed now


# serialize [function]

== serialize( var )
=== converts the variable to a byte buffer (string), containing the serialized data that can be recreated with @unserialize() or returns null and emits a warning on failure

- C functions and objects without OP_SERIALIZE implemented cannot be serialized

    data = serialize({ name = "A", info = "B" });
    print data; // prints random-ish garbage
    print unserialize(data); // prints {name=A,info=B}


# unserialize [function]

== unserialize( string data )
=== recreates a variable from the buffer with serialized data or returns null and emits a warning on failure

- this function will internally call global object creation functions specified in the data, so they must be defined and the state could change in the process
- for more info on serialization in SGScript, refer to @<Serialization in SGScript>

    data = serialize({ name = "A", info = "B" });
    print data; // prints random-ish garbage
    print unserialize(data); // prints {name=A,info=B}


# SGS_*** [constants]

== SGS_INFO, SGS_WARNING, SGS_ERROR
=== defined to the values of the C macros, respectively 100, 200 and 300


# VT_*** [constants]

== VT_NULL, VT_BOOL, VT_INT, VT_REAL, VT_STRING, VT_FUNC, VT_CFUNC, VT_OBJECT
=== these constants are defined to the values of the C macros (with the prefix "SVT_" in C) and can be compared with the values returned in @typeid() or @typeflags()


# _G [superglobal]

== A hard-coded global value that points to the global dictionary. Can be used to access non-identifier globals and change the gloal dictionary.

    _G["$diff"] = 5; // no way to access this via usual globals
    _G = {}; // global value dictionary is changed, previous functions are lost unless stored somewhere


# array [object]

- read-only properties
-- [int] size
-- [int] capacity
-- [var] first (valid if array is not empty, otherwise a warning is thrown and 'null' is returned)
-- [var] last (similar to 'first')
-- [cfunc] push
-- [cfunc] pop
-- [cfunc] shift
-- [cfunc] unshift
-- [cfunc] insert
-- [cfunc] erase
-- [cfunc] clear
-- [cfunc] reverse
-- [cfunc] resize
-- [cfunc] reserve
-- [cfunc] sort
-- [cfunc] sort_custom
-- [cfunc] sort_mapped
-- [cfunc] find
-- [cfunc] remove
-- [cfunc] unique
-- [cfunc] random
-- [cfunc] shuffle
- other features:
-- read/write integer index
-- full content dump
-- tostring = quick content dump
-- tobool = size != 0
-- iterator
-- cloning
-- serialization
-- GC-safe
-- type identification (returns the string "array")


# array.push [method]

== array.push( ... )
=== appends the variables passed to the end of array in the same order, returns the array for chaining

    a = [ 5 ];
    a.push( 6, 7 ).push( 8 ); // a = [5,6,7,8]


# array.pop [method]

== array.pop()
=== removes one item from the end of array or emits a warning if there are no items in the array, returns the removed item

    a = [ 5 ];
    a.pop(); // array is empty now
    a.pop(); // warning: "array is empty, cannot pop"


# array.shift [method]

== array.shift()
=== removes one item from the beginning of array or emits a warning if there are no items in the array, returns the removed item

    a = [ 5, 6 ];
    a.shift(); // a = [6], returned 5


# array.unshift [method]

== array.unshift( ... )
=== prepends the variables passed to the beginning of array in the same order, returns the array for chaining

    a = [ 5 ];
    a.unshift( 6, 7 ); // a = [6,7,5] now


# array.insert [method]

== array.insert( int pos, ... )
=== inserts the variables passed (all arguments after first) to the position specified in the array or emits a warning on failure (index out of bounds), returns the array for chaining

- `pos` accepts both positive and negative values, the meaning is "which value to insert before"
-- negative values are converted to positive ones by adding (<size> + 1) to them
-- beginning of array can be inserted to using position 0 or (- <size> - 1)
-- end of array can be inserted to using position <size> or -1

    a = [ 5, 7 ];
    a.insert( 1, 6 ); // inserts 6 at position 1 (before item with index 1)
    a.insert( -1, 8 ); // appends to the end of array, a = [5,6,7,8] now


# array.erase [method]

== array.erase( int[, int] )
=== erases item or a range of items from the array, depending on the arguments passed or emits a warning on failure, returns the array for chaining

- both arguments have same index processing rules as @array.insert(), but with one difference - if both arguments are passed, after resolving (converting negative indices to positive ones, if there are any), first must be smaller than second

    a = [ 5, 6, 7, 8 ];
    a.erase( 1, 2 ); // erases all items between position 1 and 2, including; gives a = [5,8]
    a.erase( 0 ); // a = [8]


# array.part [method]

== array.part( int from[, int max ] )
=== returns a new array starting from index `from`, with the max. size `max`

- if `from` is negative, it is subtracted from the end of array
- `max` cannot be negative, everything else is allowed

    a = [ 5, 6, 7, 8 ];
    a.part( 1, 2 ); // returns [6,7]
    a.part( -5, 2 ); // returns [5]
    a.part( 3 ); // returns [8]


# array.clear [method]

== array.clear()
=== erases all items from the array, returns the array for chaining

    a = [ 1, "asd", 8 ];
    a.clear(); // a = []


# array.reverse [method]

== array.reverse()
=== reverses the order of items in the original array, returns the original array for chaining

    a = [ 1, 2, 3 ];
    b = a;
    a.reverse(); // a = [3,2,1]
    print( b ); // prints [3,2,1]


# array.resize [method]

== array.resize( int size )
=== changes the size of the array, returns the array for chaining

- `size` must be larger than or equal to 0
- if previous size was less than passed to the method, null variables are appended
- if previous size was more than passed to the method, items are popped from the end of the array
- if size was not changed, nothing else will change

    a = [ 5, 6, 7 ];
    a.resize( 5 ); // a = [5,6,7,null,null]
    a.resize( 2 ); // a = [5,6]


# array.reserve [method]

== array.reserve( int capacity )
=== reserves the space for the requested number of elements in the array, returns the array for chaining

- `capacity` must be larger than or equal to 0
- if previous capacity was less than passed to the method, capacity will be increased to the requested amount
- if previous capacity was more than or equal to what was passed to the method, nothing will change

    a = [ 5, 6, 7 ];
    a.capacity( 1 ); // nothing happens
    a.capacity( 5 ); // a.capacity = 5 and two variable additions can now happen without reallocations


# array.sort [method]

== array.sort([ bool reverse ])
=== sorts the array using the @sgs_Compare C API function for comparisons, returns the array for chaining

- if `reverse` is true, array is sorted in the reverse order

    a = [ 6, 8, 7, 5 ];
    a.sort(); // a = [5,6,7,8]


# array.sort_custom [method]

== array.sort_custom( callable[, bool reverse ] )
=== sorts the array using the callable for comparisons, returns the array for chaining

! This function is considerably slower than @array.sort or @array.sort_mapped so prefer those if performance matters.

- callable must return a number, specifying the relative order of the two passed arguments: less than 0 if first variable should be placed before second, greater than 0 if first variable should be placed after second, or 0 if it doesn't matter
- if `reverse` is true, array is sorted in the reverse order

    a = [ 6, 8, 7, 5 ];
    // this code will sort numbers into odd/even ones and in ascending order
    a.sort_custom( function(a,b){return a-b+(b%2-a%2)*1000; } ); // a = [5,7,6,8]


# array.sort_mapped [method]

== array.sort_mapped( array map[, bool reverse ] );
=== sorts the array by sorting the passed array and applying the index map to the first one, returns the array for chaining

- both arrays must have the same size, otherwise a warning is emitted
- all variables in the mapping array are interpreted as 'real' values
- if `reverse` is true, array is sorted in the reverse order

    a = [ 5, 6, 7, 8 ];
    b = [ 3, 1, 4, 2 ];
    a.sort_mapped( b ); // a = [6,8,5,7]


# array.find [method]

== array.find( var item[, bool strict[, int from ]] )
=== attempts to find `item` in array, starting from 0 or the index passed with `from`, if it exists, using basic or strict equality comparisons (depending on `strict`), returning the index or 'null' if item was not found

- if strict comparisons are enabled, variable types are also checked for equality

    a = [ 5, 6, 7, 8 ];
    a.find( "7" ); // returns 2
    a.find( "7", true ); // returns null


# array.remove [method]

== array.remove( var item[, bool strict[, bool all[, int from ]]] )
=== attepts to find and remove first or all `item` variables in array (depending on `all`), according to the rules specified in @array.find(), returning the number of removed items

    a = [ 5, 2, 6, 7, 8, 2 ];
    a.remove( "7" ); // returns 1; a = [5,2,6,8,2]
    a.remove( "6", true ); // returns 0; a remains unchanged
    a.remove( 2, false, true ); // returns 2; a = [5,6,8]


# array.unique [method]

== array.unique( bool strconv = false )
=== returns an array without duplicates, where a duplicate is a strictly equal variable or a string conversion match

- if `strconv` is true, items are converted to strings before comparison

    a = [ 5, 3, 2, 3, 2, "3" ];
    a.unique(); // returns [5,3,2,"3"]
    a.unique( true ); // returns [5,3,2]


# array.random [method]

== array.random( int num )
=== return `num` randomly chosen items from the array

- to retrieve a part of the array in random order without duplicates, @array.shuffle can be used
- items after RAND_MAX will currently not be returned


# array.shuffle [method]

== array.shuffle()
=== change the order of items in the array


# dict [object]

- features:
-- read/write string index
-- read/write string properties and integer index-via-property
-- full content dump
-- tostring = quick content dump
-- tobool = size != 0
-- iterator
-- cloning
-- serialization
-- GC-safe
-- type identification (returns the string "dict")


# class [object]

- read/write properties
-- [var] _super
- other features
-- read/write pass-through index
-- read/write pass-through properties (except string "_super")
-- full content dump
-- tobool = ENOTSUP, overridable via "__tobool"
-- toint = ENOTSUP, overridable via "__toint"
-- toreal = ENOTSUP, overridable via "__toreal"
-- tostring = "class", overridable via "__tostring"
-- cloning, overridable via "__clone"
-- type identification (returns the string "class", overridable via "__typeof")
-- overridable arithmetic/comparison operations
-- overridable object call
-- serialization
-- GC-safe


# closure [object]

- features
-- full content dump
-- tostring = "closure"
-- type identification (returns the string "closure")
-- object call to callable, using the attached first argument
-- GC-safe


# <<<


# Formatting library ("fmt") [info]

This library includes functions and objects for parsing binary and text buffers.

- binary format -- fmt_pack, fmt_unpack, fmt_pack_count, fmt_pack_size
- base64 format -- fmt_base64_encode, fmt_base64_decode
- text format -- fmt_parser, fmt_text, fmt_charcc

# >>>


# fmt_pack [function]

== fmt_pack( string fmt, ... )
=== packs the given arguments using the format `fmt` and returns the byte buffer or returns null and emits a warning on failure

- the format: character command list
-- 0-9: add a digit to multiplier
-- =/</>/@: "=" sets host byte order, "<" - little endian byte order, ">" - big endian, "@" - inverted
-- +/-: "+" - unsigned integers, "-" - signed integers
-- c/w/l/q/p: integers (c - char, 1 byte, w - word, 2 bytes, l - long, 4 bytes, q - quad-word, 8 bytes, p - pointer/size, platform-specific size of 4/8 bytes, usually)
-- f/d: floating-point numbers: "f" - single precision, "d" - double precision
-- s: string, multiplier sets length instead of count, as with other items
-- x: padding byte (does not get read or written, can be used to advance the pointer)
-- space/tab/CR/LF: invisible to the parser
-- everything else resets multiplier, does nothing
- sign modifiers do nothing in fmt_pack, refer to @fmt_unpack() for their usage info

    printvar( fmt_pack( "3cf", 0, 1, 2, 3 ) ); // prints 'string [7] "\x00\x01\x02\x00\x00@@"'


# fmt_unpack [function]

== fmt_unpack( string fmt, string data )
=== unpacks the byte buffer `data` using the format `fmt`, returns array of unpacked items

- unpacks c/w/l/q/p to integers, f/d to floats, s to strings
- if signed numbers are expected (as set by the "-" modifier), the sign bit of the expected type is extended to the end of the native integer type, this makes the loaded integer signed
- refer to @fmt_pack() for more info about the format

    print fmt_unpack( "3ld", fmt_pack( "3ld", 0, 1, 2, 3 ) ); // prints [0,1,2,3]


# fmt_pack_count [function]

== fmt_pack_count( string fmt )
=== calculates the number of items to be expected in an unpacked array / required to make a successful fmt_pack call

- refer to @fmt_pack() for more info about the format

    print fmt_pack_count( "3ld" ); // prints 4


# fmt_pack_size [function]

== fmt_pack_size( string fmt )
=== calculates the number of bytes generated by a successful fmt_pack call / required to successfully unpack data using the given format

- refer to @fmt_pack() for more info about the format

    print fmt_pack_size( "3ld" ); // prints 20


# fmt_base64_encode [function]

== fmt_base64_encode( string data )
=== encodes data to produce base64 text data

- encoding is done using the following table (shortened): "A-Za-z0-9+/"

    print fmt_base64_encode( "hello world" ); // prints "aGVsbG8gd29ybGQ="


# fmt_base64_decode [function]

== fmt_base64_decode( string b64text )
=== decodes base64 text data

- decoding is done using the table mentioned in @fmt_base64_encode()

    fmt_base64_decode( fmt_base64_encode( "hello world" ) ) == "hello world" // returns true


# fmt_text [function]

== fmt_text( string text, ... )
=== parses all format specifiers in `text` and returns the result

- the general format of a format specifier is as follows: {fmt[size][.prec][r][p<char>]}
-- fmt: one-character output type (b-binary, o-octal, d-decimal, x/X-hexadecimal, f-floating-point, g/G-compact floating-point, e/E-scientific floating-point, s-valid string, c-always converted to string)
-- size: minimum number of characters to print
-- prec: precision of floating-point variables, string length limit
-- r: add "r" to right-pad (left-justify)
-- p<char>: add "p" and any character to set that character as the padding character (default: space/0x20)
- if anything unexpected happens, this function will emit a warning and put "#error#" in the place of a format specifier

    print fmt_text( "{d} -> {x}", 1337, 1337 ); // prints "1337 -> 539"
    print fmt_text( "null: {d}, {s}, {c}", null, null, null ); // prints "null: #error#, #error#, null" and emits two warnings for item 1 and item 2
    print fmt_text( "pi: {f10.10r} {g10r} {E10r}", M_PI, M_PI, M_PI ); // "pi: 3.1415926536 3.14159    3.141593E+000"


# fmt_parser [function]

== fmt_parser( callable[, buffersize ] )
=== creates a @fmt_parser object, connected to the callable

- the callable is a function that returns at most the number of bytes requested from the stream
-- if previous request reached end, subsequent requests must return 'null'

    f = io_file( "test.txt", FILE_READ );
    // usually it is easier to use @fmt_file_parser instead of the next line of code
    p = fmt_parser( closure( function(file,num){ if( file.eof() ) return null; return file.read( num ); }, f ) );


# fmt_string_parser [function]

== fmt_string_parser( string, offset = 0[, buffersize ] )
=== creates a @fmt_parser object, connected to a string reader object, initialized to the given offset and buffer size

    p = fmt_string_parser( "this is a test" );
    p.readcc( "a-z" ); // returns "this"


# fmt_file_parser [function]

== fmt_file_parser( file[, buffersize ] )
=== creates a @fmt_parser object, connected to a file reader object, initialized to the given buffer size

    p = fmt_file_parser( io_file( "something.txt", FILE_READ ) );
    p.readcc( "a-z" ); // returns something


# fmt_charcc [function]

== fmt_charcc( string char, string class )
=== checks if the first character of string `char` is included in the character class `class`

- character class is a regex-like list of specific symbols and ranges (its low and high symbols separated by "-"), optionally prepended by "^" that inverts the scope of the class

    fmt_charcc( ".", "a-zA-Z0-9" ); // returns false
    fmt_charcc( "x", "a-zA-Z0-9" ); // returns true


# fmt_parser [object]

* read-only properties
 - [bool] at_end
 - [bool] stream_offset
 - [cfunc] read
 - [cfunc] getchar
 - [cfunc] readcc
 - [cfunc] skipcc
 - [cfunc] read_real
 - [cfunc] read_int
 - [cfunc] read_binary_int
 - [cfunc] read_octal_int
 - [cfunc] read_decimal_int
 - [cfunc] read_hex_int
 - [cfunc] check
* other features:
 - GC-safe


# fmt_parser.read [method]

== fmt_parser.read( int num )
=== reads at most `num` bytes from stream and returns them as string

- if 0 bytes are returned, it's quite safe to assume that the function has reached the end of file but check the at_end property to be sure
- may return null and emit a warning on unexpected read errors

    stream = fmt_string_parser( "action" );
    stream.read( 5 ); // returns "actio"


# fmt_parser.getchar [method]

== fmt_parser.getchar( bool peek = false, bool as_int = false )
=== returns a character from stream

- if `peek` is true, stream is not advanced (next read operation will also work on the same character)
- if `as_int` is true, character is returned as integer (as one-character string otherwise)
- may return null and emit a warning on unexpected read errors

    stream = fmt_string_parser( "action" );
    stream.read( true ); // returns "a"
    stream.read( true, true ); // returns 97
    stream.read(); // returns "a"
    stream.read(); // returns "c"


# fmt_parser.readcc [method]

== fmt_parser.readcc( string class, int num = 2^31-1 (0x7fffffff) )
=== reads and returns at most `num` bytes that match the character class `class`

- returns null and emits a warning if the class is empty/only contains the inversion symbol "^"
- may return null and emit a warning on unexpected read errors

    stream = fmt_string_parser( "what is this" );
    stream.readcc( "a-z" ); // returns "what"
    stream.readcc( "^a-z" ); // returns " "


# fmt_parser.skipcc [method]

== fmt_parser.skipcc( string class, int num = 2^31-1 (0x7fffffff) )
=== skips at most `num` bytes that match the character class `class` and returns the number of bytes skipped

- returns null and emits a warning if the class is empty/only contains the inversion symbol "^"
- may return null and emit a warning on unexpected read errors

    stream = fmt_string_parser( "what is this" );
    stream.skipcc( "a-z" ); // returns 4
    stream.skipcc( "^a-z" ); // returns 1


# fmt_parser.read_real [method]

== fmt_parser.read_real( bool as_real = true )
=== returns characters read with the character class "-+0-9.eE", optionally returned as a real value


# fmt_parser.read_int [method]

== fmt_parser.read_int( bool as_int = true )
=== returns characters read with the character class "-+0-9A-Fa-fxob", optionally returned as an int value


# fmt_parser.read_binary_int [method]

== fmt_parser.read_binary_int( bool as_int = true )
=== returns characters read with the character class "0-1", optionally returned as an int value


# fmt_parser.read_octal_int [method]

== fmt_parser.read_octal_int( bool as_int = true )
=== returns characters read with the character class "0-7", optionally returned as an int value


# fmt_parser.read_decimal_int [method]

== fmt_parser.read_decimal_int( bool as_int = true )
=== returns characters read with the character class "-+0-9", optionally returned as an int value


# fmt_parser.read_hex_int [method]

== fmt_parser.read_hex_int( bool as_int = true )
=== returns characters read with the character class "0-9a-fA-F", optionally returned as an int value


# fmt_parser.check [method]

== fmt_parser.check( string str, bool ci = false, bool partial = false )
=== returns whether the specified string was found at the current position

- `ci` makes matching case-insensitive
- if `partial` is true, function returns the number of characters successfully matched instead of whether everything has been matched


# <<<


# I/O library ("io") [info]

This library contains the functions necessary to work with the file system (files and directories).

# >>>


# io_setcwd [function]

== io_setcwd( string cwd )
=== sets the current working directory, returns bool/sets errno

- wraps the C library function chdir


# io_getcwd [function]

== io_getcwd()
=== returns the current working directory or null, if for some reason an error occured

- wraps the C library function getcwd/_getcwd


# io_rename [function]

== io_rename( string path, string newpath )
=== attempts to rename the file, returns bool/sets errno

- wraps the C library function rename
- to avoid moving the file/directory, make sure both paths are of the same origin


# io_file_exists [function]

== io_file_exists( string file )
=== checks if file exists and is accessible by the process at the moment, returns true on success, false otherwise

- uses the C library functions fopen/fclose


# io_dir_exists [function]

== io_dir_exists( string dir )
=== checks if directory exists and is accessible by the process at the moment, returns true on success, false otherwise

- uses the C library functions opendir,closedir where supported, _findfirst,_findclose otherwise (Windows/MSVC)


# io_stat [function]

== io_stat( string fsitem )
=== returns info about the file system item `fsitem`, as dict

- the returned object contains the following properties:
-- atime: last access time
-- ctime: creation time
-- mtime: last modification time
-- type: enum (one of FST_DIR/FST_FILE/FST_UNKNOWN)
-- size: size of item
- uses the C library function stat/_stat


# io_dir_create [function]

== io_dir_create( string path, int mode = 0o777 )
=== attempts to create a directory at the specified path, with the specified access mode `mode`, returns bool/sets errno

- `mode` is ignored on Windows
- uses the C library function mkdir/_mkdir


# io_dir_delete [function]

== io_dir_delete( string path )
=== attempts to delete a directory at the specified path, returns bool/sets errno

- uses the C library function rmdir/_rmdir


# io_file_delete [function]

== io_file_delete( string path )
=== attempts to delete a file at the specified path, returns bool/sets errno

- uses the C library function remove


# io_file_write [function]

== io_file_write( string path, string data )
=== writes the byte buffer `data` to the file pointed to by `path`, returns bool/sets errno


# io_file_read [function]

== io_file_read( string path )
=== reads the byte buffer from file at `path`, returns buffer as string or null/sets errno


# io_file [object]

- read-only properties
-- [int] offset
-- [int] size
-- [bool] error
-- [bool] eof
-- [cfunc] open
-- [cfunc] close
-- [cfunc] read
-- [cfunc] write
-- [cfunc] seek
-- [cfunc] flush
-- [cfunc] setbuf
- other features:
-- tostring = "file"
-- tobool = returns whether file is open or not
-- GC-safe
-- type identification (returns the string "file")


# io_file.open [method]

== io_file.open( string name, int mode )
=== closes the previously open file if any, opens the file `name` for operation mode `mode`, returns bool/sets errno

- `mode` must be one of FILE_READ, FILE_WRITE or FILE_READ|FILE_WRITE
- file is always opened in binary mode

    f = io_file();
    f.open( "file" ); // returns true or false, sets errno accordingly


# io_file.close [method]

== io_file.close()
=== closes the previously open file, if any, returns whether the file was open or not

    f = io_file( "file.txt" );
    f.close(); // returns true if the file existed
    f.close(); // returns false


# io_file.read [method]

== io_file.read( int num )
=== reads and returns at most `num` bytes from file, sets errno


# io_file.write [method]

== io_file.write( string data )
=== writes the byte buffer `data` to the file, sets errno


# io_file.seek [method]

== io_file.seek( int off, int mode )
=== sets the offset in file, returns bool/sets errno

- `mode` must be one of SEEK_SET (sets as-is), SEEK_CUR (sets relative to current), SEEK_END (sets relative to end)


# io_file.flush [method]

== io_file.flush()
=== flushes a buffered file, returns bool


# io_file.setbuf [method]

== io_file.setbuf( int size )
=== sets the size of file buffer (0 to disable buffering), returns bool

- buffering allows to avoid committing each write immediately to disk, resulting in a performance gain, however it may introduce issues if application is expected to fail at any moment, resulting in some data not being written in such cases


# io_file [function]

== io_file([ string name, int mode ])
=== creates and returns a file, optionally allowing to open it on creation

- see @io_file.open() for more info on opening the file


# io_dir (directory_iterator) [object]

- features:
-- tostring = "directory_iterator"
-- iterator interface (key = whether real item, value = item name)
--- real items are all except "." and ".."
-- returns self as iterator
-- GC-safe
-- type identification (returns the string "directory_iterator")


# io_dir [function]

== io_dir( string dir )
=== creates a directory iterator for the directory `dir`, sets errno, returns null and emits a warning on failure


# FILE_*** [constants]

== FILE_READ, FILE_WRITE
=== mode constants for @io_file.open() / @io_file()


# SEEK_*** [constants]

== SEEK_SET, SEEK_CUR, SEEK_END
=== mode constants for @io_file.seek()


# FST_*** [constants]

== FST_UNKNOWN, FST_FILE, FST_DIR
=== file system item type constants for @io_stat()


# <<<


# Math library ("math") [info]

This library contains the basic math functions for processing real values.

# >>>


# abs [function]

== abs( x )
=== returns the absolute value of `x`, as `real`

    abs( 2.2 ); // real (2.2)
    abs( -3.1 ); // real (3.1)


# floor [function]

== floor( x )
=== returns the largest integer that is not bigger than `x`, as `real`

    floor( 3.4 ); // real (3)
    floor( 3.8 ); // real (3)
    floor( 4.2 ); // real (4)
    floor( -3.1 ); // real (-4)


# ceil [function]

== ceil( x )
=== returns the smallest integer that is not smaller than `x`, as `real`

    ceil( 3.4 ); // real (4)
    ceil( 3.8 ); // real (4)
    ceil( 4.2 ); // real (5)
    ceil( -3.1 ); // real (-3)


# round [function]

== round( x )
=== returns the closest integer to `x`, as `real`

    round( 3.4 ); // real (3)
    round( 3.8 ); // real (4)
    round( 4.2 ); // real (4)
    round( -3.1 ); // real (-3)


# pow [function]

== pow( x, y )
=== returns `x` raised to the power `y`, as `real`

- If base (`x`) is negative and exponent (`y`) is not an integral value, or if base is zero and exponent is negative, function returns `null` and emits a warning message.

    pow( 2, 5 ); // real (32)
    pow( 9, 0.5 ); // real (3)
    pow( -1, 0.5 ); // null; Warning: pow(): mathematical error


# sqrt [function]

== sqrt( x )
=== returns the square root of `x`, as `real`

- If `x` is negative, function returns `null` and emits a warning message.

    sqrt( 16 ); // real (4)
    sqrt( -1 ); // null; Warning: sqrt(): mathematical error


# log [function]

== log( x, y )
=== returns the base-`y` logarithm of `x`, as `real`

- If `x <= 0`  or  `b <= 0`  or  `b = 1`, function returns `null` and emits a warning message.

    log( 9, 3 ); // real (2)
    log( -1, 3 ); // .. or ..
    log( 3, 0 ); // .. or ..
    log( 3, 1 ); // null; Warning: log(): mathematical error


# sin [function]

== sin( x )
=== returns the sine of angle `x` in radians, as `real`

    sin( 0 ); // real (0)
    sin( M_PI / 2 ); // real (1)
    sin( M_PI / 4 ); // real (0.707107)


# cos [function]

== cos( x )
=== returns the cosine of angle `x` in radians, as `real`

    sin( 0 ); // real (1)
    sin( M_PI ); // real (-1)
    sin( M_PI / 4 ); // real (0.707107)


# tan [function]

== tan( x )
=== returns the tangent of angle `x` in radians, as `real`

    tan( 0 ); // real (0)
    tan( 1 ); // real (1.55741)
    tan( M_PI / 4 ); // real (1)


# asin [function]

== asin( x )
=== returns the arcsine of `x` (angle in radians), as `real`

- If `x` is outside the [-1,1] range, function returns `null` and emits a warning message

    asin( -1 ); // real (-1.5708)
    asin( 0 ); // real (0)
    asin( 2 ); // null; Warning: asin(): mathematical error


# acos [function]

== acos( x )
=== returns the arccosine of `x` (angle in radians), as `real`

- If `x` is outside the [-1,1] range, function returns `null` and emits a warning message

    acos( -1 ); // real (3.14159)
    acos( 0 ); // real (1.5708)
    acos( 2 ); // null; Warning: acos(): mathematical error


# atan [function]

== atan( x )
=== returns the arctangent of `x` (angle in radians), as `real`

    atan( 0 ); // real (0)
    atan( 1 ); // real (0.785398)
    atan( 9999999 ); // real (1.5708)


# atan2 [function]

== atan2( y, x )
=== returns the extended arctangent of y/x (angle in radians), as `real`

- Signs of `x` and `y` are used to determine the quadrant, thus `y` is expected to be the sine of the angle to be returned (the `y` coordinate of a point) and `x` - the cosine (the `x` coordinate).

! Due to the common requirement to use this function to determine the angle between two somewhat random points (usually from a simulation), it will not emit a warning when both arguments are 0 - it will return 0 instead.

    atan2( 0, 1 ); // real (0)
    atan2( 1, 0 ); // real (1.5708)
    atan2( -1, -1 ); // real (-2.35619)
    atan2( 0, 0 ); // real (0)


# deg2rad [function]

== deg2rad( x )
=== returns angle, converted from degrees to radians, as `real`

    deg2rad( 0 ); // real (0)
    deg2rad( 180 ); // real (3.14159)
    deg2rad( -90 ); // real (-1.5708)


# rad2deg [function]

== rad2deg( x )
=== returns angle, converted from radians to degrees, as `real`

    rad2deg( 0 ); // real (0)
    rad2deg( M_PI ); // real (180)
    rad2deg( -M_PI / 2 ); // real (-90)


# M_*** [constants]

== M_PI
=== the ratio of circumference of a circle to its diameter (pi)
- the value of this constant is `3.14159265358979323846`

== M_E
=== the natural logarithmic base (e)
- the value of this constant is `2.7182818284590452354`


# <<<


# OS library ("os") [info]

# This function deals with data that can be retrieved from the operating system. This includes the following data sources:

- environment variables
- time and date
- locale / regional settings

# >>>


# os_gettype [function]

== os_gettype()
=== returns the name of the closest known match for the operating system type, defined at library compile time

- the function can detect and return the following OSes at the moment (with the preprocessor define in braces):
-- "Windows" (_WIN32)
-- "Linux" (__linux)
-- "Unix" (__unix)
-- "POSIX" (__posix)
-- "Unknown" (..any other)


# os_command [function]

== os_command( string cmd )
=== passes a command to the OS command processor, returns the integer return value

! this function can be extremely unsafe in multithreaded/incontrollable environments due to the completely undefined outcome of the call

- uses the C library function 'system'


# os_getenv [function]

== os_getenv( string var )
=== returns the value for the environment variable `var` or null, if there is no such value


# os_putenv [function]

== os_putenv( string cmd )
=== sets the value for the environment variable specified in command `cmd`, returns success as bool

- `cmd` has the format "<name>=<value>"


# os_time [function]

== os_time( real tz = <local> )
=== returns the time in seconds, as integer, optionally from a different timezone `tz`


# os_get_timezone [function]

== os_get_timezone( bool as_string = false )
=== returns the timezone set in the operating system, optionally as string in the format "(+/-)HH:MM"


# os_date_string [function]

== os_date_string( string fmt, int time = os_time() )
=== returns the date/time string in the format `fmt`, optionally for a different time `time`

- the following item specifiers are supported (*-local-specific):
-- %a: abbreviated weekday name *
-- %A: full weekday name *
-- %b: abbreviated month name *
-- %B: full month name *
-- %c: full date/time *
-- %x: full date *
-- %X: full time *
-- %Z: timezone name/abbreviation (could be an empty string) *
-- %U: week number with first Sunday as the first day of week one *
-- %W: week number with first Monday as the first day of week one *
-- %C: year/100, as integer
-- %d: zero-padded day of the month (01-31)
-- %e: space-padded day of the month ( 1-31)
-- %F: date, shortcut of "%Y-%m-%d"
-- %H: hour in 24h format (00-23)
-- %I: hour in 12h format (01-12)
-- %j: day of the year (001-366)
-- %m: month number (01-12)
-- %M: minute (00-59)
-- %p: AM or PM
-- %R: hour/minute time, shortcut to %H:%M
-- %s: second (00-61)
-- %T: time, shortcut to %H:%M:%S
-- %u: weekday with Sunday as 0
-- %w: weekday with Monday as 1
-- %y: 2-digit year (00-99)
-- %Y: year
-- %f: file-safe full time, shortcut to %Y-%m-%d_%H-%M-%S
-- %t: the UNIX timestamp
-- %%: prints "%"
-- %<any other>: prints both characters


# os_parse_time [function]

== os_parse_time( int time = os_time() )
=== returns `time` split into parts, as dict

- the returned dict contains the following properties (all are integers):
-- year (1900-????)
-- month (1-12)
-- day (1-31)
-- weekday (1-7)
-- yearday (1-366)
-- hours (0-23)
-- minutes (0-59)
-- seconds (0-61)


# os_make_time [function]

== os_make_time( int sec, int min = 0, int hour = 0, int mday = 0, int mon = 0, int year = 0 )
=== returns time as UNIX timestamp, generated from the arguments, using them as hints (under-/overflows may have some unexpected behavior)


# os_get_locale [function]

== os_get_locale( int which )
=== returns the currently set locale for the specified category

- `which` must be one of the LC_ constants
- the returned string is platform-specific
- wraps the C library function setlocale


# os_set_locale [function]

== os_set_locale( int which, string locale )
=== sets the locale for the specified category, returning whether the call was successful

- `which` must be one of the LC_ constants
- the available locale strings are platform-specific
- wraps the C library function setlocale


# os_get_locale_format [function]

== os_get_locale_format()
=== retrieve the formatting info of the currently set locale as a dict

- wraps the C library function localeconv
- the returned data is identical to pre-C99 format of struct lconv


# os_locale_strcmp [function]

== os_locale_strcmp( string a, string b )
=== compare two strings using locale to return correct sign for inequalities (good for language-correct sorting)

- expected encoding depends on the platform and the locale that is currently set
- wraps the C library function strcoll


# LC_*** [constants]

These constants specify the categories for which locale can be changed.

- LC_ALL affects every locale-related function
- LC_COLLATE: os_locale_strcmp
- LC_MONETARY: os_get_locale_format
- LC_NUMERIC: os_get_locale_format
- LC_TIME: os_date_string


# <<<


# Regular expression library ("re") [info]

This library includes regular expression match & replace functions.

# >>>


# re_match [function]

== re_match( string str, string pattern, int flags = 0, int offset = 0 )
=== check for matches in string `str` for `pattern`, returning whether a match was found or details of the first match, as specified in `flags`

- `offset` specifies the character to start matching from, negative offset is subtracted from the end
- `flags` expect RE_RETURN_CAPTURED, RE_RETURN_OFFSETS or RE_RETURN_BOTH, which is a combination of the previous two
-- if `flags` is one of the special values, function returns an array of captured ranges
--- each entry is either a string (on RE_RETURN_CAPTURED) or an array of beginning and end offsets (at positions 0 and 1, respectively, on RE_RETURN_OFFSETS) or an array of a string and the beginning and end offsets (on RE_RETURN_BOTH)
- the first character in the pattern specifies a delimiter that separates the pattern from modifiers
-- example pattern strings: "/^[a-z]+/mi", "#[a-z0-9_]+.*?#s"
- more info about the supported features and modifiers at https://github.com/snake5/sgregex


# re_match_all [function]

== re_match_all( string str, string pattern, int flags = 0, int offset = 0 )
=== check for matches in string `str` for `pattern`, returning the number of matches or details of all matches, as specified in `flags`

- similar to @re_match, only difference is in the return value:
-- if `flags` is one of the special values, function returns an array of matches where each match is an array of captured ranges
--- each entry is same as in @re_match


# re_replace [function]

== re_replace( string str, string pattern, string replacement )
=== find and replace all occurrences of `pattern` in string `str` with the `replacement` string

- replacement string can contain backreferences in the forms "$[0-9]" or "\[0-9]" (in a string constant, a double backslash is required due to rules in SGScript)
-- there can be up to 10 backreferences, 0-9, 0 being the whole match


# <<<


# String library ("string") [info]

This library contains the string handling functions. In all functions, except the utf-8 ones, it is assumed that strings are byte buffers where each byte is one character. If correct indices are applied, many of them will work with multibyte strings.

# >>>


# string_cut [function]

== string_cut( string str, int from[, int to[, int flags]] )
=== returns a part of string `str`, `from` and `to` being positions of the first and last character returned, respectively

- if `to` is not specified, `to` is assumed to be the position of the last character in string `str`
- if `from` or `to` are negative, they point to characters before the end of string (-1 being the last one)
- available values for `flags`:
-- `STRING_NO_REV_INDEX` - emit warnings on negative indices, instead of handling them
-- `STRING_STRICT_RANGES` - emit warnings on out of bounds `from`/`to` values instead of silently ignoring the outside characters

    string_cut( "01234567", 3, 5 ); // string [3] "345"


# string_part [function]

== string_part( string str, int from[, int len[, int flags]] )
=== returns a part of string `str`, starting at `from`, at most `len` characters

- if `len` is not specified, `len` is assumed to be the number of characters between `from` and the end of string `str`
- if `from` is negative, it points to characters before the end of string (-1 being the last one)
- if `len` is negative, the maximum length of returned string is the sum of `len` and string `str` length
- available values for `flags`:
-- `STRING_NO_REV_INDEX` - emit warnings on negative indices, instead of handling them
-- `STRING_STRICT_RANGES` - emit warnings on out of bounds `from`/`len` values instead of silently ignoring the outside characters

    string_part( "01234567", 3, 3 ); // string [3] "345"


# string_reverse [function]

== string_reverse( string str )
=== returns `str` with all the bytes in reversed order

! This function will not work correctly with multibyte-encoded strings.

    string_reverse( "noitca" ); // string [6] "action"


# string_pad [function]

== string_pad( string str, int tgtsize, string padstr = " ", int flags = STRING_PAD_RIGHT )
=== return the string `str`, padded from template `padstr` up to the size `tgtsize` according to `flags`

- if `str` is longer than `tgtsize`, it is returned without changes
- available values for `flags`:
-- `STRING_PAD_LEFT` - pad the string at the left side
-- `STRING_PAD_RIGHT` - pad the string at the right side
-- if both flags are OR'ed together, the string `str` is centered
-- at least one of the flags must be specified if the argument is passed for the function to work

    string_pad( "padded", 10 ); // string [10] "padded    "
    string_pad( "center", 10, "_", STRING_PAD_LEFT | STRING_PAD_RIGHT ); // string [10] "__center__"


# string_repeat [function]

== string_repeat( string str, int count )
=== return the string `str`, appended to itself `count`-1 times or an empty string if `count` is equal to 0

- `count` must be greater than or equal to 0

    string_repeat( "na", 6 ); // string [12] "nananananana"
    string_repeat( "none", 0 ); // string [0] ""


# string_count [function]

== string_count( string str, string substr, bool overlap = false )
=== returns the number of substrings `substr` found in string `str`

- if `overlap` is true, function does not skip substrings when they are found

    string_count( "abababa", "aba" ); // int 2
    string_count( "abababa", "aba", true ); // int 3


# string_find [function]

== string_find( string str, string substr, int offset = 0 )
=== returns the position of first found substring `substr` in string `str`, starting at `offset`

- if `substr` was not found, 'null' is returned
- if `offset` is less than 0, it specifies offset from the end

    string_find( "what hat", "hat" ); // int 1
    string_find( "what", "hat", 2 ); // null


# string_find_rev [function]

== string_find_rev( string str, string substr, int offset = 0 )
=== returns the position of last found substring `substr` in string `str`, starting at `offset`

- if `substr` was not found, 'null' is returned
- if `offset` is less than 0, it specifies offset from the end

    string_find_rev( "what hat", "hat" ); // int 5
    string_find_rev( "what", "hat", 2 ); // int 1


# string_replace [function]

== string_replace( string str, string from, string to )
== string_replace( string str, array from, string to )
== string_replace( string str, array from, array to )
=== replaces parts of string `str`, specified in `from`, to the respective values passed in `to`

- the respective replacement is picked by taking the substring index and performing modulo operation with the number of replacement strings

    string_replace( "loaded %num files", "%num", 5 ); // string [14] "loaded 5 files"
    string_replace( "abcd", ["a","b","c","d"], [1,2,3,4] ); // string [4] "1234"
    string_replace( "1234", ["1","2","3","4"], ["x","y"] ); // string [4] "xyxy"


# string_translate [function]

== string_translate( string str, iterable repmap )
=== replaces parts of string `str`, specified in the keys of `repmap`, to the matching values of the same iterable

    string_translate( "found %a files and %b folders", {"%a" = 5, "%b" = 17} ); // string [28] "found 5 files and 17 folders"


# string_trim [function]

== string_trim( string str, string chars = " \t\r\n", int flags = STRING_TRIM_LEFT | STRING_TRIM_RIGHT )
=== removes the specified characters from the specified sides of the string

- available values for `flags`:
-- `STRING_TRIM_LEFT` - trim the string from the left side
-- `STRING_TRIM_RIGHT` - trim the string from the right side

    string_trim( "  space  " ); // string [5] "space"
    string_trim( "..something!..", ".!", STRING_TRIM_RIGHT ); // string [11] "..something"


# string_toupper [function]

== string_toupper( string str )
=== converts all ASCII lowercase letter characters of the string to uppercase

    string_toupper( "Test" ); // string [4] "TEST"


# string_tolower [function]

== string_tolower( string str )
=== converts all ASCII uppercase letter characters of the string to lowercase

    string_toupper( "Test" ); // string [4] "test"


# string_compare [function]

== string_compare( string str1, string str2, int max = 0, int from = 0 )
=== compares the two strings or the specified portions of them

    string_compare( "what", "whaT" ); // int 1
    string_compare( "what", "whaT", 3 ); // int 0
    string_compare( "file.txt", ".txt", 0, -4 ); // int 0


# string_implode [function]

== string_implode( array items, string sep )
=== concatenates the string representations of array `items` values, putting a string `sep` between each two

    string_implode( ["one","two","three"], ", " ); // string [15] "one, two, three"


# string_explode [function]

== string_explode( string str, string sep )
=== splits the string `str` into an array of substrings, separated by string `sep`

    string_explode( "www.example.com", "." ); // ["www","example","com"]
    string_explode( "x", "-" ); // ["x"]
    string_explode( "/some//data", "/" ); // ["","some","","data"]


# string_charcode [function]

== string_charcode( string str, int offset = 0 )
=== returns the byte value / ASCII character code of the specified byte in the string

    string_charcode( "Test" ); // int 84
    string_charcode( "Test", 3 ); // int 116


# string_frombytes [function]

== string_frombytes( int byteval )
== string_frombytes( array bytes )
=== returns a string, created from either one byte value (overload #1) or an array of byte values (overload #2)

- byte values must be in the range [0-255]

    string_frombytes( 53 ); // string [1] "5"
    string_frombytes([ 84, 101, 115, 116 ]); // string [4] "Test"


# string_utf8_decode [function]

== string_utf8_decode( string ustr )
=== returns an array of Unicode code points, decoded from the UTF-8 string `ustr`

- invalid byte sequences will add 0xFFFD to the array

    string_utf8_decode( "pie" ); // [112,105,101]
    string_utf8_decode( "" ); // [1082,1086,1076]
    string_utf8_decode( "" ); // [27161,28310]


# string_utf8_encode [function]

== string_utf8_encode( array cplist )
=== returns a UTF-8 string, composed from the Unicode code point list `cplist`

! Without proper terminal software UTF-8 strings will not be displayed correctly (as is the case on Windows).

- invalid code points will add "\xEF\xBF\xBD" (0xFFFD code point as UTF-8) to the string

    string_utf8_encode( [112,105,101] ); // string [3] "pie"
    string_utf8_decode( [1082,1086,1076] ); // string [6] ""
    string_utf8_decode( [27161,28310] ); // string [6] ""


# string_format [function]

== string_format( string text, ... )
=== parses all format specifiers in `text` and returns the result

- the format specifier has the form {<id>:<specifier>} where "id" is the argument index to use and specifier is a @fmt_text specifier
- argument indices to be used in specifiers start from 1

    print string_format( "{1:d} -> {1:x}", 1337 ); // prints "1337 -> 539"


# <<<


# <<<


# Additional info [info]
# >>>


# Serialization in SGScript [info]

In SGScript, serialization is conversion to a binary stream of a specific format. Serialization in the language API is done by calling the "serialize" function and deserialization is done with "unserialize". The C API has similar functions: sgs_Serialize/sgs_SerializeObject and sgs_Unserialize, respectively.

! check the "Possible gotchas" part of this page if it is intended to trust the end user with access to serialized data

=== The format

- a list of operations
- each operation consists of a 'type' byte and additional data
-- a "push" operation has the byte 'P', the data consists of the type to push (a byte consisting of one base flag from SGS_VT_*) and the binary data of the type
-- a "call" operation has the byte 'C', the data consists of the number of arguments (4 bytes), function name length (1 byte) and the null-terminated function name itself (<length>+1 bytes)

=== Serialization

- "serialize" is called
- "sgs_Serialize" is called internally
- type of variable is determined and the data is written
-- C functions cannot be serialized (obviously) and whenever encountered, will abort the action
-- objects will have SGS_OP_SERIALIZE operation called
--- if operation is not defined, everything will stop
--- if object is an array, all variables in it will be serialized using sgs_Serialize and sgs_SerializeObject will generate a call to 'array'
--- if object is a 'dict', all keys and values in it will be serialized using sgs_Serialize and sgs_SerializeObject will generate a call to 'dict'

=== Deserialization

- "unserialize" is called
-- the global environment could be changed
- "sgs_Unserialize" is called internally
- "push" and "call" operations are executed, thus regenerating the data
-- "push" operation pushes a variable on the stack
-- "call" operation calls the specified function

=== Possible gotchas

- unserialization is not by default safe in the sense that any function can be executed with a carefully crafted byte buffer; this can be prevented by specifying the second parameter to the "unserialize" function. the behavior can be reproduced with the C API but it will take a bit more effort or calling the "unserialize" function from it
- sgs_Serialize overrides the output function so any output done via "print" or "sgs_Write*" functions during serialization will corrupt the stream
- if environment overrides are used on deserialization, remember to add "array" and "dict" to the list if you use them, they are not added automatically
- serialization will not preserve any variable reuse relationships so after deserialization the structure could use more memory than before; if more efficient behavior is desired, it is suggested to serialize an array of unique items and a structure of indices to those items


# <<<


